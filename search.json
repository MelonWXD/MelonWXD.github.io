[{"title":"Gradle构建学习","url":"/2019/06/05/gradle-1/","content":"Gradle入门\n\n<!-- more -->  \n\n# 综述\n## LifeCycle\n\n### Initialization\n\nGradle supports single and multi-project builds. During the initialization phase, Gradle determines which projects are going to take part in the build, and creates a [Project](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html) instance for each of these projects.\n\n确定参与构建的项目，为每个项目创建一个`project`实例。Android中就是根据`setting.grade`中声明的项目来创建。具体步骤见下面CoreType-Project。\n\n### Configuration\n\nDuring this phase the project objects are configured. The build scripts of *all* projects which are part of the build are executed.\n\n执行每个项目自己的build scripts构建脚本。Android中就是执行个module中的`build.grade`。\n\n### Execution\n\nGradle determines the subset of the tasks, created and configured during the configuration phase, to be executed. The subset is determined by the task name arguments passed to the `gradle` command and the current directory. Gradle then executes each of the selected tasks.\n\n决定要执行的任务的子集(第二阶段中创建和配置的)。\n\n## CoreType\n\n### Project\n\nGradle对外的接口，通过这个接口来编程使用Gradle的各种功能。\n\nProject和`build.gradle`文件是一对一关系，在`Initialization`时期，Gradle会为每个参与构建的项目创建一个`project`实例。步骤如下：\n\n1. 为本次构造创建一个`Settings`实例\n\n2. 读取`settings.gradle`来配置上面的`Settings`对象\n3. 通过上面的`Settings`对象来创建`Project`实例\n4. 执行每个项目的`build.gradle`来配置每个`Project`实例\n\n### Task\n\n`Project`可以算是由一堆`Task`构成的集合。每个`Task`各司其职，比如编译代码、跑单元测试、压缩对齐等。\n\n[`TaskContainer.create(java.lang.String)`](https://docs.gradle.org/4.4/javadoc/org/gradle/api/tasks/TaskContainer.html#create(java.lang.String))是用来添加`Task`的，通过[`TaskCollection.getByName(java.lang.String)`](https://docs.gradle.org/4.4/javadoc/org/gradle/api/tasks/TaskCollection.html#getByName(java.lang.String))也可以获取到某个具体的`Task`实例。\n\n\n\n### Plugins\n\n`Plugins`可以用于模块化与项目配置复用。\n\nPlugins can be applied using the [`PluginAware.apply(java.util.Map)`](https://docs.gradle.org/4.4/dsl/org.gradle.api.plugins.PluginAware.html#org.gradle.api.plugins.PluginAware:apply(java.util.Map)) method, or by using the [`PluginDependenciesSpec`](https://docs.gradle.org/4.4/dsl/org.gradle.plugin.use.PluginDependenciesSpec.html) plugins script block.\n\n\n\n# Android 编译流程\n\n图例可以看[之前的博客](https://melonwxd.github.io/2017/10/10/dalvik-art/)\n\n这里主要基于Gradle的命令展开\n\n用Gradle打个debug包的命令如下，—info是为了打印出详细信息  并输出到文件 方便观察\n\n> ./gradlew --info assembleDebug  > ~/Desktop/gradle.info\n\n开始一步步看日志吧\n\n## Initialization\n\n读取settings\n\n```java\nStarting Build\nSettings evaluated using settings file '/Users/wengxiaodong/AndroidStudioProjects/VideoLearn/settings.gradle'.\nProjects loaded. Root project using build file '/Users/wengxiaodong/AndroidStudioProjects/VideoLearn/build.gradle'.\nIncluded projects: [root project 'VideoLearn', project ':app']\n```\n\n## Configuration\n\n```java\n> Configure project :\nEvaluating root project 'VideoLearn' using build file '/Users/wengxiaodong/AndroidStudioProjects/VideoLearn/build.gradle'.\n\n> Configure project :app\nEvaluating project ':app' using build file '/Users/wengxiaodong/AndroidStudioProjects/VideoLearn/app/build.gradle'.\n```\n\n\n\n```java\nAll projects evaluated.\nSelected primary task 'assembleDebug' from project :\nTasks to be executed: [\n  task ':app:preBuild', \n  task ':app:preDebugBuild', \n  task ':app:compileDebugAidl',     //编译AIDL\n  task ':app:compileDebugRenderscript', \n  task ':app:checkDebugManifest',  \n  task ':app:generateDebugBuildConfig',  //BuildConfig.java\n  task ':app:prepareLintJar', \n  task ':app:generateDebugSources', \n  task ':app:javaPreCompileDebug', \n  task ':app:mainApkListPersistenceDebug', \n  task ':app:generateDebugResValues',  //Res\n  task ':app:generateDebugResources',   \n  task ':app:mergeDebugResources', \n  task ':app:createDebugCompatibleScreenManifests', \n  task ':app:processDebugManifest',  //Manifest\n  task ':app:processDebugResources', \n  task ':app:compileDebugJavaWithJavac',  //javac编译\n  task ':app:compileDebugSources', \n  task ':app:mergeDebugShaders', \n  task ':app:compileDebugShaders',   \n  task ':app:generateDebugAssets',   //生成assets\n  task ':app:mergeDebugAssets',      //合并assets\n  task ':app:checkDebugDuplicateClasses', \n  task ':app:mergeExtDexDebug',   //dex\n  task ':app:mergeLibDexDebug', \n  task ':app:transformClassesWithDexBuilderForDebug', \n  task ':app:mergeProjectDexDebug', \n  task ':app:validateSigningDebug', \n  task ':app:signingConfigWriterDebug', \n  task ':app:mergeDebugJniLibFolders',  //jni\n  task ':app:transformNativeLibsWithMergeJniLibsForDebug', \n  task ':app:transformNativeLibsWithStripDebugSymbolForDebug', \n  task ':app:processDebugJavaRes', \n  task ':app:transformResourcesWithMergeJavaResForDebug', //resources.arsc\n  task ':app:packageDebug',  //打包\n  task ':app:assembleDebug'  //apk\n] \n```\n\n\n\n## Execution\n\nlog太多自行查看  就是执行上面的task\n\n# 参考\n\n[写给 Android 开发者的 Gradle 系列（一）基本姿势](https://blog.csdn.net/ziwang_/article/details/80276839)\n\n[通过gradle生成apk的过程](https://blog.csdn.net/kylewo/article/details/82632154)\n\n[Gradle Build Language Reference](https://docs.gradle.org/4.4/dsl/)\n\n[Android Plugin DSL Reference](https://google.github.io/android-gradle-dsl/3.1/)","tags":["Gradle","Android构建"],"categories":["Android"]},{"title":"音视频中的基础概念","url":"/2019/05/15/音视频与FFmpeg学习汇总/","content":"\n音视频学习笔记第一篇~\n\n<!-- more -->  \n\n\n\n# 格式\n\n## 颜色（像素）格式\n\n详见参考\n\n### RGB\n\n作为android开发最熟悉的就是rgb格式了，\n\n在RGB颜色空间中，任意色光F都可以用R、G、B三色不同分量的相加混合而成：F=r[R]+r[G]+r[B]\n\n![](https://github.com/MelonWXD/BlogPicStorage/blob/master/rgb%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B.jpeg?raw=true)\n\n### HSV\n\nHSV是一种将RGB色彩空间中的点在倒圆锥体中的表示方法。HSV即色调(Hue)、饱和度(Saturation)、明度(Value)，又称HSB(B即Brightness)。\n\n色调H：一些基础颜色\n\n饱和度S：用过ps就很好理解这个了，我理解的话是色彩的鲜艳程度，S=0就是灰度化\n\n明度V：就是亮度了，看右图就很好理解了，V=0就是暗的一B，黑色，V=max，就是亮瞎狗眼，白色。\n\n![](https://github.com/MelonWXD/BlogPicStorage/blob/master/hsv颜色模型.jpeg?raw=true)\n\n### YUV\n\nYUV则是把颜色用一种更直接抽象的方式来表达，“Y”表示明亮度，“U”和“V” 表示的则是色度。Y是通过RGB信号特定部分**叠加**得到的，UV则用来反应颜色的**色调**和**饱和度**。分别用Cr和Cb来表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。\n\n采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白。黑白电视只利用Y分量，也解决了黑白电视和彩色电视的兼容问题。\n\n有公式可以转换为RGB，上述的`NV21`算是它的子集了。\n\n![](https://github.com/MelonWXD/BlogPicStorage/blob/master/yuv%E9%A2%9C%E8%89%B2%E6%A0%BC%E5%BC%8F1.png?raw=true)\n\n![](https://github.com/MelonWXD/BlogPicStorage/blob/master/yuv%E9%A2%9C%E8%89%B2%E6%A0%BC%E5%BC%8F2.png?raw=true)\n\n\n\n## 视频的编码格式\n\n视频我们都知道，是由一帧又一帧的图片连续显示组成的。\n\n假设有个帧率为20的1080*720分辨率的视频，1秒播放20张图片，每一帧图片用的是RGB565格式，即一个像素点占16bit。那么根据上面已知条件，可以计算出想要在线播放这段视频时需要的网速应该要 `20x1080x720x16/8 =31104000 `，即29M/s，显然不现实，更别说服务器要花多少空间来存这个视频了。\n\n所以就出现了一系列的算法标准和规范，来压缩视频大小。\n\n![偷图小冬瓜又来了](https://github.com/MelonWXD/BlogPicStorage/blob/master/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png?raw=true)\n\n### H.264\n\n> 注意区别 \n>\n> MPEG-4是一整套的音频，视频，编解码标准的集合\n>\n> H.264是一个国际标准的视频编码压缩格式 它跟MPEG-4的视频压缩编码是一致的 是MPEG-4的第10部分\n\n具体的Data Struct详见参考。这里只是简单说一下基础的概念。\n\n视频帧经过算法压缩后的帧分为：I帧，P帧和B帧:\n\nI帧：关键帧，采用帧内压缩技术。\n\nP帧：向前参考帧，在压缩时，只参考前面已经处理的帧。采用帧音压缩技术。 \n\nB帧：双向参考帧，在压缩时，它即参考前而的帧，又参考它后面的帧。采用帧间压缩技术。\n\nGOP:两个I帧之间是一个图像序列，在一个图像序列中只有一个I帧。\n\n我的理解是他存储的是每一帧指间的差异，因为视频嘛，图片都是具有连贯性的。而关键帧I帧就是定下基调的一帧，对应的GOP中都是基于I帧不断修修补补的，编码时发现无法恢复信息时，就又会生成一个I帧，结束当前GOP。\n\n### 其他的压缩格式 ：VP9 ...\n\n了解的不多 待补充\n\n## 视频的封装格式\n\n我们常见的**音视频**文件格式，诸如avi、mp4和rmvb都是封装格式。\n\n跟上面编码格式的区别是什么？我觉得最大的就是封装格式里面含有音频流信息呗。\n\n### MP4\n\n详见参考\n\n![](https://github.com/MelonWXD/BlogPicStorage/blob/master/MP4%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg?raw=true)\n\n\n\n这种文件格式的解析，基本套路都是一样的。\n\n\n\n## 音频的编码格式\n\n音频常见的压缩格式为aac mp3\n\n\n\n# Android中的音视频操作\n\n了解完格式，让我们描述一个完整的android视频操作：相机录像。\n\n## 相机录像\n\n根据 `android/hardware/Camera.java` 内部类Parameters的setPreviewFormat方法注释可以知道\n\n```java\n/**\n * Sets the image format for preview pictures.\n * <p>If this is never called, the default format will be\n * {@link android.graphics.ImageFormat#NV21}, which\n * uses the NV21 encoding format.</p>\n ...\n */\npublic void setPreviewFormat(int pixel_format) {...}\n\n```\n\n默认情况下 相机预览得到的照片的**颜色格式**是`NV21`，[这里](<https://developer.android.com/reference/android/graphics/ImageFormat.html>)可以看到android中支持的所有ImageFormat。\n\n系统提供一个`YuvImage`的类，支持把`NV21`压缩成`JPEG`格式的图片，这个可能是我们比较熟悉的图片格式。\n\n> 注意\n>\n> 这里`NV21`是**颜色格式**，属于`YUV420`类别的，同级别的比较应该是`HSV`与`RGB`。而`JPEG`是**图片格式**，同级别比较的是`PNG`、`BMP`这种的。\n\n 我们是可以在`Camera.onPreviewFrame(byte[] bytes, Camera camera)`回调方法中拿到这些数据\n\n下面就要用到Android的编码类`MediaCodec` 对数据帧进行压缩编码\n\n### MediaCodec \n\n典型的生产消费模型。\n\n编解码器可以处理三种类型的数据：\n\n1. 压缩数据（即为经过H254. H265. 等编码的视频数据或AAC等编码的音频数据）\n2. 原始音频数据\n3. 原始视频数据\n\n![](https://github.com/MelonWXD/BlogPicStorage/blob/master/mediacodec.png?raw=true)\n\n### MediaMuxer\n\n将音频编码和视频编码合成为封装格式(.mp4 .avi)的Android api类\n\n相应的还有**MediaExtractor**来负责解封装  从封装格式中提取音频流和视频流\n\n音频的获取主要依赖**AudioRecord**、**AudioTrack**  就不展开了细说了 跟视频一个意思\n\n\n\n## 相机录像流程图\n\n![](https://github.com/MelonWXD/BlogPicStorage/blob/master/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0-%E5%BD%95%E5%88%B6-%E6%92%AD%E6%94%BE.jpg?raw=true)\n\n注意，这个过程是可逆的，反过来就是安卓如何播放一个mp4了，合成器变分离器，编码器变解码器，输出到Surface上显示和AudioManager里播放就是了。至于音频的采集和编码就不赘述了，一个道理。\n\n## 其他\n\n### FFmpeg\n\nAndroid在MediaCodec出现之前使用的编解码工具，用c写的，通过so库调用，软编码，兼容性好，性能略低。\n\n### openGL ES\n\n这里水深，后续有机会再扩展。\n\n据我了解的在安卓中的应用应该是滤镜。\n\n应用时机应该是在YUV格式阶段。\n\n\n\n\n\n# 参考\n\n[常见视频编码格式解析](https://blog.csdn.net/houxiaoni01/article/details/78812485/)\n\n[颜色空间模型](https://www.cnblogs.com/yooyoo/p/4717746.html)\n\n[H264 基本原理](https://blog.csdn.net/garrylea/article/details/78536775)\n\n[H264 结构](https://juejin.im/post/5a8fe66b6fb9a0633e51eadc)\n\n[mp4结构](<https://www.cnblogs.com/ranson7zop/p/7889272.html>)","tags":["音视频"],"categories":["Android"]},{"title":"Android和Java多线程学习","url":"/2018/04/16/多线程相关/","content":"Android和Java中的多线程学习\n<!-- more -->  \n\n# 综述\n\nAndroid提供了四种常用的操作多线程的方式，分别是：\n1. HandlerThread\n2. AsyncTask\n3. IntentService\n4. ThreadPoolExecutor\n\n> - **HandlerThread:** 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。\n> - **AsyncTask:** 为 UI 线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。\n> - **IntentService:** 适合于执行由 UI 触发的后台 Service 任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。\n> - **ThreadPool:** 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。\n\n\nHandlerThread在之前的一篇文章里已经讲过了，ThreadPoolExecutor是Java中处理多线程的方法，下面从源码角度分析AsyncTask和IntentService的原理\n\n# AsyncTask\n\n## 基本用法\n\n```java\n\t//继承抽象类 实现抽象方法doInBackground \n    class MyAsyncTask extends AsyncTask<Void, Integer, String> {\n\n        @Override\n        protected String doInBackground(Void... voids) {\n            publishProgress(10);\n          \t//do some work\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(Integer... values) {\n            super.onProgressUpdate(values);\n        }\n\n        @Override\n        protected void onPostExecute(String s) {\n            super.onPostExecute(s);\n        }\n\n    }\n\n\t//在UI线程中创建实例 执行\n\tMyAsyncTask asyncTask = new MyAsyncTask();\n    asyncTask.execute();\n```\n\nAsyncTask是个抽象类，我们需要实现`doInBackground`，通常我们还会实现`onProgressUpdate`来做一个进度的回调与`onPostExecute`实现结果的回调。在`doInBackground`内部通过`publishProgress`来通知`onProgressUpdate`，怎么通知会放到下面doInBackground的分析中讲解。\n\n```java\npublic abstract class AsyncTask<Params, Progress, Result> {...}\n```\n\n还需要传入三个泛型来分别表示执行参数Params，进度参数Progress，结果参数Result。\n\nParams对应着`execute`和`doInBackground`的参数类型\n\n```java\n public final AsyncTask<Params, Progress, Result> execute(Params... params){...}\n protected abstract Result doInBackground(Params... params);\n```\n\nProgress对应着`onProgressUpdate`和`publishProgress`的参数类型\n\n```java\nprotected void onProgressUpdate(Progress... values) {...}\nprotected final void publishProgress(Progress... values) {...}\n```\n\nResult对应着`onPostExecute`的参数类型\n\n```java\nprotected void onPostExecute(Result result) {...}\n```\n\n\n\n知道了每个方法对应着什么样的作用，用起来就很简单了。\n\n\n\n## 源码分析\n\n### 构造函数\n\n不管怎么调，最后都是来到这个方法\n\n```java\npublic AsyncTask(@Nullable Looper callbackLooper) {\n        mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()\n            ? getMainHandler()\n            : new Handler(callbackLooper);\n\n        mWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n\t\t\t\t...\n            }\n        };\n\n        mFuture = new FutureTask<Result>(mWorker) {\n            @Override\n            protected void done() {\n                ...\n            }\n        };\n    }\n\n    private static Handler getMainHandler() {\n        synchronized (AsyncTask.class) {\n            if (sHandler == null) {\n                sHandler = new InternalHandler(Looper.getMainLooper());\n            }\n            return sHandler;\n        }\n    }\n\n```\n\n当我们调用的是无参的构造函数时，mHandler就是InternalHandler的实例，下面在doInBackground中会详细说明。\n\nmWorker是一个基于Callable接口封装的WorkerRunnable的实例，也就多了个储存执行参数的数组而已\n\n```java\nprivate final WorkerRunnable<Params, Result> mWorker;\nprivate static abstract class WorkerRunnable<Params, Result> implements Callable<Result> {\n        Params[] mParams;\n    }\n```\n\nmFuture就是`FutureTask<Result>`的实例\n\n### execute\n\n```java\n    @MainThread\n\tpublic final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }\n\n    @MainThread\n    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,\n            Params... params) {\n        if (mStatus != Status.PENDING) {\n            switch (mStatus) {\n                case RUNNING:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task is already running.\");\n                case FINISHED:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task has already been executed \"\n                            + \"(a task can be executed only once)\");\n            }\n        }\n\n        mStatus = Status.RUNNING;\n\n        onPreExecute();\n\n        mWorker.mParams = params;\n        exec.execute(mFuture);\n\n        return this;\n    }\n```\n\n有2个值得注意的点：\n\n- @MainThread 意味着excute需要在主线程执行\n- 检测mStatus来抛出异常，说明一个AsyncTask**对象**只能执行一次\n\n检查和赋值完状态，调用了`onPreExecute`，用户可以重写这个方法来做一些预处理。\n\n然后把执行的参数赋值给mWorker，然后调用`exec.execute(mFuture);`，结合调用关系，知道exec就是sDefaultExecutor\n\n### Executor\n\nsDefaultExecutor是SerialExecutor的实例，SerialExecutor实现了Executor，内部维护一个双端队列mTasks与一个代表当前任务的mActive。\n\n```java\npublic static final Executor SERIAL_EXECUTOR = new SerialExecutor();\nprivate static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;\n\nprivate static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n\n    public static final Executor THREAD_POOL_EXECUTOR;\n\n    static {\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,\n                sPoolWorkQueue, sThreadFactory);\n        threadPoolExecutor.allowCoreThreadTimeOut(true);\n        THREAD_POOL_EXECUTOR = threadPoolExecutor;\n    }\n```\n\n代码很简单，执行上述的`exec.execute(mFuture);`实际上就是把mFuture经过一个匿名的Runnable包装后添加到sDefaultExecutor的mTasks中，然后从mTasks中取出队列头的Runnable任务并通过线程池THREAD_POOL_EXECUTOR来执行。\n\n由此可以知道AsyncTask是串行执行任务的。执行的任务是被包装后的mFuture，实际上就是mFuture的callable变量，即mWork。\n\n如果你不想串行执行任务，直接使用内部的线程池THREAD_POOL_EXECUTOR来执行，那么可以直接调用`executeOnExecutor`方法，指定Executor来执行任务\n\n```java\nasyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);\n```\n\n\n\n### doInBackground\n\n在回到构造函数中看看mHandler和mWork的创建过程。\n\n```java\n    private static class InternalHandler extends Handler {\n        public InternalHandler(Looper looper) {\n            super(looper);\n        }\n\n        @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"})\n        @Override\n        public void handleMessage(Message msg) {\n            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;\n            switch (msg.what) {\n                case MESSAGE_POST_RESULT:\n                    // There is only one result\n                    result.mTask.finish(result.mData[0]);\n                    break;\n                case MESSAGE_POST_PROGRESS:\n                    result.mTask.onProgressUpdate(result.mData);\n                    break;\n            }\n        }\n    }\n```\n\nmHandler是InternalHandler的实例，针对`MESSAGE_POST_RESULT`和`MESSAGE_POST_PROGRESS`做了处理，分别对应这**结果**的通知和**进度**的通知。\n\n再来看看mWork。\n\n```java\n        mWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n                mTaskInvoked.set(true);\n                Result result = null;\n                try {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                    //noinspection unchecked\n                    result = doInBackground(mParams);\n                    Binder.flushPendingCommands();\n                } catch (Throwable tr) {\n                    mCancelled.set(true);\n                    throw tr;\n                } finally {\n                    postResult(result);\n                }\n                return result;\n            }\n        };\n```\n\nmWorker最后会被Executor调用，call方法中调用了由用户重写的doInBackground，执行具体的工作任务。\n\n那么为什么在doInBackground中执行`publishProgeress`就可以回调通知到`onProgressUpdate`呢，看了上面InternalHandler的封装心里基本也有点数了\n\n```java\n    @WorkerThread\n    protected final void publishProgress(Progress... values) {\n        if (!isCancelled()) {\n            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,\n                    new AsyncTaskResult<Progress>(this, values)).sendToTarget();\n        }\n    }\n\n  private Result postResult(Result result) {\n        @SuppressWarnings(\"unchecked\")\n        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,\n                new AsyncTaskResult<Result>(this, result));\n        message.sendToTarget();\n        return result;\n    }\n```\n\n`publishProgress`发送了`MESSAGE_POST_PROGRESS`\n\n同样的在mWorker的call方法中finally块执行了`postResult`，发送了`MESSAGE_POST_RESULT`\n\n## 内存泄漏\n\n与Handler一样，如果作为内部类，AsyncTask也是持有外部Activity的引用的，当两者生命周期不同步的时候，容易造成内存泄露。务必在Activity的onDestroy中调用`onCancelled`方法，在`onCancelled`中关闭网络连接与资源请求等。\n\n\n\n# IntentService\n\n## HandlerThread \n\n还是再讲讲HandlerThread吧，发现又有点忘了。\n\n```java\npublic class HandlerThread extends Thread {\n        @Override\n    public void run() {\n        mTid = Process.myTid();\n        Looper.prepare();\n        synchronized (this) {\n            mLooper = Looper.myLooper();\n            notifyAll();\n        }\n        Process.setThreadPriority(mPriority);\n        onLooperPrepared();\n        Looper.loop();\n        mTid = -1;\n    }\n  \n      public Looper getLooper() {\n        if (!isAlive()) {\n            return null;\n        }\n        // If the thread has been started, wait until the looper has been created.\n        synchronized (this) {\n            while (isAlive() && mLooper == null) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return mLooper;\n    }\n}\n\n```\n\n源码没什么好分析的，一个线程，封装好Looper，就一直loop循环等待消息到来直到quit。\n\n跟一般的线程比起来就是提高了与主线程的交互能力，主线程可以在HandlerThread启动之后，通过`getLooper`新建一个Handler来与HandlerThread建立起连接，通过`sendMessage`来通知HandlerThread线程，并重写这个Handler的`handleMessage`来做对应的处理。\n\n实例：\n\n```java\n    Handler mUIHandler = new Handler();\n    Handler mBackHandler;\n    HandlerThread mBachHandlerThread;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        mBachHandlerThread = new HandlerThread(\"test\");\n        mBachHandlerThread.start();\n        mBackHandler = new Handler(mBachHandlerThread.getLooper()){\n            @Override\n            public void handleMessage(Message msg)  {\n                Thread.sleep(1000); //做一些耗时操作\n              \n                mUIHandler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        //更新ui\n                    }\n                });\n            }\n        };\n        //通知mBachHandlerThread\n        mBackHandler.sendEmptyMessage(1);\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n        mBackHandler.removeCallbacksAndMessages(null);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        mBachHandlerThread.quit();\n    }\n```\n\n\n\n## 基本用法\n\n```java\npublic class MyIntentService extends IntentService {\n    public MyIntentService(String name) {\n        super(name);\n    }\n\n    @Override\n    protected void onHandleIntent(Intent intent) {\n        try {\n            int progeress = 0;\n            while (progeress < 100) {\n                progeress++;\n\n                Thread.sleep(500);\n                sendBroadcast(progeress);//通过LocalBroadcastManager发送广播给UI线程来更新UI\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendBroadcast(int progeress) { ... }\n}\n\n```\n\n继承IntentService，实现构造方法和`onHandleIntent`即可，剩下的按照普通Service处理（清单注册，intent启动）即可。\n\n下面来分析一下内部实现。\n\n## onCreate\n\n```java\n    @Override\n    public void onCreate() {\n \n        super.onCreate();\n        HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\");\n        thread.start();\n\n        mServiceLooper = thread.getLooper();\n        mServiceHandler = new ServiceHandler(mServiceLooper);\n    }\n```\n\n跟上述我们使用HandlerThread一样的用法，让mServiceHandler与HandlerThread建立起关联。\n\n## onStart\n\n```java\n    @Override\n    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {\n        onStart(intent, startId);\n        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;\n    }\n    @Override\n    public void onStart(@Nullable Intent intent, int startId) {\n        Message msg = mServiceHandler.obtainMessage();\n        msg.arg1 = startId;\n        msg.obj = intent;\n        mServiceHandler.sendMessage(msg);\n    }\n```\n\n一启动就使用mServiceHandler发了个消息\n\n```java\n    private final class ServiceHandler extends Handler {\n        public ServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            onHandleIntent((Intent)msg.obj);\n            stopSelf(msg.arg1);\n        }\n    }\n```\n\n回调了`onHandleIntent`，该方法由用户实现，并且调用了`stopSelf`，体现IntentService用完就走的设计思路。\n\n# ThreadPoolExecutor\n\n再补充一下线程池中相关。ThreadPoolExecutor提供了4个构造方法，最后都会调用到下面这个。通过构造方法的一系列参数，来构成不同配置的线程池。\n\n```java\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n挑几个比较重要的拿出来讲一下。\n\nBlockingQueue<Runnable> workQueue，维护着等待执行的Runnable对象\n\n- SynchronousQueue 直接将Runnable交给核心线程处理，如果核心线程都在工作则新建工作线程来执行（一般来说maximumPoolSize为Integer.MAX_VALUE）。\n- LinkedBlockingDeque 当前线程数小于核心线程数，新建核心线程处理任务。如果当前线程数等于核心线程数，则进入队列等待。\n- ArrayBlockingQueue 创建时可以指定capacity，能新建核心线程就新建，不能就入队等待，等待数如果超过capacity，则新建工作线程执行任务，如果总线程数超过了maximumPoolSize则报错。\n\nThreadFactory threadFactory，提供对线程一些属性定制的操作\n\n## 执行\n\n```java\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        /*\n         * Proceed in 3 steps:\n         *\n         * 1. If fewer than corePoolSize threads are running, try to\n         * start a new thread with the given command as its first\n         * task.  The call to addWorker atomically checks runState and\n         * workerCount, and so prevents false alarms that would add\n         * threads when it shouldn't, by returning false.\n         * \n         1. 检查能不能添加\n         \n         * 2. If a task can be successfully queued, then we still need\n         * to double-check whether we should have added a thread\n         * (because existing ones died since last checking) or that\n         * the pool shut down since entry into this method. So we\n         * recheck state and if necessary roll back the enqueuing if\n         * stopped, or start a new thread if there are none.\n         2.添加后的二次检查\n         \n         * 3. If we cannot queue task, then we try to add a new\n         * thread.  If it fails, we know we are shut down or saturated\n         * and so reject the task.\n         3.不能添加就reject\n         */\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n\n### ctl变量\n\n原子级操作的整数，前3位表示运行状态，后29位表示运行的线程数。\n\n```java\n    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING    = -1 << COUNT_BITS;\n    private static final int SHUTDOWN   =  0 << COUNT_BITS;\n    private static final int STOP       =  1 << COUNT_BITS;\n    private static final int TIDYING    =  2 << COUNT_BITS;\n    private static final int TERMINATED =  3 << COUNT_BITS;\n\n    // Packing and unpacking ctl\n    private static int runStateOf(int c)     { return c & ~CAPACITY; }\n    private static int workerCountOf(int c)  { return c & CAPACITY; }\n    private static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n### addWorker\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n\n\t\t\t//省略了一些状态检查代码\n\n        }\n\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            w = new Worker(firstTask);//实现Runnable接口的类 对firstTask封装\n            final Thread t = w.thread;\n            if (t != null) {\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();\n                try {\n                    int rs = runStateOf(ctl.get());\n\t\t\t\t\t//再对状态进行一次检查\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n                      //没问题就把上面new的worker添加到workers\n                        workers.add(w);\n                        int s = workers.size();\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = true;\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    t.start();\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n    }\n```\n\n```java\n    private final class Worker extends AbstractQueuedSynchronizer implements Runnable\n    {\n        Worker(Runnable firstTask) {\n            setState(-1); // inhibit interrupts until runWorker\n            this.firstTask = firstTask;\n            this.thread = getThreadFactory().newThread(this);\n        }\n\t}\n```\n\n去掉了一些对状态检测的代码，检测没问题就会实例化一个Worker的实例，然后对状态再进行一次check，没问题就调用`t = w.thread,t.start()`。根据Worker的封装 这个t在实例的时候传入的Runnable参数就是worker本身，所以这个t.start调用的就是w的run方法\n\n```java\n        public void run() {\n            runWorker(this);\n        }\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n```\n\n在runWorker中取出firstTask，并调用其run方法来执行任务。\n\n## 常见的4个线程池\n\n### **newCachedThreadPool**\n\n```java\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n\n核心线程数0，最大工作线程数为Integer.MAX_VALUE，可灵活回收空闲线程，若无可回收，则新建线程。\n\n### **newFixedThreadPool**\n\n```java\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\n核心线程数即最大工作线程数，由用户控制，可控制线程最大并发数，超出的线程会在队列中等待。\n\n### **newScheduledThreadPool**\n\n```java\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPoolExecutor(corePoolSize);\n}\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE,\n              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,\n              new DelayedWorkQueue());\n    }\n```\n\n核心线程数由用户控制，最大工作线程数为Integer.MAX_VALUE，可创建支持定时及周期性任务执行的线程。比起Timer来应该优先使用这个。\n\n### **newSingleThreadExecutor**\n\n```java\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n\n核心线程=最大工作线程=1。创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。\n\n# ExecutorCompletionService\n\n## Callable、Future和FutureTask\n\n通常做网络请求的时候，在Runnable中回调response来起到获取请求结果的效果。Callable就避免了这种尴尬的做法，因为他有返回值。\n\n通常与线程池一起使用，通过线程池的submit方法返回一个Future对象。\n\n```java\n<T> Future<T> submit(Callable<T> task);\n```\n\n正常的使用如下：\n\n```java\n\t\t// 队列\n        BlockingQueue<Future<String>> futures = new LinkedBlockingQueue<>();\n        ExecutorService pool = Executors.newCachedThreadPool();\n\n        // 生产者\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                int index = i;\n                Future<String> submit = pool.submit(() -> \"task:\" + index + \" done\");\n                try {\n                    futures.put(submit);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n\n        // 消费者\n        new Thread(() -> {\n            try {\n                Thread.sleep(3 * 1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            for (Future<String> future : futures) {\n                try {\n                    System.out.println(future.get());\n\n                } catch (Exception e) {\n                    e.printStackTrace();\n\n                }\n            }\n            pool.shutdown();\n        }).start();\n```\n\n获取结果可以直接使用Future的get方法，来阻塞获取也可以循环判断`future.isDone()`来获取。\n\n再来看一下FutureTask这个类：\n\n```java\npublic class FutureTask<V> implements RunnableFuture<V> { ... }\n\npublic interface RunnableFuture<V> extends Runnable, Future<V> {\n    void run();\n}\n```\n\n通过接口的多继承性来同时具备了Runnable和Future的特性。\n\n使用如下，与Future区别的具体使用场景还没搞懂。。\n\n```java\n \t\tfinal FutureTask<String> futureTask = new FutureTask<>(() -> \"task done\");\n        final ExecutorService pool = Executors.newCachedThreadPool();\n\n        // 生产者\n        new Thread(() -> {\n            try {\n                Thread.sleep(3 * 1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            pool.submit(futureTask);\n        }).start();\n\n\n        // 消费者\n        new Thread(() -> {\n            while (true) {\n                try {\n                    System.out.println(futureTask.get());\n                    pool.shutdown();\n                    break;\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (ExecutionException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        }).start();\n```\n\n## ExecutorCompletionService\n\ntodo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 参考\n\n[JAVA线程池的使用](https://www.jianshu.com/p/ae67972d1156)\n\n[Callable、Future和FutureTask](http://www.cnblogs.com/dolphin0520/p/3949310.html)","tags":["多线程"],"categories":["Android"]},{"title":"常见数据结构分析","url":"/2018/04/10/常见数据结构/","content":"ArrayList、LinkedList、HashMap、LinkedHashMap实现\n<!-- more -->  \n\n# HashMap\n\n数组+链表实现\n\n![](https://upload-images.jianshu.io/upload_images/1956855-e0aa3ef55cd31303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n```java\n    transient Node<K,V>[] table;\n\n    /**\n     * Holds cached entrySet(). Note that AbstractMap fields are used\n     * for keySet() and values().\n     */\n    transient Set<Map.Entry<K,V>> entrySet;\n```\n\n\n\n每个Entry为Node实例\n\n```java\n    static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n    }\n```\n\n***\n\n根据key的hash值找到数组的位置i\n\n```java\n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\t\t\n\n\t/**\n     * Returns index for hash code h.\n     */\n    static int indexFor(int h, int length) {\n        return h & (length-1);\n    }\n```\n\n然后遍历以数组[i]为头节点的链表，如果发现有节点的hash，key都相同的节点时，就替换为新的value，然后返回旧的value，没有就加到尾巴去\n\n```java\n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n```\n\n## JDK8中的resize方法分析\n\n只关注链表时的resize\n\n```java\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n\t\t//省略计算扩容大小的代码\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;//遍历循环数组 e为当前节点\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null){\n                        newTab[e.hash & (newCap - 1)] = e;\n                    }//省略红黑树resize代码\n                    else { \n                      \t//下面会单独贴出来\n                        //①计算节点e在新数组中的位置 \n                        //②遍历e所在链表，放到新数组中\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n一个for循环管遍历数组，在for循环里再针对每个Node遍历所在链表，主要是关于位置计算的代码需要深入了解一下。\n\n在贴源码之前，回顾一下HashMap是怎么确定每个V在数组中的index的？\n\n如果数组的大小为len的话，那就是\n\n```java\nindex = hash & (len-1)\n```\n\n所以index只跟要put的V的hashcode的低(len-1)位有关系。而在jdk8中，HashMap保证数组的大小len一定为2的n次幂（二进制形如100,1000,10000）。ok，有了这些基本知识就可以继续跟进resize的源码了。上面省略的代码如下：\n\n```java\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n```\n\n通过`if ((e.hash & oldCap) == 0)`来判断当前节点 e的hash值，如果==0，则说明e.hash的值在oldCap为1的那一位，为0。\n\n```java\ne.hash       xxxxxxxxYxx  (Y=0)\noldCap               100  (2的n次幂)\noldCap-1\t  \t     011\t\t\t   \n__________________________________\ne.hash & oldCap        0\ne.hash & (oldCap-1)   xx \ne.hash & oldCap 为0 说明 Y为0\n```\n\n但是这个Y为0能干嘛呢，Y为0说明了当前的节点e在新的数组中，位置是保持不变的！因为扩容后，能够影响位置的只有Y位。\n\n```java\ne.hash       xxxxxxxxxYxx  (Y=0)\nnewCap               1000  (2的n次幂)\nnewCap-1             0111 \n__________________________________\ne.hash & (newCap-1)   0xx \n```\n\n看到没，如果Y为0的话，扩容后，e在数组中的index根本不会收到扩容后的数组长度影响。\n\n再回到上面的代码\n\n```java\nNode<K,V> loHead = null, loTail = null;\nNode<K,V> hiHead = null, hiTail = null;\n```\n\nloHead和loTail就是 位置不变的节点e所在的链表的头尾\n\nhiHead和hiTail就是 位置改变的节点e所在的链表的头尾\n\n那么问题又来了，对于改变位置的节点e来说，他是多了多少?\n\n```java\ne.hash       xxxxxxxxxYxx  (Y=1)\nnewCap               1000  (2的n次幂)\nnewCap-1             0111 \n__________________________________\ne.hash & (newCap-1)   Yxx  (Y=1)\n```\n\nY=1的时候，索引位置从 0xx变成1xx，那么就是多了100，就是多了一个oldCap的len长度嘛。分析完毕。\n\n\n\n\n\n\n\n\n\n\n\n# LinkedHashMap\n\nhttps://www.jianshu.com/p/83648fa22c4c\n\nentrySet的改变：\n\n```java\n    static class LinkedHashMapEntry<K,V> extends HashMap.Node<K,V> {\n        LinkedHashMapEntry<K,V> before, after;\n        LinkedHashMapEntry(int hash, K key, V value, Node<K,V> next) {\n            super(hash, key, value, next);\n        }\n    }\n```\n\n```java\n    /**\n     * The head (eldest) of the doubly linked list.\n     */\n    transient LinkedHashMapEntry<K,V> head;\n\n    /**\n     * The tail (youngest) of the doubly linked list.\n     */\n    transient LinkedHashMapEntry<K,V> tail;\n```\n\n在Hashmap中有在put方法中预留给LinkedHashmap操作的方法\n\n```java\n    // Callbacks to allow LinkedHashMap post-actions\n    void afterNodeAccess(Node<K,V> p) { }\n    void afterNodeInsertion(boolean evict) { }\n    void afterNodeRemoval(Node<K,V> p) { }\n\n```\n\n增加大量规则来维护head tail双向链表\n","tags":["数据结构"],"categories":["Android"]},{"title":"Dalvik加载dex文件分析","url":"/2018/04/02/dalvik加载class分析/","content":"分析Dalvik加载dex文件流程\n<!-- more -->  \n\n# .dex文件格式\n\n文件格式这个我觉得很死啊，就跟之前[分析ELF文件格式](https://melonwxd.github.io/2017/11/19/inject-1-elf/)一样，按照每个结构体对应的值来找，很无脑但是也很容易出错，我先贴个非虫的图吧，后续有机会再补充。\n\n非虫大佬的神图:\n\n![](http://img.blog.csdn.net/20160215152236880?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n\n# 从app_process到AndroidRuntime\n\n一切又要从zygote进程启动开始说起，结合之前的[分析](https://melonwxd.github.io/2017/12/08/Android启动流程/ )，在init.rc中解析zygote的时候，zygote64.rc的内容如下：\n\n```cpp\n1 service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n2    class main    //声明service所属class的名字\n3    socket zygote stream 660 root system\n4    onrestart write /sys/android_power/request_state wake\n5    onrestart write /sys/power/state on\n6    onrestart restart media\n7    onrestart restart netd\n8    writepid /dev/cpuset/foreground/tasks\n```\n\n\n\n可以知道zygote要执行的程序是`system/bin/app_process64`，他的源码位置在[app_main.cpp](http://androidxref.com/4.4.4_r1/xref/frameworks/base/cmds/app_process/app_main.cpp)，截取部分跟dvm相关的代码：\n\n```cpp\n138int main(int argc, char* const argv[])\n139{\n  \n177    AppRuntime runtime;\n\n187    int i = runtime.addVmArguments(argc, argv);\n\n222    if (zygote) {\n223        runtime.start(\"com.android.internal.os.ZygoteInit\",\n224                startSystemServer ? \"start-system-server\" : \"\");\n238 }\n```\n\n当执行app_main.cpp的`main`函数为zygote进程的时候就会调用AppRuntime的start方法。\n\nAppRuntime这个类如下：\n\n```cpp\n32class AppRuntime : public AndroidRuntime\n33{\n\n56\n57    virtual void onVmCreated(JNIEnv* env)\n58    {\n\n84    }\n85\n86    virtual void onStarted()\n87    {\n\n96    }\n97\n98    virtual void onZygoteInit()\n99    {\n\n106    }\n107\n108    virtual void onExit(int code)\n109    {\n\n116    }\n\n124};\n```\n\n继承自[AndroidRuntime](http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/jni/AndroidRuntime.cpp)，跟进父类的start方法瞅瞅\n\n```cpp\n797/*\n798 * Start the Android runtime.  This involves starting the virtual machine\n799 * and calling the \"static void main(String[] args)\" method in the class\n800 * named by \"className\".\n      ↑↑↑↑↑注释自己看 说的很简洁↑↑↑↑↑\n804 */\n805void AndroidRuntime::start(const char* className, const char* options)\n806{\n\n834    /* start the virtual machine */\n835    JniInvocation jni_invocation;\n836    jni_invocation.Init(NULL);\n  \n837    JNIEnv* env;\n838    if (startVm(&mJavaVM, &env) != 0) {\n839        return;\n840    }\n841    onVmCreated(env);\n842\n875    char* slashClassName = toSlashClassName(className);\n876    jclass startClass = env->FindClass(slashClassName);\n877    if (startClass == NULL) {\n878        ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName);\n879        /* keep going */\n880    } else {\n881        jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\",\n882            \"([Ljava/lang/String;)V\");\n\t\t\t...\n\t   }\n902}\n```\n\n## JniInvocation:加载libdvm.so\n\n[JniInvocation.cpp](http://androidxref.com/4.4.4_r1/xref/libnativehelper/JniInvocation.cpp)中的Init方法\n\n```cpp\n4 static const char* kLibraryFallback = \"libdvm.so\";\n\n56 bool JniInvocation::Init(const char* library) {\n57 #ifdef HAVE_ANDROID_OS\n58  char default_library[PROPERTY_VALUE_MAX];\n59  property_get(kLibrarySystemProperty, default_library, kLibraryFallback);\n60 #else\n61  const char* default_library = kLibraryFallback;\n62 #endif\n63  if (library == NULL) {\n64    library = default_library;\n65  }\n  \n67  handle_ = dlopen(library, RTLD_NOW);\n  \n88  if (!FindSymbol(reinterpret_cast<void**>(&JNI_GetDefaultJavaVMInitArgs_),\n89                  \"JNI_GetDefaultJavaVMInitArgs\")) {\n90    return false;\n91  }\n92  if (!FindSymbol(reinterpret_cast<void**>(&JNI_CreateJavaVM_),\n93                  \"JNI_CreateJavaVM\")) {\n94    return false;\n95  }\n96  if (!FindSymbol(reinterpret_cast<void**>(&JNI_GetCreatedJavaVMs_),\n97                  \"JNI_GetCreatedJavaVMs\")) {\n98    return false;\n99  }\n100  return true;\n101}\n```\n\n粗略看下即可，针对5.0之前的系统，通过line67的`dlopen`来加载`\"libdvm.so\"`，同时还查找了三个函数，记着阿，下面要用。\n\n##startVm:启动虚拟机\n\n```cpp\n435int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv)\n436{\n437    int result = -1;\n438    JavaVMInitArgs initArgs;\n439    JavaVMOption opt;\n      //属性定义与配置一大堆\n\n767    /*\n768     * Initialize the VM.\n769     *\n770     * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread.\n771     * If this call succeeds, the VM is ready, and we can start issuing\n772     * JNI calls.\n773     */\n774    if (JNI_CreateJavaVM(pJavaVM, pEnv, &initArgs) < 0) {\n775        ALOGE(\"JNI_CreateJavaVM failed\\n\");\n776        goto bail;\n777    }\n778\n779    result = 0;\n780\n781 bail:\n782    free(stackTraceFile);\n783    return result;\n784 }\n\n```\n\n最核心的方法：[JNI_CreateJavaVM](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/Jni.cpp)，肯定是要略过不讲的，等以后另开一篇，反正这里虚拟机就启动了。\n\n## JniEnv加载\n\n在`startVm`方法返回之后，就拿到了虚拟机的JNI接口`JNIEnv* env;`，就可以通过下面的FindClass和GetStaticMethodID来加载参数classname 值为`com.android.internal.os.ZygoteInit`以及其main函数。\n\n```java\n876    jclass startClass = env->FindClass(slashClassName);\n  \n881        jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\",\n882            \"([Ljava/lang/String;)V\");\n```\n\n \n\n# 类的加载\n\n**todo: 上面的Jni调用到类的加载，这个过程我暂时还没梳理清楚**\n\n但这并不妨碍我分析下面2个函数 -m-\n\nJvm对new操作符对应的OP_NEW_INSTANCE处理如下，地址在[/dalvik/vm/mterp/out/InterpC-portable.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/mterp/out/InterpC-portable.cpp)\n\n```cpp\n1649/* File: c/OP_NEW_INSTANCE.cpp */\n1650HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)\n1651    {\n1652        ClassObject* clazz;\n1653        Object* newObj;\n1654\n1655        EXPORT_PC();\n1656\n1657        vdst = INST_AA(inst);\n1658        ref = FETCH(1);\n1659        ILOGV(\"|new-instance v%d,class@0x%04x\", vdst, ref);\n1660        clazz = dvmDexGetResolvedClass(methodClassDex, ref);\n1661        if (clazz == NULL) {\n1662            clazz = dvmResolveClass(curMethod->clazz, ref, false);\n1665        }\n1667        if (!dvmIsClassInitialized(clazz) && !dvmInitClass(clazz))\n1668            GOTO_exceptionThrown();\n1691        newObj = dvmAllocObject(clazz, ALLOC_DONT_TRACK);\n\n1694        SET_REGISTER(vdst, (u4) newObj);\n1695    }\n1696    FINISH(2);\n1697OP_END\n```\n\n\n\n## dvmResolveClass\n\n定义在[/dalvik/vm/oo/Resolve.cpp](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Resolve.cpp#63)\n\n```cpp\n63ClassObject* dvmResolveClass(const ClassObject* referrer, u4 classIdx,\n64    bool fromUnverifiedConstant)\n65{\n66    DvmDex* pDvmDex = referrer->pDvmDex;\n67    ClassObject* resClass;\n68    const char* className;\n69\n// 先查看是否要加载的类已经被解析过了\n74    resClass = dvmDexGetResolvedClass(pDvmDex, classIdx);\n75    if (resClass != NULL)\n76        return resClass;\n//没有的话就 就解析dex文件 \n90    className = dexStringByTypeIdx(pDvmDex->pDexFile, classIdx);\n  //判断是不是原始类型  primitive type\n91    if (className[0] != '\\0' && className[1] == '\\0') {\n92        /* primitive type */   \n93        resClass = dvmFindPrimitiveClass(className[0]);\n94    } else {\n  // 不是原始类型就调用dvmFindClassNoInit\n95        resClass = dvmFindClassNoInit(className, referrer->classLoader);\n96    }\n97\n98    if (resClass != NULL) {\n  //这里就是我在热更新总结的文章里说道的，dvm的检查代码\n  //https://melonwxd.github.io/2018/03/16/%E7%83%AD%E6%9B%B4%E6%96%B0%E5%85%A8%E8%A7%A3/\n141        }\n\t\t//解析完该类  缓存起来 下次就直接通过line74的函数返回了\n154        dvmDexSetResolvedClass(pDvmDex, classIdx, resClass);\n155    } \n\n162    return resClass;\n163}\n```\n\n总体流程已经注释好了，主要跟进[dvmFindClassNoInit](http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp#1285)函数中进一步了解流程\n\n```cpp\n1285ClassObject* dvmFindClassNoInit(const char* descriptor,\n1286        Object* loader)\n1287{\n\n1293    if (*descriptor == '[') {\n1294        /*\n1295         * Array class.  Find in table, generate if not found.\n1296         */\n1297        return dvmFindArrayClass(descriptor, loader);\n1298    } else {\n1299        /*\n1300         * Regular class.  Find in table, load if not found.\n1301         */\n1302        if (loader != NULL) {\n  \t\t\t\t//通常的类都是走这个函数，应该都有classloader\n1303            return findClassFromLoaderNoInit(descriptor, loader);\n1304        } else {\n  \t\t\t\t//根据类名来看应该是系统类走这个方法 如 java.lang包下的？ 没有深究\n1305            return dvmFindSystemClassNoInit(descriptor);\n1306        }\n1307    }\n1308}\n```\n\n继续跟进函数 findClassFromLoaderNoInit\n\n```cpp\n1316 static ClassObject* findClassFromLoaderNoInit(const char* descriptor,\n1317    Object* loader)\n1318 {\n\n1322    Thread* self = dvmThreadSelf();\n1323\n\n1344    char* dotName = NULL;\n1345    StringObject* nameObj = NULL;\n1346\n1347    /* 转换符号 convert \"Landroid/debug/Stuff;\" to \"android.debug.Stuff\" */\n1348    dotName = dvmDescriptorToDot(descriptor);\n\n1353    nameObj = dvmCreateStringFromCstr(dotName);\n\n1359    dvmMethodTraceClassPrepBegin();\n1360\n1361    /*\n1362     * Invoke loadClass().  This will probably result in a couple of\n1363     * exceptions being thrown, because the ClassLoader.loadClass()\n1364     * implementation eventually calls VMClassLoader.loadClass to see if\n1365     * the bootstrap class loader can find it before doing its own load.\n1366     */\n\n1368    {\n1369        const Method* loadClass =\n1370            loader->clazz->vtable[gDvm.voffJavaLangClassLoader_loadClass];\n1371        JValue result;\n1372        dvmCallMethod(self, loadClass, loader, &result, nameObj);\n1373        clazz = (ClassObject*) result.l;\n1374\n1375        dvmMethodTraceClassPrepEnd();\n1376        Object* excep = dvmGetException(self);\n1377        if (excep != NULL) {\n1382            dvmAddTrackedAlloc(excep, self);\n1383            dvmClearException(self);\n1384            dvmThrowChainedNoClassDefFoundError(descriptor, excep);\n1385            dvmReleaseTrackedAlloc(excep, self);\n1386            clazz = NULL;\n1387            goto bail;\n1388        } else if (clazz == NULL) {\n1389            ALOGW(\"ClassLoader returned NULL w/o exception pending\");\n1390            dvmThrowNullPointerException(\"ClassLoader returned null\");\n1391            goto bail;\n1392        }\n1393    }\n1394\n1395    /* not adding clazz to tracked-alloc list, because it's a ClassObject */\n1396\n1397    dvmAddInitiatingLoader(clazz, loader);\n\n1402 bail:\n1403    dvmReleaseTrackedAlloc((Object*)nameObj, NULL);\n1404    free(dotName);\n1405    return clazz;\n1406 }\n1407\n```\n\n\n\n## dvmInitClass\n\n# 参考\n\n[深入理解Android（二）：Java虚拟机Dalvik](http://www.infoq.com/cn/articles/android-in-depth-dalvik)\n\n[老罗的分析](https://blog.csdn.net/luoshengyang/article/details/41688319)","tags":["Dalvik"],"categories":["虚拟机"]},{"title":"Glide源码学习","url":"/2018/03/28/Glide源码学习/","content":"\nGlide源码学习\n\n<!-- more -->  \n\n# 基本使用\n\n```java\n        Glide.with(this).load(\"https://www.baidu.com/123.jpg\").into(imageView);\n```\n\n## with\n\n```java\n    public static RequestManager with(Context context) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(context);\n    }\n    public static RequestManagerRetriever get() {\n        return INSTANCE;\n    }\n    private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();\n```\n\n```java\n    public RequestManager get(Context context) {\n        if (context == null) {\n            throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n        } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n            if (context instanceof FragmentActivity) {\n                return get((FragmentActivity) context);\n            } else if (context instanceof Activity) {\n                return get((Activity) context);\n            } else if (context instanceof ContextWrapper) {\n                return get(((ContextWrapper) context).getBaseContext());\n            }\n        }\n        return getApplicationManager(context);\n    }\n```\n\n根据传入的context不同而返回不同的RequestManager，看似重载了很多get方法，但是实际上只区分为applicationCtx和非applicationCtx(Fragment)。下面基于applicationCtx来跟进`getApplicationManager(context)`。\n\n```java\n    private RequestManager getApplicationManager(Context context) {\n  \t\tapplicationManager = new RequestManager(context.getApplicationContext(),\n                                          new ApplicationLifecycle(), \n                                          new EmptyRequestManagerTreeNode());\n        return applicationManager;\n    }\n```\n\n即with返回了一个RequestManager对象，RequestManager具体是干什么的后面再说。\n\n## load\n\n同样的load也有很多重载方法，我们以String为参数的方法来跟进，懂了一个，其他也一通百通，源码阅读过程切忌沉迷细节。\n\n```java\n    public DrawableTypeRequest<String> load(String string) {\n        return (DrawableTypeRequest<String>) fromString().load(string);\n    }\n    public DrawableTypeRequest<String> fromString() {\n        return loadGeneric(String.class);\n    }\n    private <T> DrawableTypeRequest<T> loadGeneric(Class<T> modelClass) {\n        ModelLoader<T, InputStream> streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);\n        ModelLoader<T, ParcelFileDescriptor> fileDescriptorModelLoader =\n                Glide.buildFileDescriptorModelLoader(modelClass, context);\n      \n        return optionsApplier.apply(\n                new DrawableTypeRequest<T>(modelClass, streamModelLoader, fileDescriptorModelLoader, context,\n                        glide, requestTracker, lifecycle, optionsApplier));\n    }\n    public <A, X extends GenericRequestBuilder<A, ?, ?, ?>> X apply(X builder) {\n            if (options != null) { //默认为null \n                options.apply(builder);\n            }\n            return builder;\n    }\n```\n\n`fromString()`返回了DrawableTypeRequest的实例，DrawableTypeRequest继承了DrawableRequestBuilder，load方法也没有重写，直接调用的DrawableRequestBuilder的，而DrawableRequestBuilder又继承了GenericRequestBuilder。\n\n```java\n    @Override\n    public DrawableRequestBuilder<ModelType> load(ModelType model) {\n        super.load(model);\n        return this;\n    }\n//GenericRequestBuilder.java\n    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {\n        this.model = model;\n        isModelSet = true;\n        return this;\n    }\n```\n\n最后将返回值向下转型为子类 DrawableTypeRequest<String>。说白了这整个load流程就是根据传入参数的类型来设置加载数据的模式。\n\n## into\n\n还是走的父类方法\n\n```java\n//DrawableRequestBuilder.java    \n\t@Override\n    public Target<GlideDrawable> into(ImageView view) {\n        return super.into(view);\n    }\n\n//GenericRequestBuilder.java\n    public Target<TranscodeType> into(ImageView view) {\n        Util.assertMainThread();\n      \n        //略掉一些对imageView的ScaleType的处理\n      \n\t\t//transcodeClass查看构造函数可以知道是 GlideDrawable.class\n        return into(glide.buildImageViewTarget(view, transcodeClass));\n    }\n```\n### GlideDrawableImageViewTarget\n\n跟进看看这个buildImageViewTarget返回什么\n\n```java\n\n    <R> Target<R> buildImageViewTarget(ImageView imageView, Class<R> transcodedClass) {\n        return imageViewTargetFactory.buildTarget(imageView, transcodedClass);\n    }\n\n    public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {\n        if (GlideDrawable.class.isAssignableFrom(clazz)) {\n            return (Target<Z>) new GlideDrawableImageViewTarget(view);\n        } \n    \t...  \t\n    }\n    public GlideDrawableImageViewTarget(ImageView view) {\n        this(view, GlideDrawable.LOOP_FOREVER);\n    }\n    public GlideDrawableImageViewTarget(ImageView view, int maxLoopCount) {\n        super(view);\n        this.maxLoopCount = maxLoopCount;\n    }\n```\n\n返回的是GlideDrawableImageViewTarget实例，再回到上面的into方法中跟进\n\n```java\n    public <Y extends Target<TranscodeType>> Y into(Y target) {\n        Util.assertMainThread();\n\n        Request previous = target.getRequest();\n\n        if (previous != null) {\n            previous.clear();\n            requestTracker.removeRequest(previous);\n            previous.recycle();\n        }\n\n        Request request = buildRequest(target);\n        target.setRequest(request);\n        lifecycle.addListener(target);\n        requestTracker.runRequest(request);\n\n        return target;\n    }\n```\n\ngetRequest在父类ViewTarget中实现\n\n```java\n    @Override\n    public Request getRequest() {\n        Object tag = getTag();\n        Request request = null;\n        if (tag != null) {\n            if (tag instanceof Request) {\n                request = (Request) tag;\n            } else {\n                throw new IllegalArgumentException(\"You must not call setTag() on a view Glide is targeting\");\n            }\n        }\n        return request;\n    }\n```\n\n这里会对view的Tag做一个检查，如果不是由glide来setTag的话会抛出异常，这也是为什么有Glide时，处理recyclerView的错位问题，我们不能通过直接对ImageView来setTag判断是否错位。\n\n回归正题，首次使用的时候返回的request应该是null，所以就走的下面这一部分核心代码\n\n```java\n        Request request = buildRequest(target);\n        target.setRequest(request);\n        lifecycle.addListener(target);\n        requestTracker.runRequest(request);\n```\n\n### buildRequest\n\n```java\nprivate Request buildRequest(Target<TranscodeType> target) {\n        if (priority == null) {\n            priority = Priority.NORMAL;\n        }\n        return buildRequestRecursive(target, null);\n    }\n\n    private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {\n        if (thumbnailRequestBuilder != null) {\n            // Recursive case: contains a potentially recursive thumbnail request builder.\n          \t...\n            return coordinator;\n        } else if (thumbSizeMultiplier != null) {\n            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.\n            ...\n            return coordinator;\n        } else {\n            // Base case: no thumbnail.\n            return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);\n        }\n    }\n```\n\n就看最基本情况，没有缩略图，返回一个`obtainRequest(target, sizeMultiplier, priority, parentCoordinator);`\n\n```java\nprivate Request obtainRequest(Target<TranscodeType> target, float sizeMultiplier, Priority priority,\n            RequestCoordinator requestCoordinator) {\n        return GenericRequest.obtain(\n                loadProvider,\n                model,\n                signature,\n                context,\n                priority,\n                target,\n                sizeMultiplier,\n                placeholderDrawable,\n                placeholderId,\n                errorPlaceholder,\n                errorId,\n                fallbackDrawable,\n                fallbackResource,\n                requestListener,\n                requestCoordinator,\n                glide.getEngine(),\n                transformation,\n                transcodeClass,\n                isCacheable,\n                animationFactory,\n                overrideWidth,\n                overrideHeight,\n                diskCacheStrategy);\n    }\n\nprivate static final Queue<GenericRequest<?, ?, ?, ?>> REQUEST_POOL = Util.createQueue(0);\npublic static <A, T, Z, R> GenericRequest<A, T, Z, R> obtain(/*省略参数*/) {\n\n        GenericRequest<A, T, Z, R> request = (GenericRequest<A, T, Z, R>) REQUEST_POOL.poll();\n        if (request == null) {\n            request = new GenericRequest<A, T, Z, R>();\n        }\n        request.init(/*省略参数*/);\n        return request;\n    }\n```\n\n在这根据一些传入的参数和默认参数构建一个GenericRequest实例。\n\n后面setRequest就略过不提了，然后是`lifecycle.addListener(target);`，这个lifecycle结合代码是with中创建RequestManager的时候传入的`new ApplicationLifecycle()`，而target是GlideDrawableImageViewTarget\n\n```java\npublic interface Target<R> extends LifecycleListener{\n  ...\n}\n\nclass ApplicationLifecycle implements Lifecycle {\n    @Override\n    public void addListener(LifecycleListener listener) {\n        listener.onStart();\n    }\n}\n//GlideDrawableImageViewTarget.java\n    @Override\n    public void onStart() {\n        if (resource != null) {\n            resource.start();\n        }\n    }\n```\n\nresource初始时为null 暂时略过\n\n### runRequest\n\n再来看看`requestTracker.runRequest(request);`\n\nrequestTrack也是构造RequestManager的时候传入一个`new RequestTracker();`\n\n```java\n    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());    \n\tpublic void runRequest(Request request) {\n        requests.add(request);\n        if (!isPaused) {\n            request.begin();\n        } else {\n            pendingRequests.add(request);\n        }\n    }\n```\n\n上面buildRequest返回的是GenericRequest的实例，跟进\n\n```java\n    @Override\n    public void begin() {\n      ...\n        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n            onSizeReady(overrideWidth, overrideHeight);\n        } else {\n            target.getSize(this);//后面也会调用到onSizeReady\n        }\n      \n        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {\n            target.onLoadStarted(getPlaceholderDrawable());\n        }\n      ...\n    }\n\n```\n\n跟进onSizeReady\n\n```java\n \t@Override\n    public void onSizeReady(int width, int height) {\n \t\t//修改状态\n        status = Status.RUNNING;\n\n        width = Math.round(sizeMultiplier * width);\n        height = Math.round(sizeMultiplier * height);\n\n        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();\n        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);\n      \n        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();\n\n        loadedFromMemoryCache = true;\n        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,priority, isMemoryCacheable, diskCacheStrategy, this);\n        loadedFromMemoryCache = resource != null;\n\n    }\n```\n\n#### loaderprovider\n\n其中的loadProvider来自上述load方法中的\n\n```java\n //requestManage.java\n\tprivate <T> DrawableTypeRequest<T> loadGeneric(Class<T> modelClass) {\n        ModelLoader<T, InputStream> streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);\n      ...\n\t\treturn optionsApplier.apply(\n                new DrawableTypeRequest<T>(modelClass, streamModelLoader, fileDescriptorModelLoader, context,\n                        glide, requestTracker, lifecycle, optionsApplier));\n    }\n //DrawableTypeRequest.java\n    DrawableTypeRequest(/*省略参数*/) {\n        super(context, modelClass,\n                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,\n                        GlideDrawable.class, null),//buildProvider参数就是创建loadProvider的方法\n                glide, requestTracker, lifecycle);\n      \n //DrawableTypeRequest.java     \n\tprivate static </*省略*/> FixedLoadProvider</*省略*/> buildProvider(Glide glide,\n            ModelLoader<A, InputStream> streamModelLoader,\n            ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader, Class<Z> resourceClass,\n            Class<R> transcodedClass,\n            ResourceTranscoder<Z, R> transcoder) {\n\n\n        if (transcoder == null) {\n            transcoder = glide.buildTranscoder(resourceClass, transcodedClass);\n        }\n        DataLoadProvider<ImageVideoWrapper, Z> dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class,\n                resourceClass);\n      \n        ImageVideoModelLoader<A> modelLoader = new ImageVideoModelLoader<A>(streamModelLoader,\n                fileDescriptorModelLoader);\n      \n        return new FixedLoadProvider</*省略*/>(modelLoader, transcoder, dataLoadProvider);\n    }\n```\n\n可以看到主要在buildProvider中构造了transcoder、dataLoadProvider、modelLoader。\n\n****\n\n具体方法自己跟进源码，记住不要沉迷细节无法自拔：\n\n- transcoder 是 ResourceTranscoder实例\n\n- dataLoadProvider 是 DataLoadProvider实例\n\n- modelLoader 是 ImageVideoModelLoader实例\n\n  返回的是FixedLoadProvider实例\n\n  ​\n\n### engin.load\n\n理清了loadprovider再回到onSizeReady中\n\n```java\n @Override\n    public void onSizeReady(int width, int height) {\n      \n        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();\n        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);\n        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();\n\n        loadedFromMemoryCache = true;\n      \n        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,priority, isMemoryCacheable, diskCacheStrategy, this);\n      \n        loadedFromMemoryCache = resource != null;\n\n    }\n```\n\n在跟进到engine.load中之前，我们先看下这个核心方法的注释，一个有良心的框架，在重要的方法上都应该好好写一下注释。。\n\n```java\n     * <p>\n     *     The flow for any request is as follows:\n     *     <ul>\n     *         <li>Check the memory cache and provide the cached resource if present</li>\n     *         <li>Check the current set of actively used resources and return the active resource if present</li>\n     *         <li>Check the current set of in progress loads and add the cb to the in progress load if present</li>\n     *         <li>Start a new load</li>\n     *     </ul>\n     * </p>\n     \n       对于任何请求，都按照下面的逻辑步骤来执行：\n       - 检测内存缓存，如果有就向View提供缓存的资源\n       - 检查当前正在使用的资源，如果有就返回\n       - 检查已经进行中的请求，如果已经包含了该资源，就添加一个回调到进行中的请求中\n       - 如果上面都没有 就开启一个新的load请求\n```\n\n那么就可以把load源码中的部分进行删减，我们就从新开一个load请求这个情况分析\n\n```java\npublic <T, Z, R> LoadStatus load(/*省略参数*/) {\n        Util.assertMainThread();\n        long startTime = LogTime.getLogTime();\n\n        final String id = fetcher.getId();\n        EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n                loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n                transcoder, loadProvider.getSourceEncoder());\n\n        /*省略三个if检测条件*/\n\n        EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n        DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n                transcoder, diskCacheProvider, diskCacheStrategy, priority);\n        EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n        jobs.put(key, engineJob);\n        engineJob.addCallback(cb);\n        engineJob.start(runnable);\n\n        return new LoadStatus(cb, engineJob);\n    }\n```\n\n逐个分析吧  EngineJob\n\n```java\n/**\n * A class that manages a load by adding and removing callbacks for for the load and notifying callbacks when the load completes.\n 一个通过添加和移除回调方法来管理load请求，并且当load完成之后通知回调的类。  有注释就是好哇\n */\nclass EngineJob implements EngineRunnable.EngineRunnableManager{...}       \n\npublic EngineJob build(Key key, boolean isMemoryCacheable) {\n            return new EngineJob(key, diskCacheService, sourceService, isMemoryCacheable, listener);\n        }\n```\n\nDecodeJob看名字就像负责解码的，暂时略过\n\nEngineRunnable\n\n```java\n/**\n * A runnable class responsible for using an {@link com.bumptech.glide.load.engine.DecodeJob} to decode resources on a\n * background thread in two stages.\n * <p>\n *     In the first stage, this class attempts to decode a resource\n *     from cache, first using transformed data and then using source data. If no resource can be decoded from cache,\n *     this class then requests to be posted again. During the second stage this class then attempts to use the\n *     {@link com.bumptech.glide.load.engine.DecodeJob} to decode data directly from the original source.\n * </p>\n\n\t在第一阶段先尝试从cache中decode出资源，如果没有就直接从original中decode data\n */\nclass EngineRunnable implements Runnable, Prioritized {...}\n```\n\n然后把EngineRunnable放到EngineJob中执行\n\n```java\n\tprivate final ExecutorService diskCacheService;    \n\tpublic void start(EngineRunnable engineRunnable) {\n        this.engineRunnable = engineRunnable;\n        future = diskCacheService.submit(engineRunnable);\n    }\n```\n\n进入到EngineRunnable的run方法中：\n\n```java\n    @Override\n    public void run() {\n        Exception exception = null;\n        Resource<?> resource = null;\n        try {\n            resource = decode();\n        } catch (Exception e) {\n            exception = e;\n        }\n\n        if (resource == null) {\n            onLoadFailed(exception);\n        } else {\n            onLoadComplete(resource);\n        }\n    }\n    private Resource<?> decode() throws Exception {\n        if (isDecodingFromCache()) {\n            return decodeFromCache();\n        } else {\n            return decodeFromSource();\n        }\n    }\n    private Resource<?> decodeFromSource() throws Exception {\n        return decodeJob.decodeFromSource();\n    }\n```\n\n最后走到decodeJob来做网络请求\n\n```java\n    public Resource<Z> decodeFromSource() throws Exception {\n        Resource<T> decoded = decodeSource();\n        return transformEncodeAndTranscode(decoded);\n    }\n\n    private Resource<T> decodeSource() throws Exception {\n        Resource<T> decoded = null;\n        try {\n            final A data = fetcher.loadData(priority);\n            decoded = decodeFromSourceData(data);\n        } finally {\n            fetcher.cleanup();\n        }\n        return decoded;\n    }\n```\n\n根据上面分析，可以知道这个fetcher是从ImageVideoModelLoader中获取的，返回的是ImageVideoFetcher实例。\n\n跟进ImageVideoFetcher的`loadData`\n\n#### streamFetcher.loadData\n\n```java\n\t\t@Override\n        public ImageVideoWrapper loadData(Priority priority) throws Exception {\n            InputStream is = null;\n            if (streamFetcher != null) {\n                try {\n                    is = streamFetcher.loadData(priority);\n                } catch (Exception e) {\n                }\n            }\n            ParcelFileDescriptor fileDescriptor = null;\n            if (fileDescriptorFetcher != null) {\n                try {\n                    fileDescriptor = fileDescriptorFetcher.loadData(priority);\n                } catch (Exception e) {\n                }\n            }\n            return new ImageVideoWrapper(is, fileDescriptor);\n        }\n```\n\n```java\n    @Override\n    public DataFetcher<ImageVideoWrapper> getResourceFetcher(A model, int width, int height) {\n        DataFetcher<InputStream> streamFetcher = null;\n        if (streamLoader != null) {\n            streamFetcher = streamLoader.getResourceFetcher(model, width, height);\n        }\n        DataFetcher<ParcelFileDescriptor> fileDescriptorFetcher = null;\n        if (fileDescriptorLoader != null) {\n            fileDescriptorFetcher = fileDescriptorLoader.getResourceFetcher(model, width, height);\n        }\n\n        if (streamFetcher != null || fileDescriptorFetcher != null) {\n            return new ImageVideoFetcher(streamFetcher, fileDescriptorFetcher);\n        } else {\n            return null;\n        }\n    }\n```\n\n这个streamFetcher结合初始化`loadGeneric`的代码可以知道是HttpUrlFetcher的实例，跟进查看其`loadData`方法\n\n```java\n@Override\n    public InputStream loadData(Priority priority) throws Exception {\n        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());\n    }\n\n    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map<String, String> headers)\n            throws IOException {\n\n        urlConnection = connectionFactory.build(url);\n        for (Map.Entry<String, String> headerEntry : headers.entrySet()) {\n          urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());\n        }\n        urlConnection.setConnectTimeout(2500);\n        urlConnection.setReadTimeout(2500);\n        urlConnection.setUseCaches(false);\n        urlConnection.setDoInput(true);\n\n        // Connect explicitly to avoid errors in decoders if connection fails.\n        urlConnection.connect();\n        if (isCancelled) {\n            return null;\n        }\n        final int statusCode = urlConnection.getResponseCode();\n        if (statusCode / 100 == 2) {\n            return getStreamForSuccessfulRequest(urlConnection);\n        } else if (statusCode / 100 == 3) {\n\n        } else {\n\n        }\n    }\n```\n\n可以看到在`loadDataWithRedirects`中通过httpUrlConnection来完成网络请求。成功之后就调用`getStreamForSuccessfulRequest`\n\n```java\n   private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)\n            throws IOException {\n        if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {\n            int contentLength = urlConnection.getContentLength();\n            stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);\n        } else {\n            stream = urlConnection.getInputStream();\n        }\n        return stream;\n    }\n```\n\n将成功请求的io流返回而已。\n\n#### return ImageVideoWrapper\n\n一路返回到上面说的ImageVideoFetcher的`loadData`方法中，继续往下走\n\n```java\n\t\t@Override\n        public ImageVideoWrapper loadData(Priority priority) throws Exception {\n            InputStream is = null;\n            is = streamFetcher.loadData(priority);\n            ParcelFileDescriptor fileDescriptor = null;\n            if (fileDescriptorFetcher != null) {\n\t\t\t\tfileDescriptor = fileDescriptorFetcher.loadData(priority);\n            }\n            return new ImageVideoWrapper(is, fileDescriptor);\n        }\n```\n\n返回ImageVideoWrapper到DecodeJob中\n\n```java\n private Resource<T> decodeSource() throws Exception {\n        Resource<T> decoded = null;\n        try {\n            final A data = fetcher.loadData(priority);\n            decoded = decodeFromSourceData(data);\n        } finally {\n            fetcher.cleanup();\n        }\n        return decoded;\n    }\n```\n\n再跟进到`decodeFromSourceData`\n\n===暂时烂尾===\n\n```java\n//ImageViewTarget.java\n    @Override\n    public void onLoadStarted(Drawable placeholder) {\n        view.setImageDrawable(placeholder);\n    }\n```\n\n","tags":["Glide"],"categories":["Android"]},{"title":"RxJava","url":"/2018/03/28/RxJava源码解析/","content":"\nRxJava流程分析\n\n<!-- more -->  \n\n# 基本使用\n\n```java\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"haha\");\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(String s) {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n```\n\n## create\n\n无脑跟进法\n\n```java\n    public static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n\n    public ObservableCreate(ObservableOnSubscribe<T> source) {\n        this.source = source;\n    }\n\n    public static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {\n        Function<? super Observable, ? extends Observable> f = onObservableAssembly;\n        if (f != null) {\n            return apply(f, source);\n        }\n        return source;\n    }\n```\n\n通过`Observable.create()`返回一个Observable子类ObservableCreate的实例。\n\n## subscribe\n\n跟进`subscribe`，ObservableCreate没有重写该方法，在父类Observable中查找：\n\n```java\n    public final void subscribe(Observer<? super T> observer) {\n        try {\n          \n            observer = RxJavaPlugins.onSubscribe(this, observer);\n            subscribeActual(observer);\n          \n        } catch (NullPointerException e) { // NOPMD\n            throw e;\n        } catch (Throwable e) {\n            throw npe;\n        }\n    }\n```\n可以再来看看`RxJavaPlugins.onSubscribe`搞什么鬼\n\n```java\n    public static <T> Observer<? super T> onSubscribe(@NonNull Observable<T> source, @NonNull Observer<? super T> observer) {\n        BiFunction<? super Observable, ? super Observer, ? extends Observer> f = onObservableSubscribe;\n        if (f != null) {\n            return apply(f, source, observer);\n        }\n        return observer;\n    }\n```\n\n可以发现包括上面的`onAssembly`，RxJavaPlugins做的都是一些额外包装的工作，类似于hook的功能，如果分析朱脉络的可以先不管这个东西。\n\n在看看`subscribeActual(observer);`，在Observable中是抽象方法，说明针对不同的创建操作符，如create、just等，都继承于Observable，并重写了subscribeActual来实现具体的逻辑。\n\n```java\n    protected abstract void subscribeActual(Observer<? super T> observer);\n```\n\n跟进`ObservableCreate.subscribeActual`\n\n```java\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        observer.onSubscribe(parent);\n\n        try {\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n```\n\n先讲observer包装为CreateEmitter\n\n```java\nstatic final class CreateEmitter<T>  extends AtomicReference<Disposable>\n    \t\t\t\t\timplements ObservableEmitter<T>, Disposable {\n\t\t...\n        final Observer<? super T> observer;\n\n        CreateEmitter(Observer<? super T> observer) {\n            this.observer = observer;\n        }\n        ...\n}\n```\n\n再通过`observer.onSubscribe(parent);`回调我们传入的observer的`void onSubscribe(@NonNull Disposable d)`方法，通常我们就是在这里拿到disposable对象来中断流的发送。\n\n然后通过`source.subscribe(parent);`回调我们传入的Observable的`void subscribe(@NonNull ObservableEmitter<T> e) throws Exception`方法，通常我们是在这里拿到ObservableEmitter对象，即上述的parent对象，来调用他的onNext等方法。\n\n再回到基本使用\n\n```java\nObservable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"haha\");\n            }\n        })\n  \t\t\t...\n}\n```\n\n在create传入的ObservableOnSubscribe就是ObservableCreate中的source，subscribe方法中的参数`ObservableEmitter<String> e`就是ObservableCreate的方法subscribeActual中`source.subscribe(parent);`的参数`parent`，即`new CreateEmitter<T>(observer);`。\n\ne = parent = new CreateEmitter<T>(observer)\n\n所以来看看parent即CreateEmitter的onNext方法\n\n```java\n        @Override\n        public void onNext(T t) {\n            if (!isDisposed()) {\n                observer.onNext(t);\n            }\n        }\n```\n\n就是这么回调到`observer.onNext(t);`中滴，流程很清楚。\n\n# 线程调度\n\n```java\n  Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"haha\");\n            }\n        }).subscribeOn(Schedulers.io())\n    \t.observeOn(AndroidSchedulers.mainThread())\n   \t\t.subscribe(new Observer<String>() {\n      \t\t...\n    \t});\n\n```\n\n## subscribeOn \n\n“订阅”所在的线程，即Observable中subscribe方法所在线程，即上游所在线程。\n\n无脑跟进法，启动。。\n\n```java\n    public final Observable<T> subscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaPlugins.onAssembly(new ObservableSubscribeOn<T>(this, scheduler));\n    }\n\n```\n\n跟上面分析的create其实差不多，在没有Function的情况下，onAssembly的返回值就是他的参数。再回顾一下create方法，返回的是包装了`source`的ObservableCreate。\n\n```java\npublic static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n```\n\n那么在`subscribeOn`方法中，onAssembly参数中构造的ObservableSubscribeOn的参数this就是这个ObservableCreate，同时还有一个scheduler。\n\n```java\n    public ObservableSubscribeOn(ObservableSource<T> source, Scheduler scheduler) {\n        super(source);\n        this.scheduler = scheduler;\n    }\n```\n\n先不考虑observerOn，直接按照上面分析的订阅流程来，会调用到ObservableSubscribeOn的`subscribeActual`方法\n\n```java\n    @Override\n    public void subscribeActual(final Observer<? super T> s) {\n        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);\n\n        s.onSubscribe(parent);\n\n        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n    }\n```\n\n比ObservableCreate的subscribeActual多了一个`parent.setDisposable…`，跟进scheduler.scheduleDirect之前先看一下scheduler具体是哪个子类\n\n```java\n\n    public static Scheduler newThread() {\n        return RxJavaPlugins.onNewThreadScheduler(NEW_THREAD);\n    }\n\n    public static Scheduler onNewThreadScheduler(@NonNull Scheduler defaultScheduler) {\n        Function<? super Scheduler, ? extends Scheduler> f = onNewThreadHandler;\n        if (f == null) {\n            return defaultScheduler;\n        }\n        return apply(f, defaultScheduler);\n    }\n\n```\n\n返回的是传入的NEW_THREAD,那么在看看这个NEW_THREAD又是个啥\n\n```java\nNEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask());\n\npublic static Scheduler initNewThreadScheduler(@NonNull Callable<Scheduler> defaultScheduler) {\n    \n        Function<...> f = onInitNewThreadHandler;\n        if (f == null) {\n            return callRequireNonNull(defaultScheduler);\n        }\n        \n    }\nstatic Scheduler callRequireNonNull(@NonNull Callable<Scheduler> s) {\n        try {\n            \n            return ObjectHelper.requireNonNull(s.call(), \"...\");\n            \n        } catch (Throwable ex) {\n            \n        }\n    }\npublic static <T> T requireNonNull(T object, String message) {\n        if (object == null) {\n            throw new NullPointerException(message);\n        }\n        return object;\n    }\n```\n\n看上面代码就知道返回的是`new NewThreadTask().call()`\n\n```java\n  static final class NewThreadTask implements Callable<Scheduler> {\n        @Override\n        public Scheduler call() throws Exception {\n            return NewThreadHolder.DEFAULT;\n        }\n    }\n    static final class NewThreadHolder {\n        static final Scheduler DEFAULT = new NewThreadScheduler();\n    }\n    public NewThreadScheduler() {\n        this(THREAD_FACTORY);\n    }\n```\n\noj8k,上面线程调度传入的Scheduler.newThread()即为NewThreadScheduler实例。\n\n再回到上面ObservableSubscribeOn的subscribeActual方法中跟进`scheduler.scheduleDirect(new SubscribeTask(parent)`\n\n```java\npublic Disposable scheduleDirect(@NonNull Runnable run) {\n        return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);\n}\n\npublic Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {\n        final Worker w = createWorker();\n\n        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        DisposeTask task = new DisposeTask(decoratedRun, w);\n\n        w.schedule(task, delay, unit);\n\n        return task;\n    }\n```\n\ncreateWorker由NewThreadScheduler重写\n\n。。就写到这吧，不想分析了，后面就是封装runnable submit到线程池执行，溜了溜了，准备上班\n\nrunnable就是\n\n```java\n\n    final class SubscribeTask implements Runnable {\n        private final SubscribeOnObserver<T> parent;\n\n        SubscribeTask(SubscribeOnObserver<T> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void run() {\n            source.subscribe(parent);\n        }\n    }\n```\n\n其实就是把source.subscribe(parent);放到县城里执行达到调度的效果嘛。","tags":["RxJava"],"categories":["Android"]},{"title":"EventBus 源码分析","url":"/2018/03/18/eventbus源码走读/","content":"事件总线框架EventBus源码走读分析\n\n<!-- more -->  \n\n\n\n# 基本使用\n\n在onCreated(init在BaseActivity中的onCreated调用)中注册，onDestroy中取消注册\n\n通过`@Subscribe`注解来修饰订阅事件的处理函数\n\n```java\npublic class EventBusActivity extends BaseActivity {\n    @Override\n    public int getLayoutID() {\n        return R.layout.activity_eventbus;\n    }\n\n    @Override\n    public void init() {\n        super.init();\n        EventBus.getDefault().register(this);\n    }\n\n    @Subscribe(threadMode = ThreadMode.MAIN)\n    public void onHandleMyEvent(MyEvent event){\n        XLog.i(event.getMessage());\n        msgTv.setText(event.getMessage());\n\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        EventBus.getDefault().unregister(this);\n    }\n}\n//自定义的事件类\npublic class MyEvent {\n    private String message;\n\n    public MyEvent(String message) {\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n}\n```\n\n在另一个Activity中 通过\n\n```java\n EventBus.getDefault().post(new MyEvent(\"this msg from TestActivity\"));\n```\n\n即可发送事件到EventBusActivity\n\n# 源码分析\n\n## register\n\n```java\n    public void register(Object subscriber) {\n        Class<?> subscriberClass = subscriber.getClass();\n        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n        synchronized (this) {\n            for (SubscriberMethod subscriberMethod : subscriberMethods) {\n                subscribe(subscriber, subscriberMethod);\n            }\n        }\n    }\n\nList<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {\n  \t//查找缓存\n        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);\n        if (subscriberMethods != null) {\n            return subscriberMethods;\n        }\n\n  \t//ignoreGeneratedIndex 默认为false\n        if (ignoreGeneratedIndex) {\n            subscriberMethods = findUsingReflection(subscriberClass);\n        } else {\n            subscriberMethods = findUsingInfo(subscriberClass);\n        }\n        if (subscriberMethods.isEmpty()) {\n          \n        } else {\n          //放到缓存里\n            METHOD_CACHE.put(subscriberClass, subscriberMethods);\n            return subscriberMethods;\n        }\n    }\n\nprivate List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {\n        FindState findState = prepareFindState();\n        findState.initForSubscriber(subscriberClass);\n        while (findState.clazz != null) {\n            findState.subscriberInfo = getSubscriberInfo(findState);\n            //最简单的情况下info==null\n            if (findState.subscriberInfo != null) {\n                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n                for (SubscriberMethod subscriberMethod : array) {\n                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                        findState.subscriberMethods.add(subscriberMethod);\n                    }\n                }\n            } else {\n                //所以还是会调用这个方法\n                findUsingReflectionInSingleClass(findState);\n            }\n            findState.moveToSuperclass();\n        }\n        return getMethodsAndRelease(findState);\n    }\n```\n\n```java\n//在findUsingReflectionInSingleClass中就是通过了反射来获取的这个订阅类上所有的方法注解来判断 \n//并添加到findState.subscriberMethods中\nif (findState.checkAdd(method, eventType)) {\n    findState.subscriberMethods.add(\n        new SubscriberMethod(method, eventType, threadMode\n           ,subscribeAnnotation.priority(),subscribeAnnotation.sticky())   );\n}\n\n//findState也是有订阅类来init的\nfindState.initForSubscriber(subscriberClass);\nvoid initForSubscriber(Class<?> subscriberClass) {\n    this.subscriberClass = clazz = subscriberClass;\n    skipSuperClasses = false;\n    subscriberInfo = null;\n}\n```\n\n## post\n\n```java\npublic void post(Object event) {\n    PostingThreadState postingState = currentPostingThreadState.get();\n    List<Object> eventQueue = postingState.eventQueue;\n    eventQueue.add(event);\n\n    if (!postingState.isPosting) {\n        postingState.isMainThread = isMainThread();\n        postingState.isPosting = true;\n        try {\n            while (!eventQueue.isEmpty()) {\n                postSingleEvent(eventQueue.remove(0), postingState);\n            }\n        } finally {\n            postingState.isPosting = false;\n            postingState.isMainThread = false;\n        }\n    }\n}\nprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n    Class<?> eventClass = event.getClass();\n    boolean subscriptionFound = false;\n    if (eventInheritance) {\n \t\t\t//默认false\n    } else {\n        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n    }\n    if (!subscriptionFound) {\n \t\t//...\n    }\n}\nprivate boolean postSingleEventForEventType(/*...*/) {\n    CopyOnWriteArrayList<Subscription> subscriptions;\n    synchronized (this) {\n        //在订阅的时候会把 事件类型与对应的Subs添加到这个map中\n        //subscriptionsByEventType.put(eventType, subscriptions);\n        subscriptions = subscriptionsByEventType.get(eventClass);\n    }\n    if (subscriptions != null && !subscriptions.isEmpty()) {\n        for (Subscription subscription : subscriptions) {\n            //for循环  invoke每个注册登记的方法\n            postingState.event = event;\n            postingState.subscription = subscription;\n            boolean aborted = false;\n            try {\n                postToSubscription(subscription, event, postingState.isMainThread);\n                aborted = postingState.canceled;\n            } finally {\n                //...\n            }\n        }\n        return true;\n    }\n    return false;\n}\n//来到重头戏\nprivate void postToSubscription(/**/) {\n    switch (subscription.subscriberMethod.threadMode) {\n        case MAIN:\n            if (isMainThread) {\n                invokeSubscriber(subscription, event);\n            } else {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            break;\n    }\n}\n//反射调用  莫得感情 只分析简单的使用的话流程就这么简单\nvoid invokeSubscriber(Subscription subscription, Object event) {\n    try {\n        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n    }  \n}\n\n```\n\n# 参考\n\n[EventBus 3.0进阶：源码及其设计模式 完全解析](https://www.jianshu.com/p/bda4ed3017ba)","tags":["事件总线"],"categories":["Android框架"]},{"title":"Android热更新总结","url":"/2018/03/16/热更新全解/","content":"Android热更新总结\n\n<!-- more -->  \n\n# 类加载方案\n\n类加载方案，我更偏向于叫dex插队方案，实现原理基于ClassLoader，原理看[Android中的ClassLoader](https://melonwxd.github.io/2017/10/17/classloader1/#Android的ClassLoader)。使用这类的基本是腾讯系。\n\n大致流程如下\n\n1. 应用刚开始启动的时候(App.onCreated)，连接服务器，检测是否有更新补丁patch.dex，如果有就下载下来。\n2. 创建新的ClassLoader主动加载补丁patch.dex中的类，反射获取dexElements。\n3. 通过反射将上面获取的dexElements插入到App应用当前的类加载的dexElements之前。\n4. 这样当应用要调用出bug的模块的时候，会优先加载patch.dex中的类，从而实现bug修复。\n\n下图中Qzone.class就是要修复的类。\n\n![](http://owu391pls.bkt.clouddn.com/640.webp)\n\n\n\n\n\n\n\n## Dalvik虚拟机的CLASS_ISPREVERIFIED\n\n在dvm虚拟机中，如果某个类`Clz1`被打上了`CLASS_ISPREVERIFIED`标志，就会进行dex校验，如果检验失败则抛出\"unexpected DEX\"异常。如果对于`Clz1`来说，被其引用到的类，都应该与`Clz1`在同一个dex文件中，就会打上`CLASS_ISPREVERIFIED`标签。\n\nhttp://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Resolve.cpp#119\n\n```java\n63 ClassObject* dvmResolveClass(const ClassObject* referrer, u4 classIdx,\n64    bool fromUnverifiedConstant)\n65{\n66    DvmDex* pDvmDex = referrer->pDvmDex;\n67    ClassObject* resClass;\n68    const char* className;\n\n  // 这是查找缓存 是否已经加载过该class，下面讲手Q方案会用到，这里暂时忽略\n74    resClass = dvmDexGetResolvedClass(pDvmDex, classIdx);\n75    if (resClass != NULL)\n76        return resClass;\n  \n  \t\t//在这里通过classIdx在dex文件中查找原先的bug类\n90    className = dexStringByTypeIdx(pDvmDex->pDexFile, classIdx);\n91    if (className[0] != '\\0' && className[1] == '\\0') {\n \n93        resClass = dvmFindPrimitiveClass(className[0]);\n94    } else {\n  \n  \t\t//在这里通过ClassLoader来查找bug类，根据修复原理，这个时候找到的bug类是插队进去的已经修复的类\n95        resClass = dvmFindClassNoInit(className, referrer->classLoader);\n96    }\n97\n98    if (resClass != NULL) {\n  \t\t\t//检测是否需要进行dex校验\n118        if (!fromUnverifiedConstant &&\n119            IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED))\n120        {\n121            ClassObject* resClassCheck = resClass;\n122            if (dvmIsArrayClass(resClassCheck))\n123                resClassCheck = resClassCheck->elementClass;\n\t\t\t\t//dex校验 referrer->pDvmDex是class.dex  resClassCheck->pDvmDex是patch.dex 所以报错！\n125            if (referrer->pDvmDex != resClassCheck->pDvmDex &&\n126                resClassCheck->classLoader != NULL)\n127            {\n128                ALOGW(\"Class resolved by unexpected DEX:\"\n129                     \" %s(%p):%p ref [%s] %s(%p):%p\",\n130                    referrer->descriptor, referrer->classLoader,\n131                    referrer->pDvmDex,\n132                    resClass->descriptor, resClassCheck->descriptor,\n133                    resClassCheck->classLoader, resClassCheck->pDvmDex);\n134                ALOGW(\"(%s had used a different %s during pre-verification)\",\n135                    referrer->descriptor, resClass->descriptor);\n136                dvmThrowIllegalAccessError(\n137                    \"Class ref in pre-verified class resolved to unexpected \"\n138                    \"implementation\");\n139                return NULL;\n140            }\n141        }\n\t\t\t//如果加载class没问题 就把他放到缓存里去\n154        dvmDexSetResolvedClass(pDvmDex, classIdx, resClass);\n155    } else {\n\n160    }\n161\n162    return resClass;\n163}\n```\n\n\n\n**待解决：为什么multiDex没有出现问题？应该是从条件上直接避免了判断？具体还要查看dvm加载流程**\n\n判断是否要进行dex校验的代码为：\n\n```java\n118        if (!fromUnverifiedConstant &&\n119            IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED))\n```\n\n2个条件 一个是 `fromUnverifiedConstant`  一个是 `CLASS_ISPREVERIFIED` 标记。\n\n```java\n57 * \"fromUnverifiedConstant\" should only be set if this call is the direct\n58 * result of executing a \"const-class\" or \"instance-of\" instruction, which\n59 * use class constants not resolved by the bytecode verifier.\n```\n\nfromUnverifiedConstant的注释说明如上，稍后会说明，下面主要来说一下`CLASS_ISPREVERIFIED`\n\nhttp://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexPrepare.cpp#1067\n\n而为类打上`CLASS_ISPREVERIFIED`标记的代码如下：\n\n```java\n1067    if (doVerify) {\n1068        if (dvmVerifyClass(clazz)) {\n1069            /*\n1070             * Set the \"is preverified\" flag in the DexClassDef.  We\n1071             * do it here, rather than in the ClassObject structure,\n1072             * because the DexClassDef is part of the odex file.\n1073             */\n1074            assert((clazz->accessFlags & JAVA_FLAGS_MASK) ==\n1075                pClassDef->accessFlags);\n1076            ((DexClassDef*)pClassDef)->accessFlags |= CLASS_ISPREVERIFIED;\n1077            verified = true;\n1078        } else {\n1079            // TODO: log when in verbose mode\n1080            ALOGV(\"DexOpt: '%s' failed verification\", classDescriptor);\n1081        }\n1082    }\n```\n\nhttp://androidxref.com/4.4.4_r1/xref/dalvik/vm/analysis/DexVerify.cpp#40\n\n```java\n40bool dvmVerifyClass(ClassObject* clazz)\n41{\n42    int i;\n43\n44    if (dvmIsClassVerified(clazz)) {\n45        ALOGD(\"Ignoring duplicate verify attempt on %s\", clazz->descriptor);\n46        return true;\n47    }\n48\n49    for (i = 0; i < clazz->directMethodCount; i++) {\n50        if (!verifyMethod(&clazz->directMethods[i])) {\n51            LOG_VFY(\"Verifier rejected class %s\", clazz->descriptor);\n52            return false;\n53        }\n54    }\n55    for (i = 0; i < clazz->virtualMethodCount; i++) {\n56        if (!verifyMethod(&clazz->virtualMethods[i])) {\n57            LOG_VFY(\"Verifier rejected class %s\", clazz->descriptor);\n58            return false;\n59        }\n60    }\n61\n62    return true;\n63}\n```\n\n通过遍历`clazz->directMethods`和`clazz->virtualMethods`来验证。\n\ndirectMethods包含了以下方法：\n\n- static方法\t\n- private方法\n- 构造函数\n\n\n\n## 解决方法\n\n想要避免`CLASS_ISPREVERIFIED`就要从上述的三个条件中着手：\n\n- 让class不被打上`CLASS_ISPREVERIFIED`标志，就不会进行dex校验\n- 让fromUnverifiedConstant 为true，就不会进行dex校验\n- 让dex校验判断异常的语句`referrer->pDvmDex != resClassCheck->pDvmDex` 不成立\n\n下面将三个解决方案分别对应上述三点。\n\n### QQ空间\n\n往所有类的构造函数里面插入了一段代码：\n\n```java\nif (ClassVerifier.PREVENT_VERIFY) {\n\tSystem.out.println(AntilazyLoad.class);\n}\n```\n\n并将AntilazyLoad类打包成一个单独的hack.dex，这样就让classes.dex内的类都会引用一个在不相同dex中的AntilazyLoad类，这样就防止了类被打上`CLASS_ISPREVERIFIED`的标志了。\n\n但是这样做的缺点就是失去了dvm的优化效果了：verify+optimize\n\n### 手机QQ\n\n通过fromUnverifiedConstant来突破\n\n**方案一**\n\n```java\n118        if (!fromUnverifiedConstant &&\n119            IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED))\n```\n\n```java\n57 * \"fromUnverifiedConstant\" should only be set if this call is the direct\n58 * result of executing a \"const-class\" or \"instance-of\" instruction, which\n59 * use class constants not resolved by the bytecode verifier.\n```\n\n注释中的翻译大概是：只有通过\"const-class\" or \"instance-of\"指令直接调用的时候，fromUnverifiedConstant才为true。\n\n补丁安装后，预先以 const-class/instance-of 方式主动引用补丁类，这次引用会触发加载补丁类并将引用放入 dex 的已解析类缓存里，后续 app 实际业务逻辑引用到补丁类时，直接从已解析缓存里就能取到，这样很简单地就绕开了“unexpected DEX”异常。\n\n缺点：想要预先引用补丁类，意味着一开始就要知道出现bug的类的名称是哪个，这显然不现实。\n\n**方案二**\n\n在Native层主动调用dvmResolveClass方法，让传入的fromUnverifiedConstant为true\n\n```java\njavaClassObject* dvmResolveClass(const ClassObject* referrer, u4 classIdx,bool fromUnverifiedConstant)\n```\n\n所需要的有：\n\n- dvmResolveClass方法地址 \n- 参数 ClassObject* referrer 地址\n- 被引用类（补丁类） 的id classIdx\n- fromUnverifiedConstant 直接手动置1或true即可\n\ndvmResolveClass的获取可以通过dlopen获取/system/lib/libdvm.so句柄，dlsym获取函数地址。\n\nreferrer地址可以通过`dvmFindLoadedClass`来获取\n\nhttp://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp#4636\n\n```java\n4636ClassObject* dvmFindLoadedClass(const char* descriptor)\n4637{\n4638    int result;\n4639\n4640    dvmHashTableLock(gDvm.loadedClasses);\n4641    result = dvmHashForeach(gDvm.loadedClasses, findClassCallback,\n4642            (void*) descriptor);\n4643    dvmHashTableUnlock(gDvm.loadedClasses);\n4644\n4645    return (ClassObject*) result;\n4646}\n```\n\ndvmFindLoadedClass可以根据类的描述符来获取**已加载**的类，所以在补丁注入成功后，在每个 dex 里找一个固定的已经加载成功的引用类即可。对于主Dex，直接找Application即可，对于分Dex，手Q的分 dex 方案有这样的逻辑：每当一个分 dex 完成注入，主Dex都会尝试加载该分dex里的一个固定空类来验证分dex是否注入成功了。那么这个固定空类就可以作为patch的引用。\n\n至于补丁类的classIdx 通过`dexdump -h`即可获取：\n\n![](https://segmentfault.com/img/remote/1460000007189921?w=723&h=344)\n\n> 这个过程可以通过一个小程序自动进行：\n>\n> **输入：** 原有 apk 的所有 dex、补丁包所有的类名\n> **输出：** 补丁包每个类所在 dex 的编号以及 classIdx 的值\n\n\n\n### 微信Tinker\n\n微信Tinker框架的原理是通过生成dex差量包的方式，与QQ空间超级补丁技术基本相同，区别在于不再将patch.dex增加到elements数组中，而是差量的方式给出patch.dex，然后将patch.dex与应用的classes.dex合并，然后整体替换掉旧的dex文件，以达到修复的目的。\n\n![](http://img.blog.csdn.net/20170315001845944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjEyNDQzOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n# 底层替换方案\n\n原理：直接在native层进行方法的结构体信息对换，从而实现完美的方法新旧替换，从而实现热修复功能\n\n## todo\n\n## AndFix\n\n# 参考\n[QFix探索之路—手Q热补丁轻量级方案](https://segmentfault.com/a/1190000007189905)\n\n\n","tags":["Dalvik","热更新"],"categories":["Android"]},{"title":"HTTP的缓存控制","url":"/2018/03/15/Http缓存控制/","content":"Http中关于缓存相关的知识与Android网络框架设置缓存的方法。\n\n<!-- more -->  \n\n# 常见缓存头\n\n## Expires 过期时间\n\n告知 客户端/缓存服务器 资源失效的日期，在Expires指定的日期之前，服务器响应的副本会一直被保留，作为响应发送给请求。如果在日期之后，缓存服务器就会向源服务器请求资源。\n\n## Cache-Control 缓存控制\n\nCache-Control与Expires的作用一致，但Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。\n\n指令的参数如下：\n\n![](http://owu391pls.bkt.clouddn.com/http-cache1.png)\n\n![](http://owu391pls.bkt.clouddn.com/httpcache2.png)\n\n参数是可选的，多个指令之间通过逗号“,”分隔。首部字段 Cache-Control 的指令可用于请求和响应。\n\n下面挑两个常见的指令来讲一下：\n\n- no-cache:【请求】表示客户端强制缓存服务器向源服务器重新获取资源。【响应】表示源服务器不建议缓存服务器对资源进行缓存，实际上还是会缓存。\n- max-age:【请求】在max-age指定时间内获取的是缓存服务器的缓存。当max-age为0的时候缓存服务器通常要将请求转发给源。【响应】表示缓存在max-age指定时间内不需要再像源服务器请求资源。（若于Expires同时存在，HTTP/1.1 中忽略Expires，HTTP/1.0中忽略max-age）\n\n## Last-Modified/If-Modified-Since\n\nLast-Modified:源服务器在响应请求时告诉客户端这个响应资源的最后修改时间\n\nIf-Modified-Since:客户端通过该字段指定一个时间T1，如果服务器上该资源最后更新日期在T1之后，那么就正常响应返回资源。如果在T1之前都没有更新过，则返回304(Not Modified)。\n\n## ETag/If-None-Match\n\nETag:当资源被缓存的时候，会被分配唯一的标识id(类似于hash，生成规则不固定，由服务器来分配)，当数据没有改变的时候，服务器返回304(Not Modified)。当缓存数据改变了，ETag也随着改变，服务器就会重新返回资源给你。而客户端请求服务器时，是通过If-None-Match来携带已缓存资源的ETag值。\n\n\n\n# OKHTTP中设置缓存\n\n## 常规设置\n\n```java\n//缓存文件夹\nFile cacheFile = new File(getExternalCacheDir().toString(),\"cache\");\n//缓存大小为10M\nint cacheSize = 10 * 1024 * 1024;\n//创建缓存对象\nCache cache = new Cache(cacheFile,cacheSize);\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .cache(cache)\n        .build();\n```\n\n这样的话当服务器返回的响应头中有Cache-Control时OkHttp自动就会帮我们缓存了。但是如果服务器不支持的话就需要我们手动添加了。\n\n##拦截缓存 \n\n跟拦截打印请求日志一样，我们可以手动在响应报文中添加Cache-Control\n\n```java\nclass CacheInterceptor implements Interceptor{\n\n        @Override\n        public Response intercept(Chain chain) throws IOException {\n\n            Response originResponse = chain.proceed(chain.request());\n\n            //设置缓存时间为60秒，并移除了pragma消息头，移除它的原因是因为pragma也是控制缓存的一个消息头属性\n            return originResponse.newBuilder().removeHeader(\"pragma\")\n                    .header(\"Cache-Control\",\"max-age=60\").build();\n        }\n    }\n```\n\n\n\n\n\n# 参考\n\n[浏览器 HTTP 协议缓存机制详解](https://my.oschina.net/leejun2005/blog/369148)\n\n图解HTTP-第六章\n","tags":["网络编程"],"categories":["网络基础"]},{"title":"Android性能优化","url":"/2018/03/14/Android性能优化/","content":"Android性能优化简洁\n<!-- more -->  \n\n# 布局优化\n## 布局标签的使用\n### include\n\n通过include将共同的布局模块化，实现布局复用\n\n### merge\n\nmerge会自动优化多余的视图，多用于替换frameLayout或者当一个布局包含另一个布局的时候。\n\n**当把有`<merge>`标签的布局放在`<include>`中的时候，就会忽视`<merge>`**\n\n### viewstub\n\nviewstub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等。\n\n## 其他\n\n- **用SurfaceView或TextureView代替普通View**\n\n-　**使用OpenGL绘图**\n\n-　**尽量为所有分辨率创建资源**\n\n-　**hierarchy viewer布局调优**\n\n  ​\n\n# 代码优化\n\n## 降低执行时间\n\n### 缓存\n\n- 线程池\n- 图片缓存：内存、磁盘\n- handler消息复用\n- Http的Cache-Control\n- IO缓存：BufferedInputStream替代InputStream，BufferedReader替代Reader，BufferedReader替代BufferedInputStream.对文件、网络IO皆适用。\n\n### 数据选择\n\n- String、StringBuilder、StringBuffer\n- SoftReference、WeakReference\n- final类型存储在常量区中读取效率更高\n- 应用内广播LocalBroadcastManager 高效、安全\n- ArrayList和LinkedList，HashMap和LinkedHashMap、Set\n- 使用自带的SpareArray和ArrayMap 替换HashMap\n\n## 提高执行效率\n\n- 多线程\n- 延迟操作 postDelay\n\n## 网络优化\n\n- 所有http请求必须添加httptimeout\n- gzip压缩  请求合并\n\n\n\n# 参考\n\n[性能优化系列总篇](http://www.trinea.cn/android/performance/)\n","tags":["性能优化"],"categories":["Android"]},{"title":"RxJava (五)","url":"/2018/03/12/rxjava-5/","content":"Android RxJava实际应用案例讲解：使用RxJava的最佳开发场景\n<!-- more -->\n[Android RxJava实际应用案例讲解：使用RxJava的最佳开发场景](http://blog.csdn.net/carson_ho/article/details/79168723)\n","tags":["RxJava"],"categories":["Android"]},{"title":"LeakCanary 源码分析","url":"/2018/03/07/LeakCanary分析/","content":"LeakCanary检测内存泄露原理\n<!-- more -->  \n\n# WeakReference和ReferenceQueue\n\n在jdk1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)四种。\n\n平常加载图片的时候，经常需要把经常显示的图片缓存在内存中来提高加载效率和程序的性能。想象一下如果在jdk1.1时代，我们的Bitmap缓存对象肯定通过强引用来缓存，就无法被GC了，如果缓存一多整个程序就gg了。所以WeakReference就出现了，当一个对象仅仅被WeakReference指向， 而没有任何其他StrongReference指向的时候， 如果GC运行， 那么这个对象就会被回收。所以厂常见的缓存算法LRUCache里面都是通过WeakReference来持有对象的。\n\n我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。ReferenceQueue即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即WeakReference对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。\n\n具体的用法如下：\n\n```java\npublic static void main(String[] args) {\n        ReferenceQueue<byte[]> referenceQueue = new ReferenceQueue();\n        Object value = new Object();\n        Map<Object, Object> map = new HashMap<>();\n        for(int i = 0;i < 10000;i++) {\n            byte[] bytes = new byte[1024*1024];\n            WeakReference<byte[]> weakReference = new WeakReference<byte[]>(bytes, referenceQueue);\n            map.put(weakReference, value);\n        }\n        System.out.println(\"map.size->\" + map.size());\n\n        Thread thread = new Thread(() -> {\n            try {\n                int cnt = 0;\n                WeakReference<byte[]> k;\n                while((k = (WeakReference) referenceQueue.remove()) != null) {\n                    System.out.println((cnt++) + \"回收了:\" + k);\n                }\n            } catch(InterruptedException e) {\n                //结束循环\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n```\n\n# LeakCanary\n\n## 使用\n\n最简单的使用就是在Application的onCreate中一行即搞定\n\n```java\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        LeakCanary.install(this);\n    }\n```\n\n## 原理\n\n采用无脑跟进法分析！\n\n```java\npublic static RefWatcher install(Application application) {\n    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)\n        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())\n        .buildAndInstall();\n  }\n\npublic static AndroidRefWatcherBuilder refWatcher(Context context) {\n    return new AndroidRefWatcherBuilder(context);\n  } \n```\n\n通过AndroidRefWatcherBuilder的`buildAndInstall`来创建一个RefWatcher实例\n\n```java\n  public RefWatcher buildAndInstall() {\n    RefWatcher refWatcher = build();\n    if (refWatcher != DISABLED) {\n      LeakCanary.enableDisplayLeakActivity(context);\n      ActivityRefWatcher.install((Application) context, refWatcher);\n    }\n    return refWatcher;\n  }\n```\n\n通过`ActivityRefWatcher.install`来创建ActivityRefWatcher实例并监听Activity的生命周期\n\n```java\npublic static void install(Application application, RefWatcher refWatcher) {\n    new ActivityRefWatcher(application, refWatcher).watchActivities();\n  }\n```\n\n```java\n  public void watchActivities() {\n    // Make sure you don't get installed twice.\n    stopWatchingActivities();\n    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);\n  }\n\n\n  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n      new Application.ActivityLifecycleCallbacks() {\n\t\t...\n        @Override public void onActivityDestroyed(Activity activity) {\n          ActivityRefWatcher.this.onActivityDestroyed(activity);\n        }\n      };\n\n```\n\n通过lifecycleCallbacks来在Activity的生命周期中回调，实际上只在`onActivityDestroyed`中做了处理，调用了 ActivityRefWatcher的onActivityDestroyed(activity)方法。\n\n```java\n  void onActivityDestroyed(Activity activity) {\n    refWatcher.watch(activity);\n  }\n```\n\n跟进\n\n```java\npublic void watch(Object watchedReference) {\n    watch(watchedReference, \"\");\n  }\n\n  public void watch(Object watchedReference, String referenceName) {\n    if (this == DISABLED) {\n      return;\n    }\n    checkNotNull(watchedReference, \"watchedReference\");\n    checkNotNull(referenceName, \"referenceName\");\n    final long watchStartNanoTime = System.nanoTime();\n    String key = UUID.randomUUID().toString();//生成唯一的key，来定位watchedReference\n    retainedKeys.add(key);\n    final KeyedWeakReference reference =\n        new KeyedWeakReference(watchedReference, key, referenceName, queue);\n\n    ensureGoneAsync(watchStartNanoTime, reference);\n  }\n\n\tprivate void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {\n    watchExecutor.execute(new Retryable() {\n      @Override public Retryable.Result run() {\n        return ensureGone(reference, watchStartNanoTime);\n      }\n    });\n  }\n```\n\n在watch中把被观察对象`watchedReference`封装成带有key值和带引用队列的KeyedWeakReference对象，然后在ensureGoneAsync中的ensureGone进行分析泄露。\n\n### 泄露分析\n\n```java\nRetryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {\n    long gcStartNanoTime = System.nanoTime();\n    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);\n\n    removeWeaklyReachableReferences();\n\n    if (debuggerControl.isDebuggerAttached()) {\n      // The debugger can create false leaks. \n      return RETRY;\n    }\n    if (gone(reference)) {\n      return DONE;\n    }\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n      long startDumpHeap = System.nanoTime();\n      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);\n\n      File heapDumpFile = heapDumper.dumpHeap();\n      if (heapDumpFile == RETRY_LATER) {\n        // Could not dump the heap.\n        return RETRY;\n      }\n      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);\n      heapdumpListener.analyze(\n          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,\n              gcDurationMs, heapDumpDurationMs));\n    }\n    return DONE;\n  }\n```\n\n先来看看`removeWeaklyReachableReferences`\n\n```java\n  private void removeWeaklyReachableReferences() {\n    KeyedWeakReference ref;\n    while ((ref = (KeyedWeakReference) queue.poll()) != null) {\n      retainedKeys.remove(ref.key);\n    }\n  }\n```\n\nKeyedWeakReference是WeakReference子类，这里用到的就是我上面介绍的 通过WeakReference加上ReferenceQueue来实现对已经被gc的对象做额外处理。如果`queue.poll()!=null`成立，说明被观察的对象已经被gc掉了，因为只有被gc了相应的包装类WeakReference的实例才会被添加到ReferenceQueue中。\n\n然后通过`gone`来判断是否有泄露\n\n```java\n private boolean gone(KeyedWeakReference reference) {\n    return !retainedKeys.contains(reference.key);\n  }\n```\n\n如果有泄露，就手动触发一下gc，再来判断有没有泄露。如果确认泄露了，那么就开始进入内存分析。\n\n### 内存快照分析\n\n```java\nif (!gone(reference)) {\n  long startDumpHeap = System.nanoTime();\n  long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);\n\n  File heapDumpFile = heapDumper.dumpHeap();\n  if (heapDumpFile == RETRY_LATER) {\n    // Could not dump the heap.\n    return RETRY;\n  }\n  long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);\n  heapdumpListener.analyze(\n      new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,\n          gcDurationMs, heapDumpDurationMs));\n}\n```\n确定泄露之后就要分析内存快照，根据上面唯一的key来定位，项目内部又使用了另一框架[haha](https://github.com/square/haha)来分析。\n\n分析的代码如下：\n\n```java\n      heapdumpListener.analyze(\n          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,\n              gcDurationMs, heapDumpDurationMs));\n```\n\n构造器传入的Listener如下\n\n```java\n  public static RefWatcher install(Application application) {\n    return refWatcher(application)\n        .listenerServiceClass(DisplayLeakService.class)//设置Listener\n        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())\n        .buildAndInstall();\n  } \n\n\tpublic AndroidRefWatcherBuilder listenerServiceClass(Class<...> listenerServiceClass) {\n    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));\n  }\n```\n\n所以上面的heapdumpListener就是ServiceHeapDumpListener的实例，看看这类的analyze方法\n\n```java\n  @Override public void analyze(HeapDump heapDump) {\n    checkNotNull(heapDump, \"heapDump\");\n    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);\n  }\n```\n\n实际上就是启动一个IntentService来进行内存分析操作\n\n```java\npublic final class HeapAnalyzerService extends IntentService {\n\n  private static final String LISTENER_CLASS_EXTRA = \"listener_class_extra\";\n  private static final String HEAPDUMP_EXTRA = \"heapdump_extra\";\n\n  public static void runAnalysis(Context context, HeapDump heapDump,\n      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {\n    Intent intent = new Intent(context, HeapAnalyzerService.class);\n    intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());\n    intent.putExtra(HEAPDUMP_EXTRA, heapDump);\n    context.startService(intent);\n  }\n\n  public HeapAnalyzerService() {\n    super(HeapAnalyzerService.class.getSimpleName());\n  }\n\n  @Override protected void onHandleIntent(Intent intent) {\n    if (intent == null) {\n      CanaryLog.d(\"HeapAnalyzerService received a null intent, ignoring.\");\n      return;\n    }\n    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);\n    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);\n\n    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);\n\n    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);\n    AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);\n  }\n}\n```\n\n跟进\n\n```java\npublic AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {\n    long analysisStartNanoTime = System.nanoTime();\n\n    if (!heapDumpFile.exists()) {\n      Exception exception = new IllegalArgumentException(\"File does not exist: \" + heapDumpFile);\n      return failure(exception, since(analysisStartNanoTime));\n    }\n\n    try {\n      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);\n      HprofParser parser = new HprofParser(buffer);\n      Snapshot snapshot = parser.parse();\n      deduplicateGcRoots(snapshot);\n\n      Instance leakingRef = findLeakingReference(referenceKey, snapshot);\n\n      // False alarm, weak reference was cleared in between key check and heap dump.\n      if (leakingRef == null) {\n        return noLeak(since(analysisStartNanoTime));\n      }\n\n      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);\n    } catch (Throwable e) {\n      return failure(e, since(analysisStartNanoTime));\n    }\n  }\n```\n\n上面的checkForLeak方法就是输入.hprof，输出分析结果，主要有以下几个步骤：\n\n1.把.hprof转为Snapshot，这个Snapshot对象就包含了对象引用的所有路径\n\n2.精简gcroots,把重复的路径删除，重新封装成不重复的路径的容器\n\n3.找出泄漏的对象\n\n4.找出泄漏对象的最短路径\n\n\n\n# 参考\n\n[ReferenceQueue的使用](http://www.cnblogs.com/dreamroute/p/5029899.html)\n\n","tags":["性能优化"],"categories":["Android框架"]},{"title":"Java并发编程","url":"/2018/03/03/Java并发编程/","content":"总结Java并发编程中涉及到的一些知识\n\n<!-- more -->  \n\n\n\n# volatile\n\n## 从双重检查锁加volatile引发的思考\n\n一般我写单例模式是这样的\n\n```java\npublic class Singleton {\n    private static Singleton singleton;\n    private Singleton(){}\n    public static Singleton getInstance(){\n        if(singleton == null){\n            synchronized(Singleton.class){\n                if(singleton == null){\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n\n今天发现别人是这样写的\n\n```java\n...\nprivate volatile static Singleton singleton;\n...\n```\n\n这就产生了一个问题，为什么用了`synchronized`之后，还要用`volatile`来修饰singleton呢？\n\n还好知乎在这个问题上有[讨论](https://www.zhihu.com/question/56606703/answer/149721562)\n\n- 防止指令的重排，使得出现先赋值，再初始化的情况，而其他线程在第一次判断`singleton == null`的时候，就直接返回了一个尚未初始化完成的singleton\n- 操作的可见性，让抢到锁的线程1在创建完singleton实例之后，要把singleton从线程1的工作内存更新回主存\n\n\n上面就介绍了volatile的有序性和可见性两种，volatile还有个原子性，**但volatile只能保证对单次读/写的原子性**，原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败。\n\n```java\nx = 10;         //原子操作  将数值10赋值给x\ny = x;         //非原子操作  先读取x的值 然后把值赋给y\nx++;           //非原子操作 先读取x的值 加1 把值赋给x\nx = x + 1;     //同上\n```\n\n```java\npublic class VolatileTest {\n    volatile int i;\n    public void addI(){\n        i++;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final  VolatileTest test = new VolatileTest();\n        for (int n = 0; n <2000; n++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    test.addI();\n                }\n            }).start();\n        }\n\n        Thread.sleep(20000);\n\n        System.out.println(test.i);\n    }\n}\n```\n\n所以上面的代码输出的值不一定为2000，因为`i++`操作不具有原子性\n\n\n\n# synchronized\n\n这个就比volatile牛逼多了，synchronized可以修饰方法、代码块，并且也保证了原子性与可见性。就上面i++的demo中把方法`addI`用synchronized修饰一下保证每次的值都是2000。\n\n两者主要差别\n\nvolatile是告知jvm，这个变量在寄存器中的值是不确定的，当某个线程修改了变量的值后会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时， 发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读。\n\nsynchronized是只允许持有锁的线程对这个变量进行操作，当前线程讲值写回主存之后，其他线程才会去读取(这个应该是这样的。。)，就不会出现先读取值，然后再被其他线程修改，出现不一致的情况了。\n\n\n\n# wait notify notifyAll\n\nObject类的三大方法，这三个方法，都是Java语言提供的**实现线程间阻塞**和**控制进程内调度的底层机制**。\n\n> **wait():**Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.\n>\n> **notify():**Wakes up a single thread that is waiting on this object's monitor.\n>\n> **notifyAll():**Wakes up all threads that are waiting on this object's monitor.\n\n主要有2点要注意：\n\n- 持有所\n- 使用while判断条件成立而不是if\n\n透过一个简单的例子来学习一下这些的使用\n\n```java\n/**\n * Simple Java program to demonstrate How to use wait, notify and notifyAll()\n * method in Java by solving producer consumer problem.\n *\n * @author Javin Paul\n */\npublic class ProducerConsumerInJava {\n    public static void main(String args[]) {\n        Queue buffer = new LinkedList();\n        int maxSize = 5;\n        Thread producer = new Producer(buffer, maxSize, \" PRODUCER \");\n        Thread consumer = new Consumer(buffer, maxSize, \" CONSUMER \");\n        producer.start();\n        consumer.start();\n\n    }\n    /**\n     * Producer Thread will keep producing values for Consumer \n     * to consumer. It will use wait() method when Queue is full \n     * and use notify() method to send notification to Consumer \n     * Thread. \n     *\n     * @author WINDOWS 8 \n     *\n     */\n    static class Producer extends Thread {\n        private Queue queue;\n        private int maxSize;\n\n        public Producer(Queue queue, int maxSize, String name) {\n            super(name);\n            this.queue = queue;\n            this.maxSize = maxSize;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                synchronized (queue) {\n                    while (queue.size() == maxSize) {\n                        try {\n                            System.out.println(\" Queue 满了 \");\n\n                            System.out.println(\"Producer1 要wait了\");\n                            queue.wait();\n                            System.out.println(\"Producer1 wait完了\");\n\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                        }\n                    }\n                    Random random = new Random();\n                    int i = random.nextInt();\n                    System.out.println(\" Producer1 创建值 : \" + i);\n                    queue.add(i);\n                    queue.notifyAll();\n                }\n            }\n        }\n    }\n    /**\n     * Consumer Thread will consumer values form shared queue.\n     * It will also use wait() method to wait if queue is\n     * empty. It will also use notify method to send\n     * notification to producer thread after consuming values\n     * from queue.\n     *\n     * @author WINDOWS 8\n     *\n     */\n    static class Consumer extends Thread {\n        private Queue queue;\n        private int maxSize;\n\n        public Consumer(Queue queue, int maxSize, String name) {\n            super(name);\n            this.queue = queue;\n            this.maxSize = maxSize;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                synchronized (queue) {\n                    while (queue.isEmpty()) {\n                        System.out.println(\" Queue is empty\");\n                        try {\n                            System.out.println(\"Consumer 要wait了\");\n                            queue.wait();\n                            System.out.println(\"Consumer wait完了\");\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                        }\n                    }\n                    System.out.println(\" Consuming value : \" + queue.remove());\n                    queue.notifyAll();\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n# yield、join\n\n[看这里](http://www.cnblogs.com/paddix/p/5381958.html)","tags":["并发编程"],"categories":["Java"]},{"title":"Python验证码识别","url":"/2018/02/27/验证码识别/","content":"\n记一次使用openCV+tesseract对验证码识别过程\n<!-- more -->  \n# 目标介绍\n\n验证码来自某招聘网站企业版[登录入口](https://passport.zhaopin.com/org/login)\n\n大概长这样:![](http://owu391pls.bkt.clouddn.com/yanzhenma.png)\n\n我把上面的图叫做src，下面的图叫做query，要做的就是根据src，找到query中相应的位置\nsrc:![](http://owu391pls.bkt.clouddn.com/src1.png)\n\nquery:![](http://owu391pls.bkt.clouddn.com/query1.png)\n\n\n项目地址[在这](https://github.com/MelonWXD/VerificationMatcher)  \n一些方法的封装：\n\n```python\n# coding=utf-8\nimport os\nimport cv2\nimport numpy as np\nimport pytesseract\n\n\n# 二值化\ndef binary_filter(src, thresh=127, maxval=255):\n    ret1, th1 = cv2.threshold(src, thresh, maxval, cv2.THRESH_BINARY)\n    return th1\n\n\n# 腐蚀\ndef erode_img(src, shape=(5, 5)):\n    kernel = np.ones(shape, np.uint8)\n    return cv2.erode(src, kernel, iterations=1)\n\n\n# 膨胀\ndef dilate_img(src):\n    kernel = np.ones((5, 5), np.uint8)\n    return cv2.dilate(src, kernel, iterations=1)\n\n\n# ocr\ndef img_to_cn(wordImg):\n    return pytesseract.image_to_string(wordImg, lang='my_cn')\n```\n\n\n\n\n\n# 模板匹配\n\n多刷新几次你会发现 src的文字在图片中的位置都是固定的 \n\n那处理起来就很方便了，灰度化之后直接按像素分割\n\n```python\nsrc1 = cv2.imread(resPath + '/src1.png', cv2.COLOR_BGR2BGRA)\nwords = (src1[0:h, 10:32], src1[0:h, 30:53], src1[0:h, 51:73])\n```\n\nquery更简单，灰度化处理一下\n\n```python\nquery_gray = cv2.cvtColor(query, cv2.COLOR_BGR2GRAY)\t\n```\n\n然后就可以开始匹配了\n\n![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=517938955,2498068913&fm=27&gp=0.jpg)\n\n\n\n```python\ndef template_match(src, query):\n    query_gray = cv2.cvtColor(query, cv2.COLOR_BGR2GRAY)\n    colors = ((0, 0, 255), (0, 255, 0), (255, 0, 0))\n    w, h = src.shape[::-1]\n    words = (src[0:h, 10:32], src[0:h, 30:53], src[0:h, 51:73])\n    for i in range(len(words)):\n        template = words[i]\n        w, h = template.shape[::-1]\n        res = cv2.matchTemplate(query_gray, template, cv2.TM_CCOEFF_NORMED)\n        threshold = 0.8\n        loc = np.where(res >= threshold)\n        for pt in zip(*loc[::-1]):\n            cv2.rectangle(query, pt, (pt[0] + w, pt[1] + h), colors[i], 2)\n    cv2.imwrite(resPath + '/result1.png', query)\n```\n\n结果:![](http://owu391pls.bkt.clouddn.com/result1.png)\n\n\n\n\n\n上面写的也太水了吧，没有困难我们就创造困难。。比如人家把字体大小、分辨率给改了，那么模板匹配很可能就不行了\n\n# OCR文字识别\n\n大体思路就是分割src，通过谷歌的tesseract转换成文字，再把query中的文字一个个抓出来识别，因为query中字体位置无规律，一整张放进去也无法识别。\n\nsrc:![](http://owu391pls.bkt.clouddn.com/src2.png)\n\nsrc的处理就不多说了，二值化之后固定分割，甚至可以不处理直接分割，然后再识别即可主要看query的处理。\n\nquery:![](http://owu391pls.bkt.clouddn.com/query2.png)\n\n二值化：\n\n```python\n    gray_query = cv2.cvtColor(query, cv2.COLOR_BGR2GRAY)\n    binary_query = binary_filter(gray_query, thresh=30)\n```\n\n![](http://owu391pls.bkt.clouddn.com/query_binary.png)\n\n由于字体是黑色的，所以我们要通过腐蚀操作处理一下（其实可以先膨胀去除右边的小黑点再腐蚀的），让下面轮廓识别提取坐标更准确一些：\n\n```python\n\terode_query = erode_img(binary_query)\n```\n\n\n\n![](http://owu391pls.bkt.clouddn.com/query_erode.png)\n\n注意到轮廓识别是在黑色背景中，识别白色轮廓，所以要做个颜色翻转，再识别：\n\n```python\n    # 翻转颜色来查找轮廓\n    erode_query = cv2.bitwise_not(erode_query)\n    image, contours, hierarchy = cv2.findContours(erode_query, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n    # 绘制轮廓保存 以便观察\n    query = cv2.drawContours(query, contours, -1, (0, 0, 255), 1)\n    cv2.imwrite(resPath + '/query_contours.png', query)\n```\n\n在原图上把轮廓画出来，如下\n\n![](http://owu391pls.bkt.clouddn.com/query_contours.png)\n\n\n\n然后处理一下轮廓数据，去掉一些轮廓siez明显不符合的，以及把轮廓整成矩形的\n\n```python\ncoorList = []\n    for i in range(0, len(contours), 1):\n        ndarr = contours[i]\n        # 根据轮廓大小过滤\n        if ndarr.size < 30:\n            continue\n        maxX = 0\n        minX = 1000  # h=src.shape[1]\n        maxY = 0\n        minY = 1000  # w=src.shape[0]\n        for j in range(0, ndarr.shape[0], 1):\n            ndarr2 = ndarr[j]\n            ndarr3 = ndarr2[0]\n            if ndarr3[0] > maxX:\n                maxX = ndarr3[0]\n            if ndarr3[0] < minX:\n                minX = ndarr3[0]\n            if ndarr3[1] > maxY:\n                maxY = ndarr3[1]\n            if ndarr3[1] < minY:\n                minY = ndarr3[1]\n        coorList.append((minX, maxX, minY, maxY))\n```\n\n有了每个文字的坐标，就可以抠出这些文字来进行ocr了\n\n```python\n    # 根据形状来切割每个字符 并进行ocr识别\n    for i in range(0, len(coorList), 1):\n        coorTuple = coorList[i]\n        wordImg = binary_query[coorTuple[2]:coorTuple[3], coorTuple[0]:coorTuple[1]]\n        # 保存每个字符 便于观察\n        cv2.imwrite(resPath + '/query_word{idx}.png'.format(idx=i), wordImg)\n        # ocr匹配\n        if img_to_cn(wordImg) == img_to_cn(words[0]):\n            print('第一个点击位置为(%d,%d)', (sum(coorTuple[:2]) / 2), (sum(coorTuple[2:]) / 2))\n        elif img_to_cn(wordImg) == img_to_cn(words[1]):\n            print('第二个点击位置为(%d,%d)', (sum(coorTuple[:2]) / 2), (sum(coorTuple[2:]) / 2))\n        elif img_to_cn(wordImg) == img_to_cn(words[2]):\n            print('第三个点击位置为(%d,%d)', (sum(coorTuple[:2]) / 2), (sum(coorTuple[2:]) / 2))\n```\n\n识别出来的word如下：\n\n![](http://owu391pls.bkt.clouddn.com/query_word0.png)\n![](http://owu391pls.bkt.clouddn.com/query_word1.png)\n![](http://owu391pls.bkt.clouddn.com/query_word2.png)\n![](http://owu391pls.bkt.clouddn.com/query_word3.png)\n![](http://owu391pls.bkt.clouddn.com/query_word4.png)\n![](http://owu391pls.bkt.clouddn.com/query_word5.png)\n![](http://owu391pls.bkt.clouddn.com/query_word6.png)\n\n第一个看来轮廓没处理好，但是也不碍事～\n","tags":["OpenCV","OCR","验证码"],"categories":["Python"]},{"title":"浅析Android进程间通信（四）","url":"/2018/02/23/android-ipc4/","content":"\n从AIDL的角度来看Binder的实现过程，结合[浅析（一）](https://melonwxd.github.io/2017/10/19/android-ipc/)和[Activity启动流程](https://melonwxd.github.io/2018/01/28/Activity%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/)的讲解来分析。\n<!-- more -->\n\n# 分析\n\n```java\npublic interface MusicAIDLService extends android.os.IInterface {\n    \n  public static abstract class Stub extends android.os.Binder implements \t\t\t       \t\t       com.dongua.ipc.service.MusicAIDLService {\n        private static final java.lang.String DESCRIPTOR = \"com.dongua.ipc.service.MusicAIDLService\";\n\n        public Stub() {\n            this.attachInterface(this, DESCRIPTOR);\n        }\n    \n\t\tpublic static com.dongua.ipc.service.MusicAIDLService asInterface(android.os.IBinder obj) {\n            //省略\n        }\n    \n        @Override\n        public android.os.IBinder asBinder() {\n            return this;\n        }\n    \n        @Override\n        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n           switch (code) {\n                case INTERFACE_TRANSACTION: {\n                    reply.writeString(DESCRIPTOR);\n                    return true;\n                }\n                case TRANSACTION_play: {\n                    data.enforceInterface(DESCRIPTOR);\n                    this.play();\n                    reply.writeNoException();\n                    return true;\n                }\n          \t//省略\n           }\n        }\n\n\n        private static class Proxy implements com.dongua.ipc.service.MusicAIDLService {\n            private android.os.IBinder mRemote;\n\n            Proxy(android.os.IBinder remote) {\n                mRemote = remote;\n            }\n\n            @Override\n            public android.os.IBinder asBinder() {\n                return mRemote;\n            }\n\n            @Override\n            public void play() throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    mRemote.transact(Stub.TRANSACTION_play, _data, _reply, 0);\n                    _reply.readException();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n            }\n        }\n\n        static final int TRANSACTION_play = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n        static final int TRANSACTION_pause = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);\n        static final int TRANSACTION_stop = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);\n        static final int TRANSACTION_prev = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);\n        static final int TRANSACTION_next = (android.os.IBinder.FIRST_CALL_TRANSACTION + 4);\n        static final int TRANSACTION_getCurrentTrack = (android.os.IBinder.FIRST_CALL_TRANSACTION + 5);\n    }\n\n    public void play() throws android.os.RemoteException;\n\n    public void pause() throws android.os.RemoteException;\n\n    public void stop() throws android.os.RemoteException;\n\n    public void prev() throws android.os.RemoteException;\n\n    public void next() throws android.os.RemoteException;\n\n    public com.dongua.ipc.service.MusicTrack getCurrentTrack() throws android.os.RemoteException;\n}\n```\n\n省略了内部类Stub和Proxy的很多实现，先来梳理一下大致的逻辑框架。\n\n- 接口MusicAIDLService，定义了我们在aidl中声明的远程服务方法（play、pause..），并且继承自IInterface\n- Stub类继承自Binder，实现上面的MusicAIDLService接口，重写了传输方法onTransact\n- Proxy类实现了MusicAIDLService接口，持有IBinder实例mRemote，重写了MusicAIDLService中定义的远程服务方法（play、pause..）\n\n那么我们是怎么使用这些来完成一次跨进程的通信呢\n\n```java\n\tprivate MusicAIDLService mMusicServiceProxy ;\n    private ServiceConnection mConnection = new ServiceConnection(){\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            mMusicServiceProxy = (MusicAIDLService) MusicAIDLService.Stub.asInterface(service);\n            try {\n                mMusicServiceProxy.play();\n                mMusicServiceProxy.pause();\n                mMusicServiceProxy.stop();\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n\n        }\n    };\n```\n\n在onServiceConnected时，通过Stub.asInterface，其实返回的是上述的Proxy类实例，我们通过这个`mMusicServiceProxy`的方法，来调用到远程的服务，如` mMusicServiceProxy.play();`\n\n```java\n\t\t\t@Override\n            public void play() throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    mRemote.transact(Stub.TRANSACTION_play, _data, _reply, 0);\n                    _reply.readException();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n            }\n```\n\n通过mRemote.transact来传输_data。此时的mRemote就是上面` MusicAIDLService.Stub.asInterface(service)`的service，也就是onServiceConnected方法的第二个参数，即我们通过intent绑定的Service（运行在另一个进程的）的onBind方法的返回值。\n\n由此引入第四个角色，真正的远程服务实现类`mServiceBinder`。\n\n```java\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.i(TAG, \"onBind: \");\n        return mServiceBinder;\n    }\n\n\tprivate Binder mServiceBinder = new MusicAIDLService.Stub() {\n        @Override\n        public void play() throws RemoteException {\n            Log.i(TAG, \"play: \");\n        }\n\n        @Override\n        public void pause() throws RemoteException {\n            Log.i(TAG, \"pause: \");\n\n        }\n\n        @Override\n        public void stop() throws RemoteException {\n            Log.i(TAG, \"stop: \");\n        }\n\n        @Override\n        public void prev() throws RemoteException {\n            Log.i(TAG, \"prev: \");\n        }\n\n        @Override\n        public void next() throws RemoteException {\n            Log.i(TAG, \"next: \");\n        }\n\n        @Override\n        public MusicTrack getCurrentTrack() throws RemoteException {\n            Log.i(TAG, \"getCurrentTrack: \");\n            return null;\n        }\n    };\n\n```\n\nOK，流程就这样。我把上面总结的重新贴一下：\n\n- MusicAIDLService 接口，定义了我们在aidl中声明的远程服务方法（play、pause等），并且继承自IInterface\n- Stub 抽象类，继承自Binder，实现上面的MusicAIDLService接口但没有重写远程服务方法，重写了传输方法`onTransact`，在跨进程时`asInterface`方法返回内部类`Stub.Proxy(obj)`实例\n- Proxy 实现了MusicAIDLService接口，持有IBinder实例mRemote，重写了MusicAIDLService中定义的远程服务方法（play、pause等），在其中调用`mRemote.transact()`来进行数据传输\n- mServiceBinder 真正的远程音乐服务，业务逻辑实现。继承了Stub，重写了远程服务方法（play、pause等）。\n\n\n\n再回过头分析一下ActivityManagerService、ActivityManagerNative、IActivityManager、ActivityManagerProxy四个兄弟。\n\n- IActivityManager 接口，定义了Activity远程服务的方法（startActivity等），并且继承自IInterface\n- ActivityManagerNative 抽象类，继承自Binder，实现上面的IActivityManager接口但没有重写远程服务方法，重写了传输方法`onTransact`，`asInterface`返回`ActivityManagerProxy(obj)`实例\n- ActivityManagerProxy 实现了IActivityManager接口，持有IBinder实例mRemote，重写了IActivityManager中定义的远程服务方法（startActivity等），在其中调用`mRemote.transact()`来进行数据传输\n- ActivityManagerService 真正的远程Activity管理服务类，继承了ActivityManagerNative，重写了远程服务的方法（startActivity等）\n\n\n\n关系很明了，无需多言了！\n\n","tags":["IPC"],"categories":["Android"]},{"title":"Retrofit与OkHttp学习","url":"/2018/02/22/Okhttp和Retrofit/","content":"Android网络请求框架okHttp源码分析\n<!-- more -->  \n\n# OkHttp\n\n偷贴一张[Piasy](https://xiaozhuanlan.com/u/1338552356)的图\n\n![](https://blog.piasy.com/img/201607/okhttp_full_process.png)\n\n\n\n## 基本用法\n\n```java\n        OkHttpClient client=new OkHttpClient.Builder().build();\n        Request request = new Request.Builder().url(\"xxx.com\").build();\n\n        //同步\n        Response syncRep = client.newCall(request).execute();\n        //异步\n        client.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n\n            }\n        });\n```\n\n## 同步请求\n\n先从同步请求入手，`newCall`返回的是RealCall实例，RealCall的execute\n\n```java\n   @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n  }\n```\n\n主要还是调用了`getResponseWithInterceptorChain`，最后在通知dispatcher结束。其他的都是取消、错误异常处理\n\n```java\n  Response getResponseWithInterceptorChain() throws IOException {\n    // Build a full stack of interceptors.\n    List<Interceptor> interceptors = new ArrayList<>();\n    interceptors.addAll(client.interceptors());\n    interceptors.add(retryAndFollowUpInterceptor);\n    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n    interceptors.add(new CacheInterceptor(client.internalCache()));\n    interceptors.add(new ConnectInterceptor(client));\n    if (!forWebSocket) {\n      interceptors.addAll(client.networkInterceptors());\n    }\n    interceptors.add(new CallServerInterceptor(forWebSocket));\n\n    Interceptor.Chain chain = new RealInterceptorChain(\n        interceptors, null, null, null, 0, originalRequest);\n    return chain.proceed(originalRequest);\n  }\n```\n\n为请求添加拦截器（下面会讲），先添加自定义的拦截器，然后添加一堆默认的桥接、缓存等拦截器，最后添加的是**CallServerInterceptor**，划重点，要考的\n\n最后调用RealInterceptorChain实例的proceed\n\n```java\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n\n    calls++;\n\n    // Call the next interceptor in the chain.\n    RealInterceptorChain next = new RealInterceptorChain(\n        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    return response;\n  }\n```\n\n第一次传进来的index为0，后面每次都是index+1，就是依次按上面interceptors的添加顺序，把拦截器取出来，调用intercept的方法。在拦截器内部又调用proceed，一直到最后来调用到上面说的最后添加的**CallServerInterceptor**这个拦截器来进行真正的网络操作。\n\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    HttpCodec httpCodec = realChain.httpStream();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n    RealConnection connection = (RealConnection) realChain.connection();\n    Request request = realChain.request();\n\n    long sentRequestMillis = System.currentTimeMillis();\n    httpCodec.writeRequestHeaders(request);\n\n    Response.Builder responseBuilder = null;\n  //对Request的请求头\"Expect: 100-continue\"做个处理\n  if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n        httpCodec.flushRequest();\n        responseBuilder = httpCodec.readResponseHeaders(true);\n      }\n\n      if (responseBuilder == null) {\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());\n        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n        request.body().writeTo(bufferedRequestBody);\n        bufferedRequestBody.close();\n      } else if (!connection.isMultiplexed()) {\n        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection from\n        // being reused. Otherwise we're still obligated to transmit the request body to leave the\n        // connection in a consistent state.\n        streamAllocation.noNewStreams();\n      }\n    }\n\n    httpCodec.finishRequest();\n\n    if (responseBuilder == null) {\n      responseBuilder = httpCodec.readResponseHeaders(false);\n    }\n\n    Response response = responseBuilder\n        .request(request)\n        .handshake(streamAllocation.connection().handshake())\n        .sentRequestAtMillis(sentRequestMillis)\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build();\n\n    int code = response.code();\n    if (forWebSocket && code == 101) {\n      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n      response = response.newBuilder()\n          .body(Util.EMPTY_RESPONSE)\n          .build();\n    } else {\n      response = response.newBuilder()\n          .body(httpCodec.openResponseBody(response))\n          .build();\n    }\n\n\n    return response;\n  }\n```\n\n实际上使用的是HttpCodec类来进行socket操作，基于Okio封装了BufferSink和BufferSource。\n\n## 拦截器\n\n```java\npublic interface Interceptor {\n  Response intercept(Chain chain) throws IOException;\n\n  interface Chain {\n    Request request();\n\n    Response proceed(Request request) throws IOException;\n\n    /**\n     * Returns the connection the request will be executed on. This is only available in the chains\n     * of network interceptors; for application interceptors this is always null.\n     */\n    @Nullable Connection connection();\n  }\n}\n```\n\nIntercept只有一个内部类Chain，一个`intercept`方法，参数为Chain的实例。\n\n通过这个`chain.request`和`chain.proceed`来分别对Request和Response做额外的处理。\n\n下面是一个自定义的拦截器，输出请求/响应的日志\n\n```java\nclass LoggingInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request request = chain.request();\n    \n    long t1 = System.nanoTime();\n    logger.info(String.format(\"Sending request %s on %s%n%s\",\n        request.url(), chain.connection(), request.headers()));\n\n    Response response = chain.proceed(request);\n\n    long t2 = System.nanoTime();\n    logger.info(String.format(\"Received response for %s in %.1fms%n%s\",\n        response.request().url(), (t2 - t1) / 1e6d, response.headers()));\n\n    return response;\n  }\n}\n```\n\n## 异步请求\n\n下面再来看看异步请求，重新贴一下代码\n\n```java\n        client.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n\n            }\n        });\n```\n\nRealCall的`enqueue`\n\n```java\n  @Override public void enqueue(Callback responseCallback) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n\n```\n\n主要是使用AsyncCall包装一下回调请求，然后通过client.dispatcher()的`enquue`来执行\n\n```java\nsynchronized void enqueue(AsyncCall call) {\n  if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n    runningAsyncCalls.add(call);\n    executorService().execute(call);\n  } else {\n    readyAsyncCalls.add(call);\n  }\n}\n\n```\n\n如果没有超过最大请求数，就使用executorService()返回的线程池实例执行call，否则添加到等待的readyAsyncCalls中。\n\n再来介绍一下AsyncCall，是RealCall的一个内部类，继承自NamedRunnable，NamedRunnable实现Runnable。NamedRunnable在重写`run`方法的时执行了一个抽象方法`execute`，由AsyncCall来实现。所以当线程执行异步请求的时候实际上走的就是AsyncCall的`execute`方法。\n\n```java\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n\t\t\t...\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n```\n\n跟RealCall的execute很像啊，`getResponseWithInterceptorChain`来执行。基本可以说明异步的请求跟同步的区别就是加了个线程池来实现网络请求，并通过callback回调。\n\n\n\n# Retrofit\n\n再来分析一下Retrofit是如何对OkHttp进行封装的\n\n## 基本用法\n\n**这块暂时不看，看下一个**\n\n```java\n    public static RetrofitClient getInstance() {\n        if (mInstance == null) {\n            synchronized (RetrofitClient.class) {\n                if (mInstance == null) {\n                    mInstance = new RetrofitClient();\n                }\n            }\n        }\n        return mInstance;\n    }\n    private RetrofitClient() {\n        mHttpClient = new OkHttpClient.Builder()\n                .addInterceptor(new LoggingInterceptor())\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .build();\n        mRetrofit = new Retrofit.Builder()\n                .baseUrl(BASE_URL)\n                .addConverterFactory(CustomConverterFactory.create())\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .client(mHttpClient)\n                .build();\n    \n        mApi = mRetrofit.create(ApiService.class);\n    }\n```\n\n\n**↓↓看这个↓↓**\n\n```java\npublic interface BlogService {\n    @GET(\"blog/{id}\")\n    Call<ResponseBody> getBlog(@Path(\"id\") int id);\n}\n\n\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"http://localhost:4567/\")\n    .build();\nBlogService service = retrofit.create(BlogService.class);\nCall<ResponseBody> call = service.getBlog(2);\ncall.enqueue(new Callback<ResponseBody>() {\n  @Override\n  public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {\n\n  }\n\n  @Override\n  public void onFailure(Call<ResponseBody> call, Throwable t) {\n\n  }\n});\n```\n## create\n\n```java\n  public <T> T create(final Class<T> service) {\n    return (T) Proxy.newProxyInstance(\n          service.getClassLoader()\n          , new Class<?>[] { service }\n          , new InvocationHandler() {\n              @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n                  throws Throwable {\n    \t\t\t\t...\n              }\n        });\n  }\n```\n\n通过动态代理技术直接返回代理类实例\n\n**动态代理**\n\n通过jdk在内存中动态生成一个代理对象，涉及Proxy类的静态方法`newProxyInstance`和`InvocationHandler`接口。\n\n下面大体讲一下使用，直接手打可能有点错误，意思到了就行了。。。\n\n```java\n//接口\ninterface UserDao{\n  String getName();\n  int getAge();\n}\n//委托类\nclass UserDaoImp{\n  String getName(){\n    return \"lewis\";\n  }\n  int getAge(){\n    return 22;\n  }\n}\n//动态代理类\npublic class MyInvocationHandler implements InvocationHandler {  \n    private Object target;  \n    MyInvocationHandler(Object target) {  \n        super();  \n        this.target = target;  //在这里获取到委托类的实例\n    }  \n     \n    @Override  \n    public Object invoke(Object o, Method method, Object[] args) throws Throwable {  \n            System.out.println(\"当前invoke的方法为：\" + method.getName() );  \n            return method.invoke(target, args); \n    }  \n}\n//使用\npublic static void main(String[] args) {  \n \t//实例化委托类传入代理类\n  \tUserDao userImp = new UserDaoImp();\n  \tUserDao userProxy = (UserDao)Proxy.newProxyInstance(\n      \t\t\tuserImp.getClass().getClassLoader()\n      \t\t\t,userImp.getClass().getInterfaces()\n      \t\t\t,new MyInvocationHandler(userImp)\n      \t\t\t);       \n   System.out.println(userProxy.getName()); \n}  \n//输出\n当前invoke的方法为：getName\nlewis\n```\n\n再回到create中InvocationHandler的invoke方法的代码\n\n```java\n @Override \n public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable {\n    ServiceMethod<Object, Object> serviceMethod = (ServiceMethod<Object, Object>) loadServiceMethod(method);\n    OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n    return serviceMethod.callAdapter.adapt(okHttpCall);      \n}\n        \n```\n\n## loadServiceMethod\n\n```java\n  ServiceMethod<?, ?> loadServiceMethod(Method method) {\n    ServiceMethod<?, ?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        result = new ServiceMethod.Builder<>(this, method).build();\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n```\n\n先从缓存中查找，如果没有就通过`new ServiceMethod.Builder<>(this, method).build()`新建一个\n\n```JAVA\npublic ServiceMethod build() {\n      callAdapter = createCallAdapter();\n\n      responseConverter = createResponseConverter();\n\n      for (Annotation annotation : methodAnnotations) {\n        parseMethodAnnotation(annotation);\n      }\n\n      return new ServiceMethod<>(this);\n    }\n```\n\n主要逻辑如上\n\n- `createCallAdapter`是根据委托类方法的返回值，来确定要使用的CallAdapter，比如我们的返回值是`Observable`，那么就会使用`RxJava2CallAdapterFactory`，如果我们在创建Retrofit实例的时候没有通过`addCallAdapterFactory(RxJava2CallAdapterFactory.create())`来添加与返回值相应的处理函数，那么这里就会抛出异常。\n- `createResponseConverter`也是同样的道理，比如我们使用`addConverterFactory`添加`GsonConverterFactory`\n- `parseMethodAnnotation`解析每个方法的注解GET、POST、PUT等等\n\n## new OkHttpCall()\n\n```java\nfinal class OkHttpCall<T> implements Call<T> {\n  private final ServiceMethod<T, ?> serviceMethod;\n  private final @Nullable Object[] args;\n  @GuardedBy(\"this\")\n  private @Nullable okhttp3.Call rawCall;\n  \n  OkHttpCall(ServiceMethod<T, ?> serviceMethod, @Nullable Object[] args) {\n    this.serviceMethod = serviceMethod;\n    this.args = args;\n  }\n  \n  \n    private okhttp3.Call createRawCall() throws IOException {\n    Request request = serviceMethod.toRequest(args);\n    okhttp3.Call call = serviceMethod.callFactory.newCall(request);\n    if (call == null) {\n      throw new NullPointerException(\"Call.Factory returned null.\");\n    }\n    return call;\n  }\n}\n```\n\n对内部okhttp3.Call类型的`rawCall`进行封装，默认使用的是OkHttpClient的实例。\n\n```java\nserviceMethod.callFactory = = builder.retrofit.callFactory(); //serviceMethod.java\n okhttp3.Call.Factory callFactory = this.callFactory; // Retrofit.Builder\n      if (callFactory == null) {\n        callFactory = new OkHttpClient();\n      }\n\n```\n\n### parseResponse\n\nOkHttpCall内部对返回值做了处理，通过responseConverter\n\n```java\nT body = serviceMethod.toResponse(catchingBody);\n  R toResponse(ResponseBody body) throws IOException {\n    return responseConverter.convert(body);\n  }\n```\n\n## callAdapter.adapt\n\n再关注动态代理方法`invoke`的返回值\n\n```java\nreturn serviceMethod.callAdapter.adapt(okHttpCall);\n```\n\n调用serviceMethod的成员变量callAdapter.adapt来适配委托类的方法返回值。\n\n在loadServiceMethod中创建ServiceMethod时，`callAdapter = createCallAdapter()`，跟进\n\n```java\n   private CallAdapter<T, R> createCallAdapter() {\n      try {\n        //noinspection unchecked\n        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);\n      } catch (RuntimeException e) { // Wide exception range because factories are user code.\n        throw methodError(e, \"Unable to create call adapter for %s\", returnType);\n      }\n    }\n```\n```java\npublic CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {\n    return nextCallAdapter(null, returnType, annotations);\n}\n\nfinal List<CallAdapter.Factory> adapterFactories;\n\npublic CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,\n      Annotation[] annotations) {\n \n    int start = adapterFactories.indexOf(skipPast) + 1;\n    for (int i = start, count = adapterFactories.size(); i < count; i++) {\n      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);\n      if (adapter != null) {\n        return adapter;\n      }\n    }\n  }\n\n```\n\n通过`adapterFactories.get(i).get(returnType, annotations, this);`可以知道是遍历retrofit的adapterFactories，并调用每个item的`get`方法来获取与返回值对应的Adapter\n\n### adapterFactories\n\n这个adapterFactories是在构造Retrofit时由Builder默认添加了一个\n\n```java\n   public Retrofit build() {\n     ...\n      // Make a defensive copy of the adapters and add the default Call adapter.\n      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);\n      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));\n\t...\n  }\n```\n\n以默认的`DefaultCallAdapterFactory`为例，看看他的get方法\n\n```java\nfinal class DefaultCallAdapterFactory extends CallAdapter.Factory {\n  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();\n\n  @Override\n  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n    if (getRawType(returnType) != Call.class) {\n      return null;\n    }\n\n    final Type responseType = Utils.getCallResponseType(returnType);\n    return new CallAdapter<Object, Call<?>>() {\n      @Override public Type responseType() {\n        return responseType;\n      }\n\n      @Override public Call<Object> adapt(Call<Object> call) {\n        return call;\n      }\n    };\n  }\n}\n```\n\n返回的`new CallAdapter`对传入的OkHttpCall毫无包装，直接返回Call，毕竟是默认的。\n\n我们再以常用的`RxJava2CallAdapterFactory`为例，看RxJava2CallAdapterFactory的get方法。\n\n```java\n @Override\n  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n    Class<?> rawType = getRawType(returnType);\n\n    if (rawType == Completable.class) {\n      // Completable is not parameterized (which is what the rest of this method deals with) so it\n      // can only be created with a single configuration.\n      return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,\n          false, true);\n    }\n\n    return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,\n        isSingle, isMaybe, false);\n  }\n```\n\n返回的是RxJava2CallAdapter的实例，在看看RxJava2CallAdapter的adapt方法。\n\n```java\n @Override public Object adapt(Call<R> call) {\n    Observable<Response<R>> responseObservable = isAsync\n        ? new CallEnqueueObservable<>(call)\n        : new CallExecuteObservable<>(call);\n\n    Observable<?> observable;\n    if (isResult) {\n      observable = new ResultObservable<>(responseObservable);\n    } else if (isBody) {\n      observable = new BodyObservable<>(responseObservable);\n    } else {\n      observable = responseObservable;\n    }\n\t...\n    return observable;\n  }\n```\n\n根据各种条件做了一些判断，对Call进行封装，具体见源码。\n\n\n\n再上一张图来帮助理解create的这个三部曲。\n\n![](https://blog.piasy.com/img/201606/retrofit_stay.png)\n","tags":["网络编程"],"categories":["Android框架"]},{"title":"深入四大组件-Activity启动分析","url":"/2018/01/28/Activity启动分析/","content":"\n通过6.0源码学习Activity启动的整体流程\n<!-- more -->\n\n多嘴一句  本文件创建于`2017-12-01 10:04:40 `\n\n完成于`2018-01-28 19:11:46`\n\n哭了\n\n\n\n# 相关知识\n\n在学习整体流程之前先介绍几个和Activity关系比较密切的类。\n\n## SystemServer\n\n之前分析的zygote进程的启动流程，最后是启动了`app_process`这个进程，那么启动之后是怎么样的呢，贴张老罗的图：\n\n![](http://hi.csdn.net/attachment/201109/16/0_1316190384ZuU0.gif)\n\n具体源码流程就略过，最后是启动了[SystemServer](http://androidxref.com/6.0.0_r1/xref/frameworks/base/services/java/com/android/server/SystemServer.java)这个进程，`main`方法如下：\n\n```java\n167    public static void main(String[] args) {\n168        new SystemServer().run();\n169    }\n\n176    private void run() {\n\n246        // Prepare the main looper thread (this thread).\n247        android.os.Process.setThreadPriority(\n248                android.os.Process.THREAD_PRIORITY_FOREGROUND);\n249        android.os.Process.setCanSelfBackground(false);\n250        Looper.prepareMainLooper();\n\n258\n259        // Initialize the system context.\n260        createSystemContext();\n261\n262        // Create the system service manager.\n263        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n264        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);\n  \n266        // Start services.\n267        try {\n268            startBootstrapServices();\n269            startCoreServices();\n270            startOtherServices();\n271        } catch (Throwable ex) {\n274            throw ex;\n275        }\n\n282        // Loop forever.\n283        Looper.loop();\n285    }\n```\n\n- startBootstrapServices() 启动一些重量级服务 如AMS\n- startCoreServices() 启动一些核心服务 如电池管理\n- startOtherServices() 启动一些有的没的杂七杂八服务\n\n在`startOtherServices`中，最后会调用\n\n```java\n1096        mActivityManagerService.systemReady(new Runnable() {...}\n```\n\n在AMS中又调用`startHomeActivityLocked`来启动Launcher组件（桌面）\n\n```java\n11719    public void systemReady(final Runnable goingCallback) {\n  ...\n11876            // Start up initial activity.\n11877            mBooting = true;\n11878            startHomeActivityLocked(mCurrentUserId, \"systemReady\");\n  ...\n}\n```\n\n至于`startHomeActivityLocked`怎么搞的，相信看完这篇文章心里大概就有数了。\n\n## ActivityManagerService(AMS)\n\n上面废话说了一堆，还是没说AMS是啥，直译就是Activity管理服务，实际上也是起到这么一个功能。\n\n**划重点了，要考的**\n\n在Android的跨进程通信中，都有这么一个命名套路。有兴趣的可以看看源码，很容易理清楚。\n\n- xxxNative：一般为抽象类，如[ActivityManagerNative](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/app/ActivityManagerNative.java#61)，继承自IActivityManager。实现了一些Binder服务端的一些方法，类似于base的功能吧。\n- xxxService：如[ActivityManagerService](http://androidxref.com/6.0.1_r10/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java)，继承自ActivityManagerNative。实现了IActivityManager中声明的所有这个Binder远程服务提供的方法，是远程服务实现类。一些默认实现也会写在AMNative中。\n- xxxProxy：如ActivityManagerProxy，为AMNative内部类，通常是外部xxxNative的`getDefault`方法返回值。这个就是AIDL中对应的Proxy类，是远程服务在本地进程的代理，在本地进程我们都是通过xxxNative.getDefault，然后执行某些特定的方法来调用到远程的服务。\n\n这个AMS、AMN、AMP在下面的分析经常会见到，同理ApplicationThreadNative、ApplicationThread(没有Service。。)和ApplicationThreadProxy。\n\n**可以参考[从ActivityManagerNative看Android系统AIDL的实现](https://www.jianshu.com/p/18517a4ef8e1)**\n\n\n\n\n\n\n\n## ActivityThread\n\nActivityThread代表了一个安卓应用的进程。\n\nAndroid应用的入口是Application的`onCreate`吗？no！是ActivityThread的`main`，这么一回答，B格是不是就上去了。\n\n\n再看一下ActivityThread这个类的几个相关的成员变量：\n\n```java\nfinal ApplicationThread mAppThread = new ApplicationThread();\nInstrumentation mInstrumentation;//在attach中实例化 line5276\nfinal ArrayMap<IBinder, ActivityClientRecord> mActivities = new ArrayMap<>();//保存了当前App进程所有的Activity，封装成ActivityClientRecord再保存到ArrayMap中\nfinal H mH = new H(); //这个H继承自Handler 定义了许多命令 详见line1227\n1227    private class H extends Handler {...}\n```\n\n主要关注一下ApplicationThread，后续流程AMS会通过ApplicationThreadProxy，来调用ApplicationThread的服务，从而调用到ApplicationThread外部类，ActivityThread的相关方法来达到控制Activity生命周期的功能。\n\n**ApplicationThread**\n\n```java\n574    private class ApplicationThread extends ApplicationThreadNative {...}\n\n//http://androidxref.com/6.0.0_r1/xref/frameworks/base/core/java/android/app/ApplicationThreadNative.java\npublic abstract class ApplicationThreadNative extends Binder\n\t       implements IApplicationThread {...}\n```\n\n\n\n\n\n## ActivityStack和ActivityStackSupervisor：\n\n每一个ActivityRecord都会有一个Activity与之对应，一个Activity可能会有多个ActivityRecord，因为Activity可以被多次实例化，取决于其launchmode。一系列相关的ActivityRecord组成了一个TaskRecord，TaskRecord是存在于ActivityStack中，ActivityStackSupervisor是用来管理这些ActivityStack的。\n\nActivityStack和ActivityRecord的关系如下：\n![](http://img.blog.csdn.net/20161220142454652?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2ViZWx6YzI0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n**先说个关于ProcessRecord的知识：**\n\n 在AMS中每个ProcessRecord代表一个应用程序进程，AMS的成员ActivityStackSupervisor(ASS)在`startActivityMayWait`中通过caller（IApplicationThread）这个参数，向他的成员mService（指向AMS）调用`getRecordForAppLocked`来获取caller对应的ProcessRecord，包含了对应进程的信息pid、uid等。\n\n ActivityRecord  TaskRecord  ProcessRecord三者关系图\n\n![](http://img.blog.csdn.net/20170519150259246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXdxMzg0ODA3Njgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n\n\n\n# Launcher启动Activity过程概述\n\n## Launcher——Activity——Instrumentation——AMP\n\nLauncher逐级调用到Instrumentation，利用`ActivityManagerNative.getDefault()`得到ActivityManagerProxy（AMS的Binder代理）并调用其`startActivity`方法。\n\n## AMP——AMS——ActivityStack\n\nAMP通过Binder来与AMS通信，调用AMS的成员ActivityStackSupervisor(ActivityStackSupervisor内部持有一个ActivityStack)\n\n\n\n在ActivityStack中有TaskRecord和ActivityRecord来记录已经启动的Activity的信息\n\n```java\n154    /**\n155     * The back history of all previous (and possibly still\n156     * running) activities.  It contains #TaskRecord objects.\n157     */\n158    private ArrayList<TaskRecord> mTaskHistory = new ArrayList<>();\n```\n\n\n\n\n\nAMS调用ActivityStack来执行启动Activity操作，先使用`PackageManagerService`去解析启动参数Intent中各种信息(判断启动flag啊，获取caller的ProcessRecord进程信息，是否需要新建一个ProcessRecord等等)。之后再根据Intent的信息(newTask)来判断是否要把即将启动的Activity放到上述的ActivityStack成员mTaskHistory的顶部。后续检查一些是否mResumeActivity就是要启动，是否有结束Activity动作发生，关机等等等。都OK的话才会通知当前的Activity-mResumeActivity（如果从桌面启动的话就是Launcher组件）来进入onPaused流程。\n\n\n\n## ApplicationThreadProxy——ApplicationThread——ActivityThread\n\n接上面的，mResumeActivity的onPaused流程是怎么通知的呢。这样就要说到上述的ActivityRecord的成员app(ProcessRecord)的又一个成员变量thread(ApplicationThreadProxy)，看这个类型就知道是干嘛的，Binder。\n\n插入介绍一下AppTP、AppTN、AppT吧。\n\nApplicationThread是[ActivityThread](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/app/ActivityThread.java)的内部类，继承自AppTN，其实就跟AMS继承AMN以及AMP代理的关系一样。\n\n```java\n   private class ApplicationThread extends ApplicationThreadNative {...}\n```\n\n好，继续。AppTP通过Binder通知ApplicationThread处理onPaused，会调用ApplicationThread的外部类ActivityThread的Handler-Message机制来通知ActivityThread，在ActivityThread的处理消息的函数中。\n\n先是让当前的Activity进入onPause\n\n```java\n  performPauseActivity(token, finished, r.isPreHoneycomb());\n```\n\n又通过这么一行代码来通知AMS说我已经让它pause了\n\n```java\nActivityManagerNative.getDefault().activityPaused(token);//ActivityManagerNative.getDefault()=ActivityManagerProxy 详细见下面代码分析\n```\n\n艾玛，太高兴了，又回到了ActivityManagerProxy。\n\n## AMP——AMS——ActivityStack\n\n通知Stack要进入onPause的mResumeActivity已经被暂停了\n\n## ActivityStack——AMS——ActivityThread\n\nmResumeActivity执行完之后，再来启动栈顶Activity。在ActivityStack中检查，PID、UID啥的，是否该Activity所属的进程已经启动了，如果启动了，就通知那个进程来启动Activity，如果没有就以PID和UID新建一个进程，再通知这个新进程启动Activity。\n\n下面假设需要新建ProcessRecord，新建完肯定要保存相应的ProcessRecord到AMS。然后执行ActivityThread的main方法。\n\n**ApplicationThread的main方法就是一个App的入口方法**\n\n## ActivityThread——AMP——AMS——ActivityStack\n\nActivityThread的main中调用attach，其中通过AMP执行attachApplication，调用到AMS的attachApplication，然后又进入Stack一顿瞎比操作。\n\n跟上面暂停的流程很像，ApplicationThreadProxy通过Binder远程调用ApplicationThread，Handler-Message调用外部类ActivityThread实际函数`performLaunchActivity`，在调用`mInstrumention.callActivityOnCreate`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Activity的启动\n\n**以下是无脑跟源码过程，可略！**\n\n从Activity的startActivity方法开始一步步跟进，走读Activity的启动流程，子标题为相关类的递进\n\n## Activity->Instrumentation->ActivityManagerProxy\n\n\n\n一步步跟进[Activity](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/app/Activity.java#3927)的`startActivity`方法，最后都是调用的`startActivityForResult`\n\n```java\n3927    public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {\n3928        if (mParent == null) {\n3929            Instrumentation.ActivityResult ar =\n3930                mInstrumentation.execStartActivity(\n3931                    this, mMainThread.getApplicationThread(), mToken, this,\n3932                    intent, requestCode, options);\n3933            if (ar != null) {\n3934                mMainThread.sendActivityResult(\n3935                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n3936                    ar.getResultData());\n3937            }\n3938            if (requestCode >= 0) {\n3939                // If this start is requesting a result, we can avoid making\n3940                // the activity visible until the result is received.  Setting\n3941                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the\n3942                // activity hidden during this time, to avoid flickering.\n3943                // This can only be done when a result is requested because\n3944                // that guarantees we will get information back when the\n3945                // activity is finished, no matter what happens to it.\n3946                mStartedActivity = true;\n3947            }\n3948\n3949            cancelInputsAndStartExitTransition(options);\n3950            // TODO Consider clearing/flushing other event sources and events for child windows.\n3951        } else {\n3952            if (options != null) {\n3953                mParent.startActivityFromChild(this, intent, requestCode, options);\n3954            } else {\n3955                // Note we want to go through this method for compatibility with\n3956                // existing applications that may have overridden it.\n3957                mParent.startActivityFromChild(this, intent, requestCode);\n3958            }\n3959        }\n3960    }\n```\n\n实际上是调用的`mInstrumentation.execStartActivity`，跟进\n\n```java\n1604    public ActivityResult execStartActivity(\n1605        Context who, IBinder contextThread, IBinder token, String target,\n1606        Intent intent, int requestCode, Bundle options) {\n1607        IApplicationThread whoThread = (IApplicationThread) contextThread;\n1608        if (mActivityMonitors != null) {\n1609            synchronized (mSync) {\n1610                final int N = mActivityMonitors.size();\n1611                for (int i=0; i<N; i++) {\n \t\t\t\t\t\t...//查找Activity是否已经存在\n1620                }\n1621            }\n1622        }\n1623        try {\n1624            intent.migrateExtraStreamToClipData();\n1625            intent.prepareToLeaveProcess();\n1626            int result = ActivityManagerNative.getDefault()\n1627                .startActivity(whoThread, who.getBasePackageName(), intent,\n1628                        intent.resolveTypeIfNeeded(who.getContentResolver()),\n1629                        token, target, requestCode, 0, null, options);\n1630            checkStartActivityResult(result, intent);\n1631        } catch (RemoteException e) {\n1632            throw new RuntimeException(\"Failure from system\", e);\n1633        }\n1634        return null;\n1635    }\n\n```\n\n**注意这里的`whoThread`参数，IApplicationThread的实例，在后续会说明**\n\n实际上是在`try`块中调用`ActivityManagerNative.getDefault().startActivity`，那么`ActivityManagerNative.getDefault()`是啥捏，去[ActivityManagerNative(AMN)](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/app/ActivityManagerNative.java)里头看看\n\n```java\n2604    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n2605        protected IActivityManager create() {\n2606            IBinder b = ServiceManager.getService(\"activity\");\n2607            if (false) {\n2608                Log.v(\"ActivityManager\", \"default service binder = \" + b);\n2609            }\n2610            IActivityManager am = asInterface(b);\n2611            if (false) {\n2612                Log.v(\"ActivityManager\", \"default service = \" + am);\n2613            }\n2614            return am;\n2615        }\n2616    };\n```\n\n就是一个单例的[IActivityManager](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/app/IActivityManager.java#66) IActivityManager是一个继承IInterface的接口，可以基本确定是负责Binder通信的了，内部的方法都和Activity的生命周期相关。\n\n```java\n public interface IActivityManager extends IInterface {\n   ...\n     93    public boolean startNextMatchingActivity(IBinder callingActivity,\n94            Intent intent, Bundle options) throws RemoteException;\n95    public int startActivityFromRecents(int taskId, Bundle options) throws RemoteException;\n96    public boolean finishActivity(IBinder token, int code, Intent data, boolean finishTask)\n97            throws RemoteException;\n98    public void finishSubActivity(IBinder token, String resultWho, int requestCode) throws RemoteException;\n99    public boolean finishActivityAffinity(IBinder token) throws RemoteException;\n100    public void finishVoiceTask(IVoiceInteractionSession session) throws RemoteException;\n101    public boolean releaseActivityInstance(IBinder token) throws RemoteException;\n102    public void releaseSomeActivities(IApplicationThread app) throws RemoteException;\n103    public boolean willActivityBeVisible(IBinder token) throws RemoteException;\n   ...\n}\n```\n\n那么上面gDefault中返回的`am`到底是那个实现类呢，跟进`IActivityManager am = asInterface(b)`\n\n```java\n67    static public IActivityManager asInterface(IBinder obj) {\n68        if (obj == null) {\n69            return null;\n70        }\n71        IActivityManager in =\n72            (IActivityManager)obj.queryLocalInterface(descriptor);\n73        if (in != null) {\n74            return in;\n75        }\n76\n77        return new ActivityManagerProxy(obj);\n78    }\n```\n\n所以` ActivityManagerNative.getDefault()`返回的是`ActivityManagerProxy`，是ActivityManagerNative的一个内部类，他俩都实现了IActivityManager这个接口，重点关注一下构造方法，传入的是一个 **IBinder** 实例\n\n```java\n    public ActivityManagerProxy(IBinder remote)  \n    {  \n        mRemote = remote;  \n    }  \n```\n\n`跟进查看`startActivity`方法\n\n```java\n2631    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n2632            String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n2633            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n2634        Parcel data = Parcel.obtain();\n2635        Parcel reply = Parcel.obtain();\n2636        data.writeInterfaceToken(IActivityManager.descriptor);\n2637        data.writeStrongBinder(caller != null ? caller.asBinder() : null);\n2638        data.writeString(callingPackage);\n2639        intent.writeToParcel(data, 0);\n2640        data.writeString(resolvedType);\n2641        data.writeStrongBinder(resultTo);\n2642        data.writeString(resultWho);\n2643        data.writeInt(requestCode);\n2644        data.writeInt(startFlags);\n2645        if (profilerInfo != null) {\n2646            data.writeInt(1);\n2647            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);\n2648        } else {\n2649            data.writeInt(0);\n2650        }\n2651        if (options != null) {\n2652            data.writeInt(1);\n2653            options.writeToParcel(data, 0);\n2654        } else {\n2655            data.writeInt(0);\n2656        }\n2657        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n2658        reply.readException();\n2659        int result = reply.readInt();\n2660        reply.recycle();\n2661        data.recycle();\n2662        return result;\n2663    }\n```\n\n很明了，使用`mRemote`成员进行Binder通信，通信码`START_ACTIVITY_TRANSACTION`。\n\n往上回溯，这个mRemote就是`ServiceManager.getService(\"activity\")`的返回值，那么这个的返回值是啥捏\n\n是`ActivityManagerService`，让我们进入 [ActivityManagerService](http://androidxref.com/6.0.1_r10/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java)的代码来找证据\n\n```java\n2172    public void setSystemProcess() {\n2173        try {\n2174            ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);//重点看这 看这！\n2175            ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);\n2176            ServiceManager.addService(\"meminfo\", new MemBinder(this));\n2177            ServiceManager.addService(\"gfxinfo\", new GraphicsBinder(this));\n2178            ServiceManager.addService(\"dbinfo\", new DbBinder(this));\n2179            if (MONITOR_CPU_USAGE) {\n2180                ServiceManager.addService(\"cpuinfo\", new CpuBinder(this));\n2181            }\n2182            ServiceManager.addService(\"permission\", new PermissionController(this));\n2183            ServiceManager.addService(\"processinfo\", new ProcessInfoService(this));\n2184\n2185            ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(\n2186                    \"android\", STOCK_PM_FLAGS);\n2187            mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());\n\n2201        } catch (PackageManager.NameNotFoundException e) {\n2202            throw new RuntimeException(\n2203                    \"Unable to find android system package\", e);\n2204        }\n2205    }\n```\n\nContext.java中定义了**ACTIVITY_SERVICE**=activity\n\n`public static final String ACTIVITY_SERVICE = \"activity\" `\n\nActivityManagerService又把自己注册为`activity`这个服务，所以`ServiceManager.getService(\"activity\")`的返回值就是ActivityManagerService。所以我们就进入`ActivityManagerService`分析一波。\n\n## ActivityManagerService->ActivityStackSupervisor\n\n我们是通过mRmote向AMS进行IPC通信，根据Binder的实现原理，会调用到AMS的`onTransact`方法\n\n```java\n2452    @Override\n2453    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n2454            throws RemoteException {\n2455        if (code == SYSPROPS_TRANSACTION) {\n2456            // We need to tell all apps about the system property change.\n\t\t\t\t...\n2481        }\n2482        try {\n2483            return super.onTransact(code, data, reply, flags);\n2484        } catch (RuntimeException e) {\n2485            // The activity manager only throws security exceptions, so let's\n2486            // log all others.\n2487            if (!(e instanceof SecurityException)) {\n2488                Slog.wtf(TAG, \"Activity Manager Crash\", e);\n2489            }\n2490            throw e;\n2491        }\n2492    }\n```\n\n实际上只响应SYSPROPS_TRANSACTION请求码，其他的通过`super`调用AMS的父类，ActivityManagerNative来处理，那么查看一下ActivityManagerNative的`onTransact`中对应code为`START_ACTIVITY_TRANSACTION`的方法块吧\n\n```java\n146        case START_ACTIVITY_TRANSACTION:\n147        {\n148            data.enforceInterface(IActivityManager.descriptor);\n149            IBinder b = data.readStrongBinder();\n150            IApplicationThread app = ApplicationThreadNative.asInterface(b);\n151            String callingPackage = data.readString();\n152            Intent intent = Intent.CREATOR.createFromParcel(data);\n153            String resolvedType = data.readString();\n154            IBinder resultTo = data.readStrongBinder();\n155            String resultWho = data.readString();\n156            int requestCode = data.readInt();\n157            int startFlags = data.readInt();\n158            ProfilerInfo profilerInfo = data.readInt() != 0\n159                    ? ProfilerInfo.CREATOR.createFromParcel(data) : null;\n160            Bundle options = data.readInt() != 0\n161                    ? Bundle.CREATOR.createFromParcel(data) : null;\n162            int result = startActivity(app, callingPackage, intent, resolvedType,\n163                    resultTo, resultWho, requestCode, startFlags, profilerInfo, options);\n164            reply.writeNoException();\n165            reply.writeInt(result);\n166            return true;\n167        }\n```\n\n烦不烦啊，怎么又调用`startActivity`，但是注意了啊，这个`startActivity`是**AMS**中的，而不是上面的ActivityManagerNative中的方法。\n\n```java\n3848    @Override\n3849    public final int startActivity(IApplicationThread caller, String callingPackage,\n3850            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n3851            int startFlags, ProfilerInfo profilerInfo, Bundle options) {\n3852        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,\n3853            resultWho, requestCode, startFlags, profilerInfo, options,\n3854            UserHandle.getCallingUserId());\n3855    }\n3856\n3857    @Override\n3858    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n3859            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n3860            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n3861        enforceNotIsolatedCaller(\"startActivity\");\n3862        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n3863                false, ALLOW_FULL_ONLY, \"startActivity\", null);\n3864        // TODO: Switch to user app stacks here.\n3865        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n3866                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n3867                profilerInfo, null, null, options, false, userId, null, null);\n3868    }\n```\n\n冲啊，跟进代码[mStackSupervisor.startActivityMayWait](http://androidxref.com/6.0.1_r10/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java#925)\n\n```java\n final int startActivityMayWait(IApplicationThread caller, int callingUid,\n926            String callingPackage, Intent intent, String resolvedType,\n927            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n928            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n929            ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,\n930            Bundle options, boolean ignoreTargetSecurity, int userId,\n931            IActivityContainer iContainer, TaskRecord inTask) {\n\n//解析Intent信息\n938        // Don't modify the client's object!\n939        intent = new Intent(intent);\n941        // Collect information about the target of the Intent.\n942        ActivityInfo aInfo =\n943                resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId);\n\n946        synchronized (mService) {\n\n1045            int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n1046                    voiceSession, voiceInteractor, resultTo, resultWho,\n1047                    requestCode, callingPid, callingUid, callingPackage,\n1048                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,\n\n1095\n1096            return res;\n1097        }\n1098    }\n```\n\n代码太长 删减了许多，有兴趣的自己看源码去，跟进`res = startActivityLocked`\n\n```java\n    final int startActivityLocked(IApplicationThread caller,\n1400            Intent intent, String resolvedType, ActivityInfo aInfo,\n1401            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n1402            IBinder resultTo, String resultWho, int requestCode,\n1403            int callingPid, int callingUid, String callingPackage,\n1404            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n1405            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,\n1406            ActivityContainer container, TaskRecord inTask) {\n1407        int err = ActivityManager.START_SUCCESS;\n//从传进来的参数caller得到调用者的进程信息，并保存在callerApp变量中\n1409        ProcessRecord callerApp = null;\n1410        if (caller != null) {\n1411            callerApp = mService.getRecordForAppLocked(caller);\n1412            if (callerApp != null) {\n1413                callingPid = callerApp.pid;\n1414                callingUid = callerApp.info.uid;\n1415            } else {\n1416                Slog.w(TAG, \"Unable to find app for caller \" + caller\n1417                      + \" (pid=\" + callingPid + \") when starting: \"\n1418                      + intent.toString());\n1419                err = ActivityManager.START_PERMISSION_DENIED;\n1420            }\n1421        }\n1422\n\n//创建即将要启动的Activity的相关信息，并保存在r变量\n1636        ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,\n1637                intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,\n1638                requestCode, componentSpecified, voiceSession != null, this, container, options);\n\n1674\n1675        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n1676                startFlags, true, options, inTask);\n1677\n1678        if (err < 0) {\n1679            // If someone asked to have the keyguard dismissed on the next\n1680            // activity start, but we are not actually doing an activity\n1681            // switch...  just dismiss the keyguard now, because we\n1682            // probably want to see whatever is behind it.\n1683            notifyActivityDrawnForKeyguard();\n1684        }\n1685        return err;\n1686    }\n```\n\n代码量实在太多了，对一些信息的封装和检测啥的，真不大懂，无脑跟进，go`startActivityUncheckedLocked`\n\n```java\n final int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord,\n1829            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,\n1830            boolean doResume, Bundle options, TaskRecord inTask) {\n1831        final Intent intent = r.intent;\n1832        final int callingUid = r.launchedFromUid;\n1833\n\n1847        int launchFlags = intent.getFlags();\n1848        if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0 &&\n1849                (launchSingleInstance || launchSingleTask)) {\n1850            // We have a conflict between the Intent and the Activity manifest, manifest wins.\n1851            Slog.i(TAG, \"Ignoring FLAG_ACTIVITY_NEW_DOCUMENT, launchMode is \" +\n1852                    \"\\\"singleInstance\\\" or \\\"singleTask\\\"\");\n1853            launchFlags &=\n1854                    ~(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);\n1855        } else {\n1856            switch (r.info.documentLaunchMode) {\n1857                case ActivityInfo.DOCUMENT_LAUNCH_NONE:\n1858                    break;\n1859                case ActivityInfo.DOCUMENT_LAUNCH_INTO_EXISTING:\n1860                    launchFlags |= Intent.FLAG_ACTIVITY_NEW_DOCUMENT;\n1861                    break;\n1862                case ActivityInfo.DOCUMENT_LAUNCH_ALWAYS:\n1863                    launchFlags |= Intent.FLAG_ACTIVITY_NEW_DOCUMENT;\n1864                    break;\n1865                case ActivityInfo.DOCUMENT_LAUNCH_NEVER:\n1866                    launchFlags &= ~Intent.FLAG_ACTIVITY_MULTIPLE_TASK;\n1867                    break;\n1868            }\n1869        }\n1870\n1871        final boolean launchTaskBehind = r.mLaunchTaskBehind\n1872                && !launchSingleTask && !launchSingleInstance\n1873                && (launchFlags & Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0;\n1874\n\n2457        ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);\n2458        targetStack.mLastPausedActivity = null;\n2459        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n2464        return ActivityManager.START_SUCCESS;\n2465    }\n```\n\n一堆的标记位Flag检测，来判断启动行为，看不懂，放弃，go`startActivityLocked`\n\n```java\n\n1399    final int startActivityLocked(IApplicationThread caller,\n1400            Intent intent, String resolvedType, ActivityInfo aInfo,\n1401            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n1402            IBinder resultTo, String resultWho, int requestCode,\n1403            int callingPid, int callingUid, String callingPackage,\n1404            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n1405            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,\n1406            ActivityContainer container, TaskRecord inTask) {\n1407        int err = ActivityManager.START_SUCCESS;\n1408\n1409        ProcessRecord callerApp = null;\n1410        if (caller != null) {\n1411            callerApp = mService.getRecordForAppLocked(caller);\n1412            if (callerApp != null) {\n1413                callingPid = callerApp.pid;\n1414                callingUid = callerApp.info.uid;\n1415            } else {\n1416                Slog.w(TAG, \"Unable to find app for caller \" + caller\n1417                      + \" (pid=\" + callingPid + \") when starting: \"\n1418                      + intent.toString());\n1419                err = ActivityManager.START_PERMISSION_DENIED;\n1420            }\n1421        }\n1422\n1423        final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;\n1424\n1425        if (err == ActivityManager.START_SUCCESS) {\n1426            Slog.i(TAG, \"START u\" + userId + \" {\" + intent.toShortString(true, true, true, false)\n1427                    + \"} from uid \" + callingUid\n1428                    + \" on display \" + (container == null ? (mFocusedStack == null ?\n1429                            Display.DEFAULT_DISPLAY : mFocusedStack.mDisplayId) :\n1430                            (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY :\n1431                                    container.mActivityDisplay.mDisplayId)));\n1432        }\n1433\n1434        ActivityRecord sourceRecord = null;\n1435        ActivityRecord resultRecord = null;\n1436        if (resultTo != null) {\n1437            sourceRecord = isInAnyStackLocked(resultTo);\n1438            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,\n1439                    \"Will send result to \" + resultTo + \" \" + sourceRecord);\n1440            if (sourceRecord != null) {\n1441                if (requestCode >= 0 && !sourceRecord.finishing) {\n1442                    resultRecord = sourceRecord;\n1443                }\n1444            }\n1445        }\n1446\n1447        final int launchFlags = intent.getFlags();\n1448\n1449        if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {\n1450            // Transfer the result target from the source activity to the new\n1451            // one being started, including any failures.\n1452            if (requestCode >= 0) {\n1453                ActivityOptions.abort(options);\n1454                return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;\n1455            }\n1456            resultRecord = sourceRecord.resultTo;\n1457            if (resultRecord != null && !resultRecord.isInStackLocked()) {\n1458                resultRecord = null;\n1459            }\n1460            resultWho = sourceRecord.resultWho;\n1461            requestCode = sourceRecord.requestCode;\n1462            sourceRecord.resultTo = null;\n1463            if (resultRecord != null) {\n1464                resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);\n1465            }\n1466            if (sourceRecord.launchedFromUid == callingUid) {\n1467                // The new activity is being launched from the same uid as the previous\n1468                // activity in the flow, and asking to forward its result back to the\n1469                // previous.  In this case the activity is serving as a trampoline between\n1470                // the two, so we also want to update its launchedFromPackage to be the\n1471                // same as the previous activity.  Note that this is safe, since we know\n1472                // these two packages come from the same uid; the caller could just as\n1473                // well have supplied that same package name itself.  This specifially\n1474                // deals with the case of an intent picker/chooser being launched in the app\n1475                // flow to redirect to an activity picked by the user, where we want the final\n1476                // activity to consider it to have been launched by the previous app activity.\n1477                callingPackage = sourceRecord.launchedFromPackage;\n1478            }\n1479        }\n1480\n1481        if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {\n1482            // We couldn't find a class that can handle the given Intent.\n1483            // That's the end of that!\n1484            err = ActivityManager.START_INTENT_NOT_RESOLVED;\n1485        }\n1486\n1487        if (err == ActivityManager.START_SUCCESS && aInfo == null) {\n1488            // We couldn't find the specific class specified in the Intent.\n1489            // Also the end of the line.\n1490            err = ActivityManager.START_CLASS_NOT_FOUND;\n1491        }\n1492\n1493        if (err == ActivityManager.START_SUCCESS\n1494                && !isCurrentProfileLocked(userId)\n1495                && (aInfo.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {\n1496            // Trying to launch a background activity that doesn't show for all users.\n1497            err = ActivityManager.START_NOT_CURRENT_USER_ACTIVITY;\n1498        }\n1499\n1500        if (err == ActivityManager.START_SUCCESS && sourceRecord != null\n1501                && sourceRecord.task.voiceSession != null) {\n1502            // If this activity is being launched as part of a voice session, we need\n1503            // to ensure that it is safe to do so.  If the upcoming activity will also\n1504            // be part of the voice session, we can only launch it if it has explicitly\n1505            // said it supports the VOICE category, or it is a part of the calling app.\n1506            if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n1507                    && sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) {\n1508                try {\n1509                    intent.addCategory(Intent.CATEGORY_VOICE);\n1510                    if (!AppGlobals.getPackageManager().activitySupportsIntent(\n1511                            intent.getComponent(), intent, resolvedType)) {\n1512                        Slog.w(TAG,\n1513                                \"Activity being started in current voice task does not support voice: \"\n1514                                + intent);\n1515                        err = ActivityManager.START_NOT_VOICE_COMPATIBLE;\n1516                    }\n1517                } catch (RemoteException e) {\n1518                    Slog.w(TAG, \"Failure checking voice capabilities\", e);\n1519                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;\n1520                }\n1521            }\n1522        }\n1523\n1524        if (err == ActivityManager.START_SUCCESS && voiceSession != null) {\n1525            // If the caller is starting a new voice session, just make sure the target\n1526            // is actually allowing it to run this way.\n1527            try {\n1528                if (!AppGlobals.getPackageManager().activitySupportsIntent(intent.getComponent(),\n1529                        intent, resolvedType)) {\n1530                    Slog.w(TAG,\n1531                            \"Activity being started in new voice task does not support: \"\n1532                            + intent);\n1533                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;\n1534                }\n1535            } catch (RemoteException e) {\n1536                Slog.w(TAG, \"Failure checking voice capabilities\", e);\n1537                err = ActivityManager.START_NOT_VOICE_COMPATIBLE;\n1538            }\n1539        }\n1540\n1541        final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack;\n1542\n1543        if (err != ActivityManager.START_SUCCESS) {\n1544            if (resultRecord != null) {\n1545                resultStack.sendActivityResultLocked(-1,\n1546                    resultRecord, resultWho, requestCode,\n1547                    Activity.RESULT_CANCELED, null);\n1548            }\n1549            ActivityOptions.abort(options);\n1550            return err;\n1551        }\n1552\n1553        boolean abort = false;\n1554\n1555        final int startAnyPerm = mService.checkPermission(\n1556                START_ANY_ACTIVITY, callingPid, callingUid);\n1557\n1558        if (startAnyPerm != PERMISSION_GRANTED) {\n1559            final int componentRestriction = getComponentRestrictionForCallingPackage(\n1560                    aInfo, callingPackage, callingPid, callingUid, ignoreTargetSecurity);\n1561            final int actionRestriction = getActionRestrictionForCallingPackage(\n1562                    intent.getAction(), callingPackage, callingPid, callingUid);\n1563\n1564            if (componentRestriction == ACTIVITY_RESTRICTION_PERMISSION\n1565                    || actionRestriction == ACTIVITY_RESTRICTION_PERMISSION) {\n1566                if (resultRecord != null) {\n1567                    resultStack.sendActivityResultLocked(-1,\n1568                            resultRecord, resultWho, requestCode,\n1569                            Activity.RESULT_CANCELED, null);\n1570                }\n1571                String msg;\n1572                if (actionRestriction == ACTIVITY_RESTRICTION_PERMISSION) {\n1573                    msg = \"Permission Denial: starting \" + intent.toString()\n1574                            + \" from \" + callerApp + \" (pid=\" + callingPid\n1575                            + \", uid=\" + callingUid + \")\" + \" with revoked permission \"\n1576                            + ACTION_TO_RUNTIME_PERMISSION.get(intent.getAction());\n1577                } else if (!aInfo.exported) {\n1578                    msg = \"Permission Denial: starting \" + intent.toString()\n1579                            + \" from \" + callerApp + \" (pid=\" + callingPid\n1580                            + \", uid=\" + callingUid + \")\"\n1581                            + \" not exported from uid \" + aInfo.applicationInfo.uid;\n1582                } else {\n1583                    msg = \"Permission Denial: starting \" + intent.toString()\n1584                            + \" from \" + callerApp + \" (pid=\" + callingPid\n1585                            + \", uid=\" + callingUid + \")\"\n1586                            + \" requires \" + aInfo.permission;\n1587                }\n1588                Slog.w(TAG, msg);\n1589                throw new SecurityException(msg);\n1590            }\n1591\n1592            if (actionRestriction == ACTIVITY_RESTRICTION_APPOP) {\n1593                String message = \"Appop Denial: starting \" + intent.toString()\n1594                        + \" from \" + callerApp + \" (pid=\" + callingPid\n1595                        + \", uid=\" + callingUid + \")\"\n1596                        + \" requires \" + AppOpsManager.permissionToOp(\n1597                                ACTION_TO_RUNTIME_PERMISSION.get(intent.getAction()));\n1598                Slog.w(TAG, message);\n1599                abort = true;\n1600            } else if (componentRestriction == ACTIVITY_RESTRICTION_APPOP) {\n1601                String message = \"Appop Denial: starting \" + intent.toString()\n1602                        + \" from \" + callerApp + \" (pid=\" + callingPid\n1603                        + \", uid=\" + callingUid + \")\"\n1604                        + \" requires appop \" + AppOpsManager.permissionToOp(aInfo.permission);\n1605                Slog.w(TAG, message);\n1606                abort = true;\n1607            }\n1608        }\n1609\n1610        abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,\n1611                callingPid, resolvedType, aInfo.applicationInfo);\n1612\n1613        if (mService.mController != null) {\n1614            try {\n1615                // The Intent we give to the watcher has the extra data\n1616                // stripped off, since it can contain private information.\n1617                Intent watchIntent = intent.cloneFilter();\n1618                abort |= !mService.mController.activityStarting(watchIntent,\n1619                        aInfo.applicationInfo.packageName);\n1620            } catch (RemoteException e) {\n1621                mService.mController = null;\n1622            }\n1623        }\n1624\n1625        if (abort) {\n1626            if (resultRecord != null) {\n1627                resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode,\n1628                        Activity.RESULT_CANCELED, null);\n1629            }\n1630            // We pretend to the caller that it was really started, but\n1631            // they will just get a cancel result.\n1632            ActivityOptions.abort(options);\n1633            return ActivityManager.START_SUCCESS;\n1634        }\n1635\n1636        ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,\n1637                intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,\n1638                requestCode, componentSpecified, voiceSession != null, this, container, options);\n1639        if (outActivity != null) {\n1640            outActivity[0] = r;\n1641        }\n1642\n1643        if (r.appTimeTracker == null && sourceRecord != null) {\n1644            // If the caller didn't specify an explicit time tracker, we want to continue\n1645            // tracking under any it has.\n1646            r.appTimeTracker = sourceRecord.appTimeTracker;\n1647        }\n1648\n1649        final ActivityStack stack = mFocusedStack;\n1650        if (voiceSession == null && (stack.mResumedActivity == null\n1651                || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {\n1652            if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,\n1653                    realCallingPid, realCallingUid, \"Activity start\")) {\n1654                PendingActivityLaunch pal =\n1655                        new PendingActivityLaunch(r, sourceRecord, startFlags, stack);\n1656                mPendingActivityLaunches.add(pal);\n1657                ActivityOptions.abort(options);\n1658                return ActivityManager.START_SWITCHES_CANCELED;\n1659            }\n1660        }\n1661\n1662        if (mService.mDidAppSwitch) {\n1663            // This is the second allowed switch since we stopped switches,\n1664            // so now just generally allow switches.  Use case: user presses\n1665            // home (switches disabled, switch to home, mDidAppSwitch now true);\n1666            // user taps a home icon (coming from home so allowed, we hit here\n1667            // and now allow anyone to switch again).\n1668            mService.mAppSwitchesAllowedTime = 0;\n1669        } else {\n1670            mService.mDidAppSwitch = true;\n1671        }\n1672\n1673        doPendingActivityLaunchesLocked(false);\n1674\n1675        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n1676                startFlags, true, options, inTask);\n1677\n1678        if (err < 0) {\n1679            // If someone asked to have the keyguard dismissed on the next\n1680            // activity start, but we are not actually doing an activity\n1681            // switch...  just dismiss the keyguard now, because we\n1682            // probably want to see whatever is behind it.\n1683            notifyActivityDrawnForKeyguard();\n1684        }\n1685        return err;\n1686    }\n```\n\n\n\n代码都是多的要死，在startActivityLocked内部主要就是把Activity放到Activity组件堆栈中，然后在激活栈顶的Activity来达到启动Activity的目的。\n\n然后`startActivityUncheckedLocked`-> `ActivityStack.resumeTopActivityLocked`来通知Activity栈最上层不为Finish态的Activity进入Paused状态->`resumeTopActivityInnerLocked`->`startPausingLocked`来设置ActivityRecord状态和调用ApplicationThreadProxy的`schedulePauseActivity`方法\n\n#ApplicationThreadProxy->ApplicationThread->ActivityThread\n\nApplicationThreadProxy是[ApplicationThreadNative](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/app/ApplicationThreadNative.java)的内部类\n\n```java\npublic abstract class ApplicationThreadNative extends Binder\n        implements IApplicationThread {\n        ...\n\t\n\t\n\tclass ApplicationThreadProxy implements IApplicationThread {\n        ...  \n        }\n}\n```\n\n跟之前说的ActivityManagerNative和ActivityManagerProxy异曲同工，ApplicationThreadProxy发送的transact会在ActivityManagerNative的子类[ApplicationThread](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/app/ActivityThread.java#574)`onTransact`方法处理，ApplicationThread是ActivityThread的内部类，同时也没有覆盖`onTransact`方法。\n\n```java\n// ApplicationThreadProxy.class\n718    public final void schedulePauseActivity(IBinder token, boolean finished,\n719            boolean userLeaving, int configChanges, boolean dontReport) throws RemoteException {\n720        Parcel data = Parcel.obtain();\n721        data.writeInterfaceToken(IApplicationThread.descriptor);\n722        data.writeStrongBinder(token);\n723        data.writeInt(finished ? 1 : 0);\n724        data.writeInt(userLeaving ? 1 :0);\n725        data.writeInt(configChanges);\n726        data.writeInt(dontReport ? 1 : 0);\n727        mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, null,\n728                IBinder.FLAG_ONEWAY);\n729        data.recycle();\n730    }\n731\n // ActivityManagerNative.java\n  78        case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:\n79        {\n80            data.enforceInterface(IApplicationThread.descriptor);\n81            IBinder b = data.readStrongBinder();\n82            boolean finished = data.readInt() != 0;\n83            boolean userLeaving = data.readInt() != 0;\n84            int configChanges = data.readInt();\n85            boolean dontReport = data.readInt() != 0;\n86            schedulePauseActivity(b, finished, userLeaving, configChanges, dontReport);\n87            return true;\n88        }\n//ApplicationThread.class \n588        public final void schedulePauseActivity(IBinder token, boolean finished,\n589                boolean userLeaving, int configChanges, boolean dontReport) {\n590            sendMessage(\n591                    finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,\n592                    token,\n593                    (userLeaving ? 1 : 0) | (dontReport ? 2 : 0),\n594                    configChanges);\n595        }\n\n  \n```\n\n跟进ActivityThread成员函数`sendMessage`\n\n```java\n2265    private void sendMessage(int what, Object obj, int arg1, int arg2) {\n2266        sendMessage(what, obj, arg1, arg2, false);\n2267    }\n2268\n2269    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {\n2270        if (DEBUG_MESSAGES) Slog.v(\n2271            TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what)\n2272            + \": \" + arg1 + \" / \" + obj);\n2273        Message msg = Message.obtain();\n2274        msg.what = what;\n2275        msg.obj = obj;\n2276        msg.arg1 = arg1;\n2277        msg.arg2 = arg2;\n2278        if (async) {\n2279            msg.setAsynchronous(true);\n2280        }\n2281        mH.sendMessage(msg);\n2282    }\n```\n\n这就是handler-message机制了，注意这个what字段值为**PAUSE_ACTIVITY**，跟进`handleMessage`方法！！！\n\n```java\n1353                case PAUSE_ACTIVITY:\n1354                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\");\n1355                    handlePauseActivity((IBinder)msg.obj, false, (msg.arg1&1) != 0, msg.arg2,\n1356                            (msg.arg1&2) != 0);\n1357                    maybeSnapshot();\n1358                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n1359                    break;\n```\n\n```java\n3305    private void handlePauseActivity(IBinder token, boolean finished,\n3306            boolean userLeaving, int configChanges, boolean dontReport) {\n3307        ActivityClientRecord r = mActivities.get(token);\n3308        if (r != null) {\n\n3322            // Tell the activity manager we have paused.\n3323            if (!dontReport) {\n3324                try {\n3325                    ActivityManagerNative.getDefault().activityPaused(token);\n3326                } catch (RemoteException ex) {\n3327                }\n3328            }\n3329            mSomeActivitiesChanged = true;\n3330        }\n3331    }\n```\n\n之前说过了ActivityManagerNative.getDefault()=ActivityManagerProxy，所以就跟进\n\n```java\n3134    public void activityPaused(IBinder token) throws RemoteException\n3135    {\n3136        Parcel data = Parcel.obtain();\n3137        Parcel reply = Parcel.obtain();\n3138        data.writeInterfaceToken(IActivityManager.descriptor);\n3139        data.writeStrongBinder(token);\n3140        mRemote.transact(ACTIVITY_PAUSED_TRANSACTION, data, reply, 0);\n3141        reply.readException();\n3142        data.recycle();\n3143        reply.recycle();\n3144    }\n```\n\n又是一个Binder通信过程，所以看AMS的`onTransact`中code=ACTIVITY_PAUSED_TRANSACTION的代码，实际上在AMS父类AMNative中\n\n```java\n536        case ACTIVITY_PAUSED_TRANSACTION: {\n537            data.enforceInterface(IActivityManager.descriptor);\n538            IBinder token = data.readStrongBinder();\n539            activityPaused(token);\n540            reply.writeNoException();\n541            return true;\n542        }\n```\n\n又调用了AMS的`activityPaused`方法，跟进，擦\n\n```java\n6497    @Override\n6498    public final void activityPaused(IBinder token) {\n6499        final long origId = Binder.clearCallingIdentity();\n6500        synchronized(this) {\n6501            ActivityStack stack = ActivityRecord.getStackLocked(token);\n6502            if (stack != null) {\n6503                stack.activityPausedLocked(token, false);\n6504            }\n6505        }\n6506        Binder.restoreCallingIdentity(origId);\n6507    }\n6508\n```\n\nActivityStack的`activityPausedLocked`\n\n```java\n928    final void activityPausedLocked(IBinder token, boolean timeout) {\n929        if (DEBUG_PAUSE) Slog.v(TAG_PAUSE,\n930            \"Activity paused: token=\" + token + \", timeout=\" + timeout);\n931\n932        final ActivityRecord r = isInStackLocked(token);\n933        if (r != null) {\n934            mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);\n935            if (mPausingActivity == r) {\n\n938                completePauseLocked(true);\n939            } else {\n\n944                if (r.finishing && r.state == ActivityState.PAUSING) {\n\n947                    finishCurrentActivityLocked(r, FINISH_AFTER_VISIBLE, false);\n948                }\n949            }\n950        }\n951    }\n```\n\n`completePauseLocked`->`StackSupervisor.resumeTopActivitiesLocked(topStack, prev, null);`\n\n```java\n2727    boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,\n2728            Bundle targetOptions) {\n2729        if (targetStack == null) {\n2730            targetStack = mFocusedStack;\n2731        }\n2732        // Do targetStack first.\n2733        boolean result = false;\n2734        if (isFrontStack(targetStack)) {\n2735            result = targetStack.resumeTopActivityLocked(target, targetOptions);\n2736        }\n2737\n2738        for (int displayNdx = mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {\n2739            final ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks;\n2740            for (int stackNdx = stacks.size() - 1; stackNdx >= 0; --stackNdx) {\n2741                final ActivityStack stack = stacks.get(stackNdx);\n2742                if (stack == targetStack) {\n2743                    // Already started above.\n2744                    continue;\n2745                }\n2746                if (isFrontStack(stack)) {\n2747                    stack.resumeTopActivityLocked(null);\n2748                }\n2749            }\n2750        }\n2751        return result;\n2752    }\n```\n\n`ActivityStack.resumeTopActivityLocked`->`resumeTopActivityInnerLocked`->`StackSupervisor.startspecificactivitylocked`\n\n```java\n1365    void startSpecificActivityLocked(ActivityRecord r,\n1366            boolean andResume, boolean checkConfig) {\n1367        // Is this activity's application already running?\n1368        ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n1369                r.info.applicationInfo.uid, true);\n1370\n1371        r.task.stack.setLaunchTime(r);\n1372\n1373        if (app != null && app.thread != null) {\n1393        }\n1394\n1395        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n1396                \"activity\", r.intent.getComponent(), false, false, true);\n1397    }\n```\n\nAMS.startProcessLocked会启动r.processName=ActivityThread这个进程，则会执行ActivityThread.main方法\n\n## ActivityThread->\n\n\n\n```java\n5379    public static void main(String[] args) {\n5380        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\");\n5381        SamplingProfilerIntegration.start();\n5382\n\n5387\n5388        Environment.initForCurrentUser();\n\n\n5398\n5399        Process.setArgV0(\"<pre-initialized>\");\n5400\n5401        Looper.prepareMainLooper();\n5402\n5403        ActivityThread thread = new ActivityThread();\n5404        thread.attach(false);\n5405\n5406        if (sMainThreadHandler == null) {\n5407            sMainThreadHandler = thread.getHandler();\n5408        }\n5409\n5410        if (false) {\n5411            Looper.myLooper().setMessageLogging(new\n5412                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n5413        }\n5414\n5415        // End of event ActivityThreadMain.\n5416        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n5417        Looper.loop();\n5418\n5419        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n5420    }\n\t\t\n\n\n\n5230    private void attach(boolean system) {\n5231        sCurrentActivityThread = this;\n5232        mSystemThread = system;\n5233        if (!system) {\n\n5243            final IActivityManager mgr = ActivityManagerNative.getDefault();\n5244            try {\n5245                mgr.attachApplication(mAppThread);\n5246            } catch (RemoteException ex) {\n5247                // Ignore\n5248            }\n  \t\t\t...\n\t\t\t}\n  \t\t\t...\n\t\t}\n```\n\n\n\n`attachApplication`，还是一个套路，AMProxy通过Binder发送，AMS来响应的套路，这次的code码为ATTACH_APPLICATION_TRANSACTION\n\n```JAVA\n//AMProxy\n3093    public void attachApplication(IApplicationThread app) throws RemoteException\n3094    {\n3095        Parcel data = Parcel.obtain();\n3096        Parcel reply = Parcel.obtain();\n3097        data.writeInterfaceToken(IActivityManager.descriptor);\n3098        data.writeStrongBinder(app.asBinder());\n3099        mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0);\n3100        reply.readException();\n3101        data.recycle();\n3102        reply.recycle();\n3103    }\n\n//AMNatvie\n502        case ATTACH_APPLICATION_TRANSACTION: {\n503            data.enforceInterface(IActivityManager.descriptor);\n504            IApplicationThread app = ApplicationThreadNative.asInterface(\n505                    data.readStrongBinder());\n506            if (app != null) {\n507                attachApplication(app);\n508            }\n509            reply.writeNoException();\n510            return true;\n511        }\n512\n  \n//AMS\n  6245    @Override\n6246    public final void attachApplication(IApplicationThread thread) {\n6247        synchronized (this) {\n6248            int callingPid = Binder.getCallingPid();\n6249            final long origId = Binder.clearCallingIdentity();\n6250            attachApplicationLocked(thread, callingPid);\n6251            Binder.restoreCallingIdentity(origId);\n6252        }\n6253    }\n\n```\n\nAMS.attachApplicationLocked 又调用了Stack.realStartActivityLocked -> ApplicationThreadProxy.scheduleLaunchActivity->ApplicationThread.scheduleLaunchActivity->ActivityThread.sendMessage->H.handleMessage->handleLaunchActivity->ActivityThread.handleLaunchActivity->performLaunchActivity->mInstrumentation.callActivityOnCreate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 参考\n\n[AMS和SystemServer](https://www.cnblogs.com/bastard/p/5770573.html)\n\n[ActivityManager ActivityManagerProxy等关系](http://blog.csdn.net/kc58236582/article/details/50394905)\n\n[ActivityRecord、TaskRecord、ActivityStack](http://blog.csdn.net/kebelzc24/article/details/53747506)\n","tags":["源码分析","Activity"],"categories":["Android"]},{"title":"注入之道(四) 实例","url":"/2018/01/06/inject-4-demo/","content":"注入一台ArmV8架构的5.1版本手机，替换eglswapbuffer函数，来获取eglswapbuffer的调用次数。\n<!-- more -->\n\n完整代码见[github](https://github.com/MelonWXD/ELFHooker)\n注入系列笔记：\n[ELF格式分析](https://melonwxd.github.io/2017/11/19/inject-1-elf/)\n[so文件加载流程](https://melonwxd.github.io/2017/11/28/inject-2-so/)\n[Inject和Hook](https://melonwxd.github.io/2017/12/01/inject-3-hook/)\n\n# 使用\n准备:\n- 一台root的android设备\n- ndk编译环境\n\n分别开2个终端来查看日志:\n- adb logcat | grep INJECT\n- adb logcat | grep ELFHooker\n  如果其他日志太多了可以用 `adb logcat -c`来清理一下日志\n\n然后在新的终端中执行:\n- git clone \n- cd jni\n- ndk-build\n- cd ../libs/arm64-v8a/ (or ../libs/armeabi// if your device is 32-bit)\n- adb push .* /data/local/tmp\n- adb shell\n- su\n- cd /data/local/tmp\n- chmod 755 inject\n- chmod 755 libelfHooker.so \n\n找到`/system/bin/surfaceflinger`这个进程的pid:\n- ps | grep surfaceflinger\n- ./inject -p <pid> -l /data/local/tmp/libelfHooker.so\n  ![](http://owu391pls.bkt.clouddn.com/cmdlog.png)\n  查看日志输出:\n  ![](http://owu391pls.bkt.clouddn.com/injectlog.png)\n  ![](http://owu391pls.bkt.clouddn.com/hookerlog.png)\n\n\n\n\n\n# 参考\n[Lody's elfHook](https://github.com/asLody/ElfHook)\n[ Android中的so注入(inject)和挂钩(hook) - For both x86 and arm](http://blog.csdn.net/jinzhuojun/article/details/9900105)\n","tags":["注入"],"categories":["Android逆向安全"]},{"title":"Unix I/O多路复用","url":"/2017/12/30/IO复用/","content":"分析select函数来学习 I/O多路复用\n<!-- more -->\n\n\n\n# 什么是 I/O多路复用\n\nIO 多路复用是5种I/O模型之一（阻塞IO 非阻塞IO IO复用 信号驱动IO 异步IO）\n\n## 阻塞IO\n\n当服务器要read一个socket链接的时候，内核挂起该线程，直到改socket有数据写入\n\n当服务器要处理1000个并发的时候，需要1000个线程，内存开销大\n\n## 非阻塞IO\n\n当服务器要read一个socket链接的时候，没有数据立即返回-1或返回一个错误\n\n服务器需要不断轮询\n\n## IO多路复用\n\n用一个线程，来管理一堆文件描述符fd，不断的轮询检查是否有fd可读（或者可写），如果有，就返回，否则一直阻塞到超时。\n\n得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。\n\n这样在处理1000个连接时，只需要1个线程监控就绪状态，对就绪的每个连接开一个线程处理就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的CPU开销\n\n# Select()\n```c\n\tint select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);\n```\n\n\n\n\n## fd_set\n\n结构体如下\n\n```c\n#define __NFDBITS (8 * sizeof(unsigned long))                //每个ulong型可以表示多少个bit,\n#define __FD_SETSIZE 1024                                          //socket最大取值为1024\n#define __FDSET_LONGS (__FD_SETSIZE/__NFDBITS)     //bitmap一共有1024个bit，共需要多少个ulong\n \ntypedef struct {\n    unsigned long fds_bits [__FDSET_LONGS];                 //用ulong数组来表示bitmap\n} __kernel_fd_set;\n```\n\nfd_set这个结构实际上就是一个数组，每个数组按位存放fd，即文件描述符，提供了4个宏定义来让我们操作fd_set\n\n```\n(1)、FD_ZERO(fd_set *)  清空一个文件描述符集合；\n(2)、FD_SET(int ,fd_set *) 将一个文件描述符添加到一个指定的文件描述符集合中；\n(3)、FD_CLR(int ,fd_set*)  将一个给定的文件描述符从集合中删除；\n(4)、FD_ISSET(int ,fd_set* ) 检查集合中指定的文件描述符是否可以读写。\n```\n\n那么参数中的`fd_set *readfds,fd_set *writefds,fd_set *errorfds`也非常好理解了：\n\n- readfds：这个数组中包含了所有我们要关注的fd的可读状态，如果这个数组中的某个fd状态变为可读，那么select就返回一个正整数，表示某个或多个文件目前可读\n- writefds：同上，可写\n- errorfds：同上，异常\n\n附图一张加深理解：\n\n![](http://img.blog.csdn.net/20131007164314234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGluZ2Zlbmd0ZW5nZmVp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n可以看到当程序开始监听的时候，通过宏定义来清空fd_set后再设置我们所关心的fd进去，在没有返回之后，通过`FD_ISSET`来找到变化的fd，判断是accept还是recv，然后再根据不同的操作还会在修改fd_set的某些位。\n\n\n\n## timeout\n\n结构体如下\n\n```c\nstruct timeval{      \n        long tv_sec;   /*秒 */\n        long tv_usec;  /*微秒 */   \n    }\n```\n\n有三种情况：\n\n- timeout == NULL  等待无限长的时间。等待可以被一个信号中断。当有一个描述符做好准备或者是捕获到一个信号时函数会返回。如果捕获到一个信号， select函数将返回-1,并将变量 erro设为 EINTR。\n- timeout->tv_sec == 0 && timeout->tv_usec == 0 不等待，直接返回。加入描述符集的描述符都会被测试，并且返回满足要求的描述符的个数。这种方法通过轮询，无阻塞地获得了多个文件描述符状态。\n- timeout->tv_sec !=0 ||timeout->tv_usec!= 0 等待指定的时间。当有描述符符合条件或者超过超时时间的话，函数返回。在超时时间即将用完但又没有描述符合条件的话，返回 0。等待也会被信号所中断。\n\n\n\n\n\n\n## 缺点\n\n- select 会修改传入的参数数组，这个对于一个需要调用很多次的函数，是非常不友好的。\n- select 当fd变化，select只是返回一个值，具体是哪个值还要我们去找，如果fd_set很大的话每次开销也很大\n- select 只能监视1024个链接 \n- select 不是线程安全的\n\n基于以上考量，就有了poll这方法，但是poll也不是线程安全的，之后又有了epoll～\n\n\n\n# 参考\n\n[select详解](https://www.cnblogs.com/ccsccs/articles/4224253.html)\n\n[知乎](https://www.zhihu.com/question/28594409)","tags":["并发"],"categories":["CSAPP"]},{"title":"Android异步消息处理","url":"/2017/12/26/Android异步消息处理/","content":"源码角度分析Android异步消息处理机制\n<!-- more -->\n# 写在前面\n最近公司变动频繁，心下略慌，刚才随便逛看到2个面试题：\n1. 一个线程有几个Handler，如果一个线程有多个Handler，那么怎么系统怎么确定某个Message所回调到的handleMessage方法\n\n2. 两个副线程可以使用Looper.prepare公用一个MessageQueue吗？如果可以怎么实现\n\n下意识给出如下答案：\n\n1. 一个线程可以有多个Handler。Handler在发送Message的时候会通过msg.target=this来把Handler和该Handler发送的消息关联起来。Message在被Looper提取处理的时候，会调用Message对应的tagert的dispatchMessage来，从而实现多个Handler回调的准确性。\n\n\n2. 第一反应是不能的，首先Looper.prepare的方法是通过ThreadLocal来保证多线程的互不影响，也保证了Looper在每个线程中都是唯一的，他这个题目我首先就有点看不懂了。最后看他说，如果可以，怎么实现？兄弟，貌似不可以啊，如果不可以为什么还要问怎么实现？一点思路都没有，又一想到Handler这个源码每次都是看了忘，遂再次走读源码并做个笔记。\n\n# Looper\n```java\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n\n```\n\n## ThreadLocal\n暂时不纠结源码，反正被他修饰的变量都会为每个线程拷贝一份副本，使得多线程可以无冲突的访问同一个变量且互相不影响。所以这个就保证了上面的prepare方法只会被调用1次，以及每个线程有且只有一个Looper。\n\n## 获取消息\n```java\n public static void loop() {\n        final Looper me = myLooper();\n        final MessageQueue queue = me.mQueue;\n        for (;;) {\n            Message msg = queue.next(); // might block\n            try {\n                msg.target.dispatchMessage(msg);\n            } finally {\n                if (traceTag != 0) {\n                    Trace.traceEnd(traceTag);\n                }\n         }\n    }\n\n```\n不断的循环，调用消息队列的next方法取出消息，再调用`msg.target.dispatchMessage`，即Handler的dispatchMessage。\n\n# Handler\n```java\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n## CallBack\n\n```java\n    public interface Callback {\n        public boolean handleMessage(Message msg);\n    }\n```\n没啥用，在处理的时候发现如果有Callback就调用Callback的handleMessage，就是不想写个类来实现自己的Handler的话使用这个回调来处理Message。\n\n## 发送\n```java\n    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n    \n        private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n`sendMessage`主要设置了msg.target=当前的handler 以及调用MessageQueue来enqueue消息，后续会被Looper获取。\n\n```java\n    public final boolean post(Runnable r)\n    {\n       return  sendMessageDelayed(getPostMessage(r), 0);\n    }\n\n    private static Message getPostMessage(Runnable r) {\n        Message m = Message.obtain();\n        m.callback = r;\n        return m;\n    }\n\n```\n\n而`post`是将传入的参数r作为新建的Message的成员callback，在后续的处理中会优先被调用到。\n\n## 处理\n```java\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n\n\n    private static void handleCallback(Message message) {\n        message.callback.run();\n    }\n```\n在这里先判断msg.callback是否为null，如果我们调用的Handler.post方法，那么这里就会执行`handleCallback`，否则再查看Handler.Callback是否为null，不为null则通过CallBack来处理本次事件，否则调用我们重写的handleMessage。\n\n## HandlerThread\n\n```java\n//创建子线程\n mCheckMsgThread = new HandlerThread(\"check-message-coming\");\n mCheckMsgThread.start(); \n//获取Handler\n mCheckMsgHandler = new Handler(mCheckMsgThread.getLooper())\n        {\n            @Override\n            public void handleMessage(Message msg)\n            {\n\t\t\t\t//网络请求操作\n            }\n        };\n//这样就能在主线程中根据UI的生命周期来控制HandlerThread了\n mCheckMsgHandler.sendEmptyMessage(MSG_UPDATE_INFO);//onResume\n mCheckMsgHandler.removeMessages(MSG_UPDATE_INFO);//onPause\n```\n\n\n\n# 内存泄露\n**[update:2018-02-07 10:36:06 ------------------------------------------------------]**\n\n不是说匿名内部类持有外部引用就会导致内存泄漏，而是因为他们的生命周期不同步。 \nmessage.target持有Handler，而Handler又持有Activity引用。 CallBack也一样，是Handler的成员，所以之前说的使用CallBack的方法根本不行，实际测试也是会导致内存泄露。\n\n![](http://owu391pls.bkt.clouddn.com/handlerleak.jpg)\n\n**[update:2018-02-07 10:36:06 ------------------------------------------------------]**\n\n通常我们在Activity中写Handler的时候都是如下的形式：\n\n```java\nHandler handler = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n        }\n    };\n```\nide这个时候会报一个内存泄露的警告，为什么呢？\n\n上面说过message.target就是发送该消息的Handler，而上述的Handler是Activity的一个匿名类，java中匿名类和non-static内部类会持有外部类的引用，即Activity。假设Activity被关闭了(**注意区分Activity生命周期和主线程的生命周期**)，但是MessageQueue中的消息还没被处理，那么消息队列中的message就会持有这个Handler的引用，Handler又持有Activity的引用，导致Activity无法被gc回收，导致内存泄漏。\n\n~~通过CallBack，来避免泄露的写法：~~  **这是错误的，正确用法是通过弱引用，详见参考**\n\n```java\nHandler handler = new Handler(new Handler.Callback() {\n        @Override\n        public boolean handleMessage(Message msg) {\n            return false;\n       }\n    });\n```\n\n通过静态内部类，也是官方推荐的：\n\n```java\n private static class MyHandler extends Handler {\n    private final WeakReference<SampleActivity> mActivity;\n\n    public MyHandler(SampleActivity activity) {\n      mActivity = new WeakReference<SampleActivity>(activity);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n      SampleActivity activity = mActivity.get();\n      if (activity != null) {\n        // ...\n      }\n    }\n  }\n\n  private final MyHandler mHandler = new MyHandler(this);\n```\n\n\n\n# 参考\n\n[ThreadLocal](http://blog.csdn.net/lufeng20/article/details/24314381)\n\n[官方对Handler泄露的处理](https://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html)\n\n[弱引用封装CallBack](https://www.jianshu.com/p/88cf7a923b56)\n","tags":["多线程"],"categories":["Android"]},{"title":"Android 系统启动流程","url":"/2017/12/08/Android启动流程/","content":"Android系统启动流程分析，基于6.0源码\n<!-- more -->\n# Android系统启动过程分析\n整个Android系统的启动分为Linux Kernel的启动和Android系统的启动。Linux Kernel启动起来后，然后运行第一个用户程序，在Android中就是init程序。Linux的启动也从其他文章copy到了本文后半段。\n## init.cpp\n源码路径:[/system/core/init/init.cpp](http://androidxref.com/6.0.1_r10/xref/system/core/init/init.cpp)\n```\nint main(int argc, char** argv) {\n\t...\n       if (is_first_stage) {\n        mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\");\n        mkdir(\"/dev/pts\", 0755);\n        mkdir(\"/dev/socket\", 0755);\n        mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL);\n        mount(\"proc\", \"/proc\", \"proc\", 0, NULL);\n        mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);\n    }\n    ...\n      if (!is_first_stage) {\n         // Indicate that booting is in progress to background fw loaders, etc.\n         close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000));\n         property_init();\n         ...\n     } \n \n     start_property_service();\n     init_parse_config_file(\"/init.rc\");\n     ...\n}\n```\n主要做了以下工作：\n- 在系统第一阶段(stage1)，挂载系统目录\n- 在第二阶段(stage2)，初始化属性服务（[property_service](http://androidxref.com/6.0.1_r10/xref/system/core/init/property_service.cpp)）\n- 分析并执行init.rc脚本\n\n## 解析zygote\n\n### init.rc\n位置：[/system/core/rootdir/init.rc](http://androidxref.com/6.0.1_r10/xref/system/core/rootdir/init.rc)\n先来分析一下init.rc，这是android系统的启动配置文件，包括Android的启动第一个应用进程zygote的执行命令也是这个文件中。解析部分文件内容如下：\n\n```\n11import /init.${ro.zygote}.rc\n12import /init.trace.rc\n13\n14 on early-init\n15    # Set init and its forked children's oom_adj.\n16    write /proc/1/oom_score_adj -1000\n17\n18    # Set the security context of /adb_keys if present.\n19    restorecon /adb_keys\n20\n21    start ueventd\n22\n23 on init\n24    sysclktz 0\n```\n\n值得注意的是跟之前的不同，`zygote`不再是直接写在文件中，而是通过`import`来导入，查看同级目录下有4个文件：\n\n- [init.zygote32.rc](http://androidxref.com/6.0.1_r10/xref/system/core/rootdir/init.zygote32.rc)   \n- [init.zygote32_64.rc](http://androidxref.com/6.0.1_r10/xref/system/core/rootdir/init.zygote32_64.rc) \n- [init.zygote64.rc](http://androidxref.com/6.0.1_r10/xref/system/core/rootdir/init.zygote64.rc) \n- [init.zygote64_32.rc](http://androidxref.com/6.0.1_r10/xref/system/core/rootdir/init.zygote64_32.rc) \n\n根据`ro.zygote`的值不同，来导入不同的文件，zygote64.rc内容：\n\n```cpp\n1 service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n2    class main    //声明service所属class的名字\n3    socket zygote stream 660 root system\n4    onrestart write /sys/android_power/request_state wake\n5    onrestart write /sys/power/state on\n6    onrestart restart media\n7    onrestart restart netd\n8    writepid /dev/cpuset/foreground/tasks\n```\n\n\n\ninit.rc文件包含五个类型的声明：\n\n- Action ：动作\n- Commands ：命令\n- Service ：服务\n- Options ：服务的参数\n- Import ：导入\n\n\n结合[keywords.h](http://androidxref.com/6.0.1_r10/xref/system/core/init/keywords.h)可以查看文件中诸如`class_start`、`import`等关键字对应的命令类型。在头文件中`on`和`service`关键字被定义为了`SECTION`类型。\n\n\n\n跟进上述init.cpp的`init_parse_config_file`方法，进入[init_parser.cpp](http://androidxref.com/6.0.1_r10/xref/system/core/init/init_parser.cpp#385)，在该方法内部实际调用了`parse_config`->` parse_new_section`，对zygote(service zygote)来说，主要是`parse_service`和`parse_line_service`两个方法。\n\n```cpp\n    case K_service:  \n        state->context = parse_service(state, nargs, args);  \n        if (state->context) {  \n            state->parse_line = parse_line_service;  \n            return;  \n        }  \n        break;  \n```\n\n### Service结构体\n\n在具体查看解析代码之前，先来介绍一下[Service](http://androidxref.com/6.0.1_r10/xref/system/core/init/init.h#95)这个结构，因为最后文件的内容都要被解析成相关的信息，而Service就是存储这些信息的结构体。\n\n```cpp\nstruct service {\n\t/*\n\t\t用来连接所有的services。Init中有一个全局的service_list变量，专门用来保存解析配置文件后得到的service。 \n\t*/\n    struct listnode slist;\n\n    const char *name;\t\t\t// service的名字，在我们的例子中为zygote\n    const char *classname;\t\t// service所属的class名字，默认为default\n\n    unsigned flags;\t\t\t// service的属性\n    pid_t pid;\t\t\t\t\t// 进程号\n    time_t time_started;    /* 上一次启动时间 */\n    time_t time_crashed;    /* 上一次死亡时间*/\n    int nr_crashed;         /* 死亡次数 */\n    \n    uid_t uid;\n    gid_t gid;\n    gid_t supp_gids[NR_SVC_SUPP_GIDS];\n    size_t nr_supp_gids;\n\n    char *seclabel;\n\t/*\n\t\t有些service需要使用socket来通信，下面这个socketinfo用来描述socket的相关信息。\n\t\t我们的zygote也使用了socket，配置文件中的内容是socket zygote stream 660 root system。\n\t\t它表示将创建一个AF_STREAM类型的socket（其实就是TCP socket），该socket的名为zygote，读写权限是660。\n\t*/\n    struct socketinfo *sockets;\n\t// service一般运行在一个单独的进程中，envvars用来描述创建这个进程时所需的环境\n\t// 变量信息。\n    struct svcenvinfo *envvars;\n\t/*\n\t\t虽然onrestart关键字是一个OPTION，可是这个OPTION后面一般都跟着一个COMMAND，action结构体就是用来存储command信息的。\n\t*/\n    struct action onrestart;  /* Actions to execute on restart. */\n    \n    /* keycodes for triggering this service via /dev/keychord */\n    int *keycodes;\n    int nkeycodes;\n    int keychord_id;\n\n\t// io优先级\n    int ioprio_class;\n    int ioprio_pri;\n\n    int nargs; \t// 参数个数\n    /* \"MUST BE AT THE END OF THE STRUCT\" */\n    char *args[1];\t// 用于存储参数内容\n};\nstruct action {  \n    /* \n        一个action结构可以被链入三个不同的双向链表中，其中alist用来存储所有的action， \n        qlist用来链接那些等待执行的action，tlist用来链接那些待某些条件满足后就需要执行的action。 \n    */      \n    /* node in list of all actions */  \n        struct listnode alist;  \n  \n        /* node in the queue of pending actions */  \n        struct listnode qlist;  \n  \n        /* node in list of actions for a trigger */  \n        struct listnode tlist;  \n  \n        unsigned hash;  \n        const char *name;   // 名字一般为\"onrestart\"  \n      \n    /* \n        一个command的结构列表，command结构如下： \n        struct command \n        { \n                /* list of commands in an action */  \n                struct listnode clist;  \n                int (*func)(int nargs, char **args);  \n                int nargs;  \n                char *args[1];  \n        };  \n    */  \n        struct listnode commands;  \n        struct command *current;  \n};\n```\n\n![](http://img.blog.csdn.net/20140730144405770?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHUzMTY3MzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n\n## 启动zygote\n\ninit.rc中有一段是\n\n```\n403 on boot\n...\n495 on nonencrypted\n496    class_start main\n497    class_start late_start\n```\n\n`class_start`是一个`COMMAND`，`main`是类名，上述zygote文件中line2通过`class main`来把类名修改为`main`，所以这里就是启动zygote服务所属的类。\n\n从[builtin.cpp](http://androidxref.com/6.0.1_r10/xref/system/core/init/builtins.cpp#112)的`do_class_start`一步步调用到[init.cpp](http://androidxref.com/6.0.1_r10/xref/system/core/init/init.cpp#service_start)的`service_start`方法。\n\n```cpp\n...\n262    pid_t pid = fork();\n354        if (!dynamic_args) {\n355            if (execve(svc->args[0], (char**) svc->args, (char**) ENV) < 0) {\n...\n357            }\n358        } else {\n...\n374            execve(svc->args[0], (char**) arg_ptrs, (char**) ENV);\n375        }\n376        _exit(127);\n...\n```\n\n通过`fork`以及调用`execve`来执行`/system/bin/app_process64`文件来创建zygote进程。\n\n\n\n# Linux系统启动过程分析\n\nLinux系统启动流程图如下:  \n\n![](http://images2015.cnblogs.com/blog/607348/201512/607348-20151229231206354-919070678.png)\n\n## BIOS\nBIOS(Basic Input/Output System)，基本输入输出系统，该系统存储于主板的ROM芯片上，计算机在开机时，会最先读取该系统。BIOS会按照启动顺序去查找第一个磁盘头的MBR信息，并加载和执行MBR中的Bootloader程序，若第一个磁盘不存在MBR，则会继续查找第二个磁盘，一旦BootLoader程序被检测并加载到内存中，BIOS就将控制权交接给了BootLoader程序。\n\n## MBR\n　　MBR(Master Boot Record)，主引导记录，MBR存储于磁盘的头部，大小为512bytes，其中，446bytes用于存储BootLoader程序，64bytes用于存储分区表信息，最后2bytes用于MBR的有效性检查。\n### BootLoader\n主要功能是初始化硬件设备、准备好软件环境，最后调用操作系统内核。  \n![](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=338703827,4227717080&fm=27&gp=0.jpg)\n- Bootloader：上电后第一个程序。\n- Boot parameters：分区中一般存放一些可设置的参数，比如IP地址、串口波特率，要传递给内核的命令行参数。\n- kernel：嵌入式板定制的内核，包含内核启动参数\n- Root filesystem文件系统：里面包含了linux能够运行的应用程序，和相关库等。\n\n\n## GRUB\nGRUB(Grand Unified Bootloader)，多系统启动程序，其执行过程可分为三个步骤：  \nStage1：这个其实就是MBR，它的主要工作就是查找并加载第二段Bootloader程序(stage2)，但系统在没启动时，MBR根本找不到文件系统，也就找不到stage2所存放的位置，因此，就有了stage1_5  \nStage1_5：该步骤就是为了识别文件系统  \nStage2：GRUB程序会根据/boot/grub/grub.conf文件查找Kernel的信息，然后开始加载Kernel程序，当Kernel程序被检测并在加载到内存中，GRUB就将控制权交接给了Kernel程序。\n## Kernel\nKernel，内核，Kernel是Linux系统最主要的程序，实际上，Kernel的文件很小，只保留了最基本的模块，并以压缩的文件形式存储在硬盘中，当GRUB将Kernel读进内存，内存开始解压缩内核文件。讲内核启动，应该先讲下initrd这个文件，initrd(Initial RAM Disk)，它在stage2这个步骤就被拷贝到了内存中，这个文件是在安装系统时产生的，是一个临时的根文件系统(rootfs)。因为Kernel为了精简，只保留了最基本的模块，因此，Kernel上并没有各种硬件的驱动程序，也就无法识rootfs所在的设备，故产生了initrd这个文件，该文件装载了必要的驱动模块，当Kernel启动时，可以从initrd文件中装载驱动模块，直到挂载真正的rootfs，然后将initrd从内存中移除。\n\n　　Kernel会以只读方式挂载根文件系统，当根文件系统被挂载后，开始装载第一个进程(用户空间的进程)，执行/sbin/init，之后就将控制权交接给了init程序。\n\n## init\ninit，初始化，该程序就是进行OS初始化操作，实际上是根据/etc/inittab(定义了系统默认运行级别)设定的动作进行脚本的执行，第一个被执行的脚本为/etc/rc.d/rc.sysinit，这个是真正的OS初始化脚本\n\n## Runlevel\nrunlevel，运行级别，不同的级别会启动的服务不一样，init会根据定义的级别去执行相应目录下的脚本，Linux的启动级别分为以下几种：  \n　　0：关机模式  \n　　1：单一用户模式(直接以管理员身份进入)  \n　　2：多用户模式（无网络）  \n　　3：多用户模式（命令行）  \n　　4：保留  \n　　5：多用户模式（图形界面）  \n　　6：重启  \n\n\n\n\n\n\n\n\n\n\n\n\n# 参考\n[Android启动分析](http://blog.csdn.net/hu3167343/article/details/38299969)\n\n[Linux启动过程](https://www.cnblogs.com/codecc/p/boot.html)  ","tags":["源码分析"],"categories":["Android"]},{"title":"注入之道(三) Inject和Hook","url":"/2017/12/01/inject-3-hook/","content":"\n使用Inject来把so库注入进程，在目标进程加载So库来替换函数表\n<!-- more -->\n\n# Inject\n\n## Ptrace\nPtrace是Unix/类Unix操作系统的一个系统调用，通过使用Ptrace可以让一个进程控制另一个进程，从而查看并修改的内部状态，通常是被用在debug或者代码分析等一系列辅助工具上。\n\n> 下文中执行Ptrace的进程统称为控制进程，被控制、被注入进程统称目标进程\n\nPtrace也是注入程序Inject的核心功能支撑，通过Ptrace来读取、修改目标进程的寄存器，控制目标进程的挂起、执行，来达到我们想要的目的，即在目标进程中加载我们自己写的so库。\n\nPtrace的方法就一个，根据不同的request对目标进程pid做不同的操作。\n```c\n\n\t// request: ptrace操作类型\n\t// pid_t  : 目标进程pid\n\t// addr   : 执行 peek 和 poke （内存读写）操作的目标地址\n\t// data   : 执行 poke 时作为数据写入到addr\n\t#include <sys/ptrace.h>\n    long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);\n```\n下面来介绍一下基本的几个`__ptrace_request`：\n- PTRACE_ATTACH ：attach到进程id为pid的进程\n- PTRACE_DETACH ：detach\n- PTRACE_GETREGS ：将目标进程寄存器值拷贝到 地址addr处\n- PTRACE_SETREGS ：将控制进程 地址addr处的数据写入到 目标进程 寄存器中\n- PTRACE_POKETEXT：将控制进程 地址data处数据 写入到 目标进程 地址addr处\n- PTRACE_PEEKTEXT：读取目标进程 addr处数据 并返回\n- PTRACE_CONT：让目标进程继续执行\n\n## 整体流程\n整个注入流程可以分为以下几点：\n1.通过Ptrace Attach到目标进程\n2.保存寄存器值（以便后续恢复现场）\n3.调用mmap申请内存空间，来存放要加载的so库的路径\n4.调用dlopen函数在目标进程中加载so库\n5.[-]调用dlsym函数返回 so库中 某个方法名的地址 \n6.[-]执行so库中的hook方法\n7.[-]调用dlclose关闭动态链接库（只有动态链接库的使用计数为0时,才会真正被卸载）\n8.恢复寄存器值\n9.Ptrace Detach\n\n其中567点不是必须的，如果so库的方法是so库的构造方法的话，形如：\n```c\nvoid __attribute__ ((constructor)) hooker_main() {\n\t...\n}\n```\n在加载完so库之后链接器会自动调用so的构造方法，就不需要特地的再去找某个方法的地址，手动去调用了。\n\n寄存器的保存和恢复比较简单，直接调用Ptrace的方法，下面主要讲一下方法地址的查找和执行。\n## 确定方法地址\n对于so文件来说，内部的函数一般分为导出函数和非导出函数，使用命令`nm -D xx.so`即可看到导出函数的偏移值，虽然每次加载so库的内存地址不同，但是偏移值是固定的。如果知道so文件的内存基址base_addr，那么base_addr+偏移值就是某个导出函数的内存地址。\nlibc.so的导出函数mmap的偏移值如下：\n```\nduoyi@duoyi-OptiPlex-7010:~/Desktop$ nm -D libc.so | grep mmap\n0000000000062a24 T mmap\n0000000000062a24 T mmap64\n```\n既然偏移值是确定的，那么可以得出下面的式子：\n`进程A中mmap函数地址 - 进程A的libc基址 = 进程B中mmap函数地址 - 进程B的libc基址`\n\n基于这样一个式子，我们在控制进程中，主动加载libc库，取得mmap函数地址，记为`local_base_addr`和`local_method_addr`。\n\n再通过遍历查询目标进程的内存映射文件，找到libc库在目标进程中的基址`remote_base_addr`，即可算出函数mmap地址`remote_base_addr`。目标进程的内存映射文件的位置为`/proc/pid/maps`，我这里用命令行来快速查看一下这样做的可行性，具体实现请看代码。\n\n```\n//权限\nroot@P635B32:/ # su\n//查找目标进程surfaceflinger的pid=268 \nroot@P635B32:/ # ps | grep surf\nsystem    268   1     307056 18256 ffffffff 829d8a4c S /system/bin/surfaceflinger\n//查看目标进程的maps  过滤libc.so\nroot@P635B32:/ # cat /proc/268/maps | grep libc.so\n7f82975000-7f82a25000 r-xp 00000000 b3:17 1959                           /system/lib64/libc.so\n7f82a25000-7f82a2c000 r--p 000b0000 b3:17 1959                           /system/lib64/libc.so\n7f82a2c000-7f82a2f000 rw-p 000b7000 b3:17 1959                           /system/lib64/libc.so\n```\n可以看到在进程`/system/bin/surfaceflinger`中libc.so的基址也是可以查到。\n\n## 执行方法\n先讲几个ARM中比较重要的几个寄存器：\n- PC ：总是指向下一条指令\n- SP ： 堆栈指针寄存器\n- LR ：链接寄存器，用来保存子程序的返回值\n- R0~R3 ：传参\n\n结合上述的`__ptrace_request`，基本可以想到执行方案的思路：\n使用`PTRACE_POKETEXT`修改寄存器PC值为要执行的方法地址`remote_method_add`。\n但是这样一旦修改完，调用`PTRACE_CONT`，目标进程就一直执行下去了，也不知道方法是否执行完成，所以就用到了LR寄存器。\n通过把LR寄存器手动置为0，当方法执行完成，跳转到LR寄存器时，目标进程尝试访问无效的内存引用，就会发生错误，进入暂停状态同时发送系统信号`SIGSEGV(#11)`。因此Ptrace就可以通过捕获这个错误，来达到既执行了方法，又没有丢失目标进程的控制的目的。\n下面结合代码来说明：\n```c\nbool Tracer::traceCall(void *addr, t_long *params, uint8_t num_params, arch_regs *regs) {\n    if (pid > 0) {\n        //把参数存到寄存器中\n        for (uint8_t i=0; i<num_params && i<MAX_PARAMETER_REGISTER; i++) \t\t{\n            regs->uregs[i] = params[i];\n        }\n\t\t//若参数个数超过MAX_PARAMETER_REGISTER 则把剩下的存到堆栈中\n        if (num_params > MAX_PARAMETER_REGISTER) {\n            size_t size = (num_params-MAX_PARAMETER_REGISTER)*sizeof(t_long);\n            regs->sp -= size;\n            traceWrite((uint8_t *) regs->sp, (uint8_t *) &params[MAX_PARAMETER_REGISTER], size);\n        }\n\t\t//调整pc寄存器 地址\n        regs->pc = (t_long)addr;\n      \n      \t//确定指令集，调整cpsr状态寄存器\n        if (regs->pc & 0x1) {\n            // thumb\n            regs->pc &= ~1u;\n            regs->cpsr |= CPSR_T_MASK;\n        } else {\n            // arm\n            regs->cpsr &= ~CPSR_T_MASK;\n        }\n      \n        //设置lr寄存器地址为0\n        regs->lr = 0;\n\t\t \n        if (traceSetRegs(regs) && traceContinue()) {\n            int stat = 0;\n            //WUNTRACED：当目标进程进入暂停状态时 waitpid返回\n            //stat：低8位 表示目标进程是退出(0x0)还是暂停(0x7f)\n          \t//      高8位 表示导致退出或暂停的信号值\n          \t// 0b7f 就表示 因系统信号11 导致进程暂停\n            waitpid(pid, &stat, WUNTRACED);\n            while (stat != 0xb7f) {\n                if (!traceContinue()) {\n                    LOGE(\"failed to traceCall (%d)\", pid);\n                    return false;\n                }\n                waitpid(pid, &stat, WUNTRACED);\n            }\n            return true;\n        }\n    }\n    LOGE(\"failed to traceCall (%d)\", pid);\n    return false;\n}\n```\n\n\n\n这样我们就能够在目标进程中调用特定的方法了，同理适用于`dlopen`，这就不再赘述，下面主要讲so被加载之后，是如何Hook来替换函数。\n\n\n\n# ElfHook\n在对ELF文件格式有了大致的认识之后，我们就可以基于ELF文件的执行视图，来进行ElfHook，整体思路也是参考linker加载so库的流程，如果对于linker加载so库的流程比较熟悉的话那对ElfHook应该也不陌生。\n> 分析是基于32位的ELF文件格式，代码中兼容了64位。\n\n## 整体流程\n先来快速的过一下Hook流程：\n1.读取ELF文件头，获取程序头表位置等信息\n2.遍历程序头表，找到类型为PT_DYNAMIC的段区，动态链接段\n3.再遍历动态链接段区，获得不同类型的节区，初始化相关参数\n4.根据传入的符号值`symbol`，经过哈希计算得出该符号在`符号表(.dynsym)`的索引值，根据索引值获取`符号表`的`st_name`(非0即为该符号在`字符串表(.dynstr)`中的索引即`symidx`)\n5.遍历重定位表`pltrel`和`rel`，计算每个表项在`字符串表`的索引值等于`symidx`的重定位表项，并从该表项中得到对应的地址`addr`(这个地址里存放的 是`symbol`函数的实际地址)\n6.获取`addr`所在页的起始地址，修改改页的读写权限\n7.取出`addr`中`symbol`实际地址，保存到`old_addr`备用，将我们自己写的函数的地址`new_addr`写入`addr`中\n8.系统调用，清除缓存，保证替换生效\n\n基本流程如上，就是照着ELF文件的格式来解析，规则很死，下面主要讲之前做错的和报错比较多的地方。\n\n## 哈希查找\n通过计算`symbol`的哈希值，查找哈希表得到索引值`symidx`。\n目前ELF有2种Hash表，一种就是DT_HASH，详见`ELF文件格式系统3.8.6`，另一种就是DT_GNU_HASH，详见参考。\n如果哈希表的类型是DT_GNU_HASH时，是存在`symbol`通过GNU_HASH无法找到对应的`symidx`的，根据文档原文解释，`symndx`是能被GNU_HASH找到的第一个符号的索引值。假设符号表的项数为`dynsymcount`，那么可以被找到的项数为`dynsymcount-symndx`。所以当通过GNU_HASH无法找到的时候，就要手动遍历符号表的`前symndx`项来计算`symidx`，部分代码如下：\n```c\n\t\tif (0 == gnuLookup(symbol, sym, symidx)) {\n            return 0;\n        }\n\n        ElfW(Sym) *curr;\n        for(uint32_t i=0; i<this->gnuSymndx; i++) {\n            curr = this->symTable + i;\n            if (0 == strcmp(this->strTable+curr->st_name, symbol)) {\n                *symidx = i;\n                *sym = curr;\n                return 0;\n            }\n        }\n        LOGE(\"not found %s in %s before gnu symbol index %d\", symbol, this->moduleName, this->gnuSymndx);\n        return -1;\n```\n\n\n## 基址偏移计算\n先来看看6.0源码中[Linker](http://androidxref.com/6.0.1_r10/xref/bionic/linker/linker_phdr.cpp#307)加载so库的时候，ElfReader为so库分配内存空间的部分代码:\n```c\n307  bool ElfReader::ReserveAddressSpace(const android_dlextinfo* extinfo) {\n308    ElfW(Addr) min_vaddr;\n309    load_size_ = phdr_table_get_load_size(phdr_table_, phdr_num_, &min_vaddr);\n  \t\t...\n315    uint8_t* addr = reinterpret_cast<uint8_t*>(min_vaddr);\n316    void* start;\n  \t\t...\n341    int mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;\n342    start = mmap(mmap_hint, load_size_, PROT_NONE, mmap_flags, -1, 0);\n  \t\t...\n351    load_start_ = start;\n352    load_bias_ = reinterpret_cast<uint8_t*>(start) - addr;\n353    return true;\n354  }\n```\n\n这段代码先是计算了so库需要的空间，然后调用系统函数mmap来映射。\n\n> 值得注意的是`min_vaddr`，通常情况下SO是不会指定加载的基址，即min_vaddr=0。但是如果SO指定了加载基址，并且地址不是页对齐的，就会导致实际映射地址与指定加载地址有偏差，这个偏差值就是`load_bias_`，所以在针对虚拟地址计算的时候需要使用`load_bias_`来修正。\n\n\n\n而Linker也有计算`load_bias`地址的方法，代码中计算值也是跟这个一样的原理：\n\n```\n3329/* Compute the load-bias of an existing executable. This shall only\n3330 * be used to compute the load bias of an executable or shared library\n3331 * that was loaded by the kernel itself.\n3332 *\n3333 * Input:\n3334 *    elf    -> address of ELF header, assumed to be at the start of the file.\n3335 * Return:\n3336 *    load bias, i.e. add the value of any p_vaddr in the file to get\n3337 *    the corresponding address in memory.\n3338 */\n3339  static ElfW(Addr) get_elf_exec_load_bias(const ElfW(Ehdr)* elf) {\n3340    ElfW(Addr) offset = elf->e_phoff;\n3341    const ElfW(Phdr)* phdr_table =\n3342    reinterpret_cast<const ElfW(Phdr)*>(reinterpret_cast<uintptr_t>(elf) + offset);\n3343    const ElfW(Phdr)* phdr_end = phdr_table + elf->e_phnum;\n3344\n3345    for (const ElfW(Phdr)* phdr = phdr_table; phdr < phdr_end; phdr++) {\n3346      if (phdr->p_type == PT_LOAD) {\n3347        return reinterpret_cast<ElfW(Addr)>(elf) + phdr->p_offset - phdr->p_vaddr;\n3348      }\n3349    }\n3350    return 0;\n3351  }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 参考\n[Ptrace](https://en.wikipedia.org/wiki/Ptrace)\n[ Android Hook学习之ptrace函数的使用](http://blog.csdn.net/qq1084283172/article/details/45967633)\n[ptrace函数详解  ](http://blog.163.com/yuanxiaohei@126/blog/static/6742308720123683433989/)\n[arm 寄存器](https://www.cnblogs.com/xiaojinma/archive/2012/12/19/2825481.html)\n[waitpid之status意义解析 ](http://tsecer.blog.163.com/blog/static/15018172012323975152/)\n[gnu_hash](https://blogs.oracle.com/ali/gnu-hash-elf-sections)\n[Linker和So加壳](http://dev.qq.com/topic/57e3a3bc42eb88da6d4be143)\n[Android的so注入( inject)和函数Hook(基于got表)](http://blog.csdn.net/QQ1084283172/article/details/53942648?locationNum=1&fps=1)\n","tags":["注入"],"categories":["Android逆向安全"]},{"title":"注入之道(二) so文件加载流程","url":"/2017/11/28/inject-2-so/","content":"乱贴源码系列：结合Android6.0源码[linker.cpp](http://androidxref.com/6.0.1_r10/xref/bionic/linker/linker.cpp)来学习一下so库的加载流程\n<!-- more -->\n# so的加载和链接\n## 整体流程\n### System.load\n通常我们要在代码中使用so库的话，都要在静态块手动的去载入so库，形如：\n```\n    static {\n        System.loadLibrary(\"native-lib\");\n    }\n```\n跟进代码，会一直走到`java.lang.Runtime`包下的native方法\n`nativeLoad`,再到源码中的[java_lang_Runtime.cc](http://androidxref.com/6.0.1_r10/xref/art/runtime/native/java_lang_Runtime.cc#70)中的`Runtime_nativeLoad`,然后跳转到[java_vm_ext.cc](http://androidxref.com/6.0.1_r10/xref/art/runtime/java_vm_ext.cc#596)的`LoadNativeLibrary`，在line645调用了dlopen:\n```\n643  Locks::mutator_lock_->AssertNotHeld(self);\n644  const char* path_str = path.empty() ? nullptr : path.c_str();\n645  void* handle = dlopen(path_str, RTLD_NOW);\n```\n看到dlopen基本就是跳转到linker下执行了，`dlopen`是linker目录下的[dlfcn.cpp](http://androidxref.com/6.0.1_r10/xref/bionic/linker/dlfcn.cpp)的函数:\n```\n70\tstatic void* dlopen_ext(const char* filename, int flags, const android_dlextinfo* extinfo) {\n71\t  ScopedPthreadMutexLocker locker(&g_dl_mutex);\n72\t  soinfo* result = do_dlopen(filename, flags, extinfo);\n73\t  if (result == nullptr) {\n74  \t  __bionic_format_dlerror(\"dlopen failed\", linker_get_error_buffer());\n75 \t   return nullptr;\n76 \t }\n77 \t return result;\n78\t }\n79\n80\tvoid* android_dlopen_ext(const char* filename, int flags, const android_dlextinfo* extinfo) {\n81\t  return dlopen_ext(filename, flags, extinfo);\n82\t}\n83\n84\tvoid* dlopen(const char* filename, int flags) {\n85\t  return dlopen_ext(filename, flags, nullptr);\n86\t}\n```\n自下往上，最后调用到[linker.cpp](http://androidxref.com/6.0.1_r10/xref/bionic/linker/linker.cpp#1676)的`do_dlopen`。\n### do_dlopen\n```\n\t  ...\n1694  ProtectedDataGuard guard;\n1695  soinfo* si = find_library(name, flags, extinfo);\n1696  if (si != nullptr) {\n1697    si->call_constructors();\n1698  }\n1699  return si;\n```\n前面做了一堆非空值的判断，然后调用了一个`ProtectedDataGuard`类的`protect_data`方法\n```\n791class ProtectedDataGuard {\n792 public:\n793  ProtectedDataGuard() {\n794    if (ref_count_++ == 0) {\n795      protect_data(PROT_READ | PROT_WRITE);\n796    }\n797  }\n798\n799  ~ProtectedDataGuard() {\n800    if (ref_count_ == 0) { // overflow\n801      __libc_fatal(\"Too many nested calls to dlopen()\");\n802    }\n803\n804    if (--ref_count_ == 0) {\n805      protect_data(PROT_READ);\n806    }\n807  }\n808 private:\n809  void protect_data(int protection) {\n810    g_soinfo_allocator.protect_all(protection);\n811    g_soinfo_links_allocator.protect_all(protection);\n812  }\n813\n814  static size_t ref_count_;\n815};\n816\n```\n最后通过`LinkerTypeAllocator`调用到`LinkerBlockAllocator`的`protect_all`，实际上调的是系统函数`mprotect`来修改页的读写属性。\n```\n89void LinkerBlockAllocator::protect_all(int prot) {\n90  for (LinkerBlockAllocatorPage* page = page_list_; page != nullptr; page = page->next) {\n91    if (mprotect(page, PAGE_SIZE, prot) == -1) {\n92      abort();\n93    }\n94  }\n95}\n```\nok，回归正文，刚才`do_dlopen`最主要一行代码，通过find_library就完成了so的加载，返回一个结构体soinfo，然后调用这个soinfo的call_constructors()方法，即so库的构造函数，来完成so的加载。\n```\n1695  soinfo* si = find_library(name, flags, extinfo);\n1696  if (si != nullptr) {\n1697    si->call_constructors();\n1698  }\n```\n### soinfo\n在进入find_library之前先介绍一下表示一个so库的信息的结构体[soinfo](http://androidxref.com/6.0.1_r10/xref/bionic/linker/linker.h#172)  \n我很想把代码都贴上来，但是那样凑字数意图太明显，我还是贴个简单版的\n```\nstruct soinfo{\n    char old_name_[SOINFO_NAME_LEN];\n    const ElfW(Phdr)* phdr;\n    size_t phnum;\n    ElfW(Addr) entry;\n    ElfW(Addr) base;\n    size_t size;\n    ElfW(Dyn)* dynamic;\n\n    //以下与.hash表有关\n    unsigned nbucket;\n    unsigned nchain;\n    unsigned *bucket;\n    unsigned *chain;\n    \n    //以下与.gnu_hash表有关\n    size_t gnu_nbucket_;\n    uint32_t* gnu_bucket_;\n    uint32_t* gnu_chain_;\n    uint32_t gnu_maskwords_;\n    uint32_t gnu_shift2_;\n    ElfW(Addr)* gnu_bloom_filter_;\n}\n```\n`phdr`在之前的ELF文件格式执行视图中已经介绍过了，就是程序头表，dynamic就是动态节区，特别注意有2个hash表相关的，这个放到后续我们hook的时候会再细说，主要是有个印象，知道符号查找不一定是根据hash表来，还有个gnuhash。\n\n### find_library\n内部调用`find_libraries`->`find_library_internal`->`load_library`->`load_library`，做一系加载，预链接，已加载判断等，在6个参数的[load_library](http://androidxref.com/6.0.1_r10/xref/bionic/linker/linker.cpp#1252)中开始通过ElfReader这个类来读取so文件信息并赋值到soinfo中来实现so文件加载到内存中。\n```\n1303  // Read the ELF header and load the segments.\n1304  ElfReader elf_reader(realpath.c_str(), fd, file_offset, file_stat.st_size);\n1305  if (!elf_reader.Load(extinfo)) {\n1306    return nullptr;\n1307  }\n1308\n1309  soinfo* si = soinfo_alloc(realpath.c_str(), &file_stat, file_offset, rtld_flags);\n1310  if (si == nullptr) {\n1311    return nullptr;\n1312  }\n1313  si->base = elf_reader.load_start();\n1314  si->size = elf_reader.load_size();\n1315  si->load_bias = elf_reader.load_bias();\n1316  si->phnum = elf_reader.phdr_count();\n1317  si->phdr = elf_reader.loaded_phdr();\n```\n\n## 加载\n### ElfReader\nElfReader的定义在[linker_phdr](http://androidxref.com/6.0.1_r10/xref/bionic/linker/linker_phdr.cpp#136)中，就是通过解析so库的执行视图，来读取so文件的各种信息，因为后续介绍的hook的时候也是根据这里的思路来进行的。\n### Load\n根据上面的`load_library`代码，可以看到先执行了ElfReader的Load方法，如下：\n```\n149bool ElfReader::Load(const android_dlextinfo* extinfo) {\n150  return ReadElfHeader() &&\n151         VerifyElfHeader() &&\n152         ReadProgramHeader() &&\n153         ReserveAddressSpace(extinfo) &&\n154         LoadSegments() &&\n155         FindPhdr();\n156}\n```\n很完美，读取头文件-验证-读取程序头-分配内存空间-加载段区-查找程序头表项。\n每个步骤在参考中的**Linker与So加壳技术**都有说明，规则都很死，读取文件信息，找偏移，读取正确位置即可，我这里只强调一下分配空间这个步骤。\n```\n307bool ElfReader::ReserveAddressSpace(const android_dlextinfo* extinfo) {\n308  ElfW(Addr) min_vaddr;\n309  load_size_ = phdr_table_get_load_size(phdr_table_, phdr_num_, &min_vaddr);\n\n\n315  uint8_t* addr = reinterpret_cast<uint8_t*>(min_vaddr);\n316  void* start;\n\n341  int mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;\n342  start = mmap(mmap_hint, load_size_, PROT_NONE, mmap_flags, -1, 0);\n\n351  load_start_ = start;\n352  load_bias_ = reinterpret_cast<uint8_t*>(start) - addr;\n353  return true;\n354}\n```\n这段代码先是计算了so库在内存中需要的空间，然后调用系统函数`mmap`来映射。\n在line352有个变量`load_bias_`，他的值是start-addr，这个addr的值是`min_vaddr`，这是so库在加载的时候指定的加载基址，通常来说这个值为0，对，通常来说。\n在Android4.4及其之前的版本，load_bias_=load_start，但是在Anroid6.0（5.0没有机子测试）之后，min_vaddr不为0，所以load_bias_要做一个修正：\n```\nload_bias_ = reinterpret_cast<uint8_t*>(start) - addr;\n```\n在linker的line3339也可以看到，可以计算load_bias\n```\n3329/* Compute the load-bias of an existing executable. This shall only\n3330 * be used to compute the load bias of an executable or shared library\n3331 * that was loaded by the kernel itself.\n3332 *\n3333 * Input:\n3334 *    elf    -> address of ELF header, assumed to be at the start of the file.\n3335 * Return:\n3336 *    load bias, i.e. add the value of any p_vaddr in the file to get\n3337 *    the corresponding address in memory.\n3338 */\n3339static ElfW(Addr) get_elf_exec_load_bias(const ElfW(Ehdr)* elf) {\n3340  ElfW(Addr) offset = elf->e_phoff;\n3341  const ElfW(Phdr)* phdr_table =\n3342      reinterpret_cast<const ElfW(Phdr)*>(reinterpret_cast<uintptr_t>(elf) + offset);\n3343  const ElfW(Phdr)* phdr_end = phdr_table + elf->e_phnum;\n3344\n3345  for (const ElfW(Phdr)* phdr = phdr_table; phdr < phdr_end; phdr++) {\n3346    if (phdr->p_type == PT_LOAD) {\n3347      return reinterpret_cast<ElfW(Addr)>(elf) + phdr->p_offset - phdr->p_vaddr;\n3348    }\n3349  }\n3350  return 0;\n3351}\n```\n这个在后续的hook也是参考上述方法来得到实际的地址。\n\n## 链接\n在加载完毕之后，在line1319来执行预链接[perlink_image](http://androidxref.com/6.0.1_r10/xref/bionic/linker/linker.cpp#2499)方法来链接。\n```\n2499bool soinfo::prelink_image() {\n2500  /* Extract dynamic section */\n2501  ElfW(Word) dynamic_flags = 0;\n2502  phdr_table_get_dynamic_section(phdr, phnum, load_bias, &dynamic, &dynamic_flags);\n\n2527  // Extract useful information from dynamic section.\n2528  // Note that: \"Except for the DT_NULL element at the end of the array,\n2529  // and the relative order of DT_NEEDED elements, entries may appear in any order.\"\n2530  //\n2531  // source: http://www.sco.com/developers/gabi/1998-04-29/ch5.dynamic.html\n2533  for (ElfW(Dyn)* d = dynamic; d->d_tag != DT_NULL; ++d) {\n\t\t...\t\n      }\n```\n### 定位动态节区\n通过[phdr_table_get_dynamic_section](http://androidxref.com/6.0.1_r10/xref/ndk/sources/android/crazy_linker/src/linker_phdr.cpp#380)来找到type为`PT_DYNAMIC`的动态节区。\n\n然后再遍历解析，获取重定位相关的各种信息（DT_SYMTAB DT_HASH等）。\n\n### 遍历动态节区\n找到动态节区之后，遍历来根据节区的结构体成员d_tag，确定需要用到的各种参数，各种节区，别如DT_PLTRELSZ就是与重定位有关的，DT_HASH DT_GNU_HASH就是和符号表索引相关的，DT_INIT就是初始化相关的节。\n### 重定位\n\n在prelink_image之后，回到`find_libraries`函数中，line1527调用了[linke_image](http://androidxref.com/6.0.1_r10/xref/ndk/sources/android/crazy_linker/src/linker_phdr.cpp#2924)方法,内部调用[relocate](http://androidxref.com/6.0.1_r10/xref/bionic/linker/linker.cpp#1840)函数  \n\n解析完信息之后，就要遍历重定位表，来重定位每个符号的实际地址。\n占坑，放在（三）中和hook原理一起讲解。\n\n# 参考\n[Android Linker 与 SO 加壳技术](http://blog.csdn.net/tencent_bugly/article/details/52668772)\n","tags":["注入"],"categories":["Android逆向安全"]},{"title":"BaseActivity/BaseToolBarActivity","url":"/2017/11/25/baseactivity/","content":"基类Activity的构建模板\n<!-- more -->\n\n## BaseActivity\n```java\n\n\npublic abstract class BaseActivity extends AppCompatActivity {\n\n    private Unbinder mUnbinder;\n\n//    protected BasePresenter mPresenter;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(getLayoutID());\n\n        mUnbinder = ButterKnife.bind(this);\n\n        setTranslucentStatus();\n\n        initBundle(savedInstanceState);\n//        initPresenter();\n        initView();\n        initData();\n    }\n\n    protected void initPresenter() {\n//        mPresenter = getPresenter();\n    }\n//\n//    protected BasePresenter getPresenter() {\n//        return null;\n//    }\n\n    protected void initBundle(Bundle savedInstanceState) {\n\n    }\n\n    protected void saveBundle(Bundle outState) {\n\n    }\n\n\n    protected abstract int getLayoutID();\n\n    @Override\n    protected void onPostCreate(@Nullable Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        if (mUnbinder != null) {\n            mUnbinder.unbind();\n        }\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        saveBundle(outState);\n//        Logger.d(\"onSaveInstanceState\");\n    }\n\n    protected void initView() {\n\n    }\n\n\n    protected void initData() {\n\n    }\n}\n\n```\n\n## BaseToolBarActivity\n```java\n\npublic abstract class BaseToolBarActivity extends BaseActivity {\n\n\n\n    private Toolbar mToolBar;\n    //根布局\n    private LinearLayout mRootView = null;\n    //子Activity原布局\n    private View mContentView = null;\n\n\n    /**\n     * 根据子类传入的布局ID来获取View，在该View外面增加一个LL和ToolBar再setContentView\n     * @param layoutResID 子类重写BaseActivity的getLayoutID\n     */\n    @Override\n    public void setContentView(int layoutResID) {\n        mContentView = LayoutInflater.from(this).inflate(layoutResID,null);\n        initDectorView();\n        super.setContentView(mRootView);\n    }\n\n\n    /**\n     * 初始化根布局\n     */\n    private void initDectorView() {\n        mRootView = new LinearLayout(this);\n        mRootView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n                ViewGroup.LayoutParams.MATCH_PARENT));\n        mRootView.setOrientation(LinearLayout.VERTICAL);\n        initToolBar();\n        mRootView.addView(mToolBar);\n        mRootView.addView(mContentView);\n    }\n\n    /**\n     * 初始化ToolBar\n     */\n    private void initToolBar() {\n        mToolBar = (Toolbar) getLayoutInflater().inflate(R.layout.layout_toolbar,mRootView,false);\n        setCustomToolbar(mToolBar);\n    }\n\n    /**\n     * 子类自行扩展设置属性\n     * @param toolbar\n     */\n    protected abstract void setCustomToolbar(Toolbar toolbar);\n\n}\n\n```\n\n\n## BaseFragment\n主要注意有个Bundle和setArguments的用法\n```java\npublic abstract class BaseFragment extends Fragment {\n\n    protected LayoutInflater mInflater;\n    protected Context mContext;\n    protected View mRoot;\n    protected Bundle mBundle;//获取setArguments的值\n    protected Unbinder mUnbinder;\n\n    @Override\n    public void onAttach(Context context) {\n        mContext =context;\n        super.onAttach(context);\n    }\n\n\n\n    @Override\n    public void onDetach() {\n        mContext = null;\n        super.onDetach();\n\n    }\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mBundle = getArguments();\n        initBundle(mBundle);\n\n\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        if(mUnbinder!=null){\n            mUnbinder.unbind();\n        }\n\n\n    }\n\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        mInflater = inflater;\n        mRoot = inflater.inflate(getLayoutId(),container,false);\n        mUnbinder = ButterKnife.bind(this,mRoot);\n\n        initWidget(mRoot);\n        initData();\n\n\n\n\n        return mRoot;\n    }\n\n\n\n\n    protected abstract int getLayoutId();\n\n    protected void initBundle(Bundle bundle) {\n\n    }\n\n    protected void initWidget(View root) {\n\n\n    }\n\n    protected void initData() {\n\n\n    }\n}\n```\n","tags":["Base"],"categories":["Android代码库"]},{"title":"注入之道(一) ELF格式分析","url":"/2017/11/19/inject-1-elf/","content":"32位ELF(可执行可链接文件)格式的分析\n<!-- more -->\n# 目标文件 Object File\n一个简单的c文件，经过预处理-编译-汇编-链接，四个耳熟能详的步骤后，就变成了一个可执行的目标文件。  \n目标文件有三种形式：\n- 可重定位文件（Relocatable file）：这是由汇编器汇编生成的.o文件，链接器会使用一个或多个的可重定位文件作为输入，生成一个可执行文件\n- 可执行文件（Executable file）：可以直接复制到内存中执行的文件\n- 可共享文件（Shared Object file）：也是Android中常说的so库。所谓的动态库文件，在运行时被动态的加载进内存，由动态链接器来负责链接so库和可执行文件的执行。\n\n这些目标文件都是按照特定的文件格式来组织的，比如Windows下是PE，Mac下是Mach-O，Linux/unix下就是ELF格式。  \n这里主要就是以Linux下的so文件格式ELF来做分析，因为在逆向APK中主要也是针对so库做注入。\n# EFL文件格式\n先放2张图，可以直观的了解ELF文件格式\n![](http://blog.chinaunix.net/photo/94212_101201164532.jpg)\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1511088380577&di=7d77512485a60706d6fd1ab9f949f7af&imgtype=0&src=http%3A%2F%2Fwww.yeolar.com%2Fmedia%2Fnote%2F2012%2F03%2F20%2Flinux-linking%2Ffig2.png)\n\n## 结构综述\n- ELF文件头 ： 对ELF文件整体结构的一个描述\n- 程序头部表 Program Header Table ：描述下面的段区Segment，告诉系统如何创建进程影像\n- 节区Section ：section从链接角度具体描述这个elf文件\n- 段区Segment ：segment是从运行角度来描述这个elf文件，segment包含多个section\n- 节区头部表 Section Header Table ：描述上面的各个节区Section的属性信息\n\n\n\n\n**为什么要区别节区和段区？**\n\n> 当ELF文件被加载到内存中后，系统会将多个具有相同权限（flag值）section合并一个segment。操作系统往往以页为基本单位来管理内存分配，一般页的大小为4096B，即4KB的大小。同时，内存的权限管理的粒度也是以页为单位，页内的内存是具有同样的权限等属性，并且操作系统对内存的管理往往追求高效和高利用率这样的目标。ELF文件在被映射时，是以系统的页长度为单位的，那么每个section在映射时的长度都是系统页长度的整数倍，如果section的长度不是其整数倍，则导致多余部分也将占用一个页。而我们从上面的例子中知道，一个ELF文件具有很多的section，那么会导致内存浪费严重。这样可以减少页面内部的碎片，节省了空间，显著提高内存利用率。\n\n\n\n# 分析\n下面我就结合linux的命令`readelf`来分析Android的GUI系统中使用的`/system/lib/libsurfaceflinger.so`文件来逐一介绍EFL文件 节区头部表 与一些与重定位相关的节区。\n\n> Android 4.4 32位所以结构体都是ELF32开头，64位的文件格式即为ELF64 \n\n## ELF文件头\nELF文件头对应的结构体Elf32_Ehdr如下：\n```\n#define EI_NIDENT 16\ntypedef struct {\n       unsigned char e_ident[EI_NIDENT];\n       ELF32_Half e_type;\n       ELF32_Half e_machine;\n       ELF32_Word e_version;\n       ELF32__Addr e_entry;\n       ELF32_Off e_phoff;\n       ELF32_Off e_shoff;\n       ELF32_Word e_flags;\n       ELF32_Half e_ehsize;\n       ELF32_Half e_phentsize;\n       ELF32_Half e_phnum;\n       ELF32_Half e_shentsize;\n       ELF32_Half e_shnum;\n       ELF32_Half e_shstrndx;\n}Elf32_Ehdr;\n```\n使用`readelf -h libsurfaceflinger.so `可以让系统来自动解析文件头hex值对应的实际意义\n```\nduoyi@duoyi-OptiPlex-7010:~/Desktop/todo$ readelf -h libsurfaceflinger.so \nELF 头：\n  Magic：   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  类别:                              ELF32\n  数据:                              2 补码，小端序 (little endian)\n  版本:                              1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI 版本:                          0\n  类型:                              DYN (共享目标文件)\n  系统架构:                          ARM\n  版本:                              0x1\n  入口点地址：               0x0\n  程序头起点：          52 (bytes into file)\n  节区头起点:          201044 (bytes into file)\n  标志：             0x5000000, Version5 EABI\n  本头的大小：       52 (字节)\n  程序头大小：       32 (字节)\n  程序头表项数:         8\n  节头大小：         40 (字节)\n  节头数量：         24\n  字符串表索引节头： 23\n\n```\n\n## “节”头表\n同样的，节区头部表的表项对应的结构体Elf32_Shdr如下：\n```\n typedef struct elf32_shdr { \n          Elf32_Word    sh_name;  \n          Elf32_Word    sh_type; \n          Elf32_Word    sh_flags; \n          Elf32_Addr    sh_addr;    //在内存中的虚地址\n          Elf32_Off     sh_offset;   //对应的Section在文件中的偏移\n          Elf32_Word    sh_size; \n          Elf32_Word    sh_link; \n          Elf32_Word    sh_info; \n          Elf32_Word    sh_addralign; \n          Elf32_Word    sh_entsize; \n        } Elf32_Shdr; \n```\n可能说的有点绕，节区头部表本身就含有多个项，每个项对应着上面说的Section，一个是表，一个是项，一个节区头表，含有多个节区项的描述结构体，该结构体就是Elf32_Shdr。那么这个节区头表的位置我们是如何确定的呢，这是在ELF文件头中确定的，往上看可以找到\n```\n  节区头起点:          201044 (bytes into file)\n```\n这个是起始位置，结束位置一般就是文件末尾。201044对应的16进制值为0x31154，我们使用命令`readelf -S libsurfaceflinger.so `来解析节区头看看：\n```\nduoyi@duoyi-OptiPlex-7010:~/Desktop/todo$ readelf -S libsurfaceflinger.so \n共有 24 个节头，从偏移量 0x31154 开始：\n\n节头：\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .interp           PROGBITS        00000134 000134 000013 00   A  0   0  1\n  [ 2] .dynsym           DYNSYM          00000148 000148 0020a0 10   A  3   1  4\n  [ 3] .dynstr           STRTAB          000021e8 0021e8 00454c 00   A  0   0  1\n  [ 4] .hash             HASH            00006734 006734 001054 04   A  2   0  4\n  [ 5] .rel.dyn          REL             00007788 007788 0069f0 08   A  2   0  4\n  [ 6] .rel.plt          REL             0000e178 00e178 000f08 08   A  2   7  4\n  [ 7] .plt              PROGBITS        0000f080 00f080 0016a0 00  AX  0   0  4\n  [ 8] .text             PROGBITS        00010720 010720 015828 00  AX  0   0  8\n  [ 9] .ARM.exidx        ARM_EXIDX       00025f48 025f48 001958 08  AL  8   0  4\n  [10] .ARM.extab        PROGBITS        000278a0 0278a0 000390 00   A  0   0  4\n  [11] .rodata           PROGBITS        00027c30 027c30 002ca8 00   A  0   0  4\n  [12] .data.rel.ro.loca PROGBITS        0002c7d8 02b7d8 000108 00  WA  0   0  8\n  [13] .fini_array       FINI_ARRAY      0002c8e0 02b8e0 000004 00  WA  0   0  4\n  [14] .init_array       INIT_ARRAY      0002c8e4 02b8e4 000018 00  WA  0   0  4\n  [15] .data.rel.ro      PROGBITS        0002c900 02b900 004d80 00  WA  0   0  8\n  [16] .dynamic          DYNAMIC         00031680 030680 000150 08  WA  3   0  4\n  [17] .got              PROGBITS        000317d4 0307d4 00082c 00  WA  0   0  4\n  [18] .data             PROGBITS        00032000 031000 000009 00  WA  0   0  4\n  [19] .bss              NOBITS          0003200c 031009 000098 00  WA  0   0  4\n  [20] .comment          PROGBITS        00000000 031009 000010 01  MS  0   0  1\n  [21] .note.gnu.gold-ve NOTE            00000000 03101c 00001c 00      0   0  4\n  [22] .ARM.attributes   ARM_ATTRIBUTES  00000000 031038 00003a 00      0   0  1\n  [23] .shstrtab         STRTAB          00000000 031072 0000e0 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n\n```\n可以看到打印出来的第一行信息和我们根据ELF文件头算出来的一样。  \n可以看到输出了很多个表项，每个表项的结构就是上述的Elf32_Shdr了，下面挑几个相关的来讲。  \n### 符号表 .dynsym\n符号表包含用来定位、重定位程序中符号定义和引用的信息，简单的理解就是符号表记录了该文件中的所有符号。所谓的符号就是经过修饰了的函数名或者变量名，不同的编译器有不同的修饰规则。例如符号_ZL15global_static_a，就是由global_static_a变量名经过修饰而来。  \n通过命令`readelf -s libsurfaceflinger.so `来查看.dynsym的Section内容\n```\nduoyi@duoyi-OptiPlex-7010:~/Desktop/todo$ readelf -s libsurfaceflinger.so \n\nSymbol table '.dynsym' contains 522 entries:\n   Num:    Value  Size Type    Bind   Vis      Ndx Name\n     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize\n     2: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit\n     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __aeabi_unwind_cpp_pr0\n     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND _ZNK7android22ISurfaceCom\n     5: 00000000     0 FUNC    GLOBAL DEFAULT  UND _ZN7android10VectorImpl13\n     6: 00000000     0 FUNC    GLOBAL DEFAULT  UND _ZN7android16SortedVector\n\t ...\n     520: 00032009     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start\n     521: 000320a4     0 NOTYPE  GLOBAL DEFAULT  ABS _end\n\n```\n也可以通过`readelf -p [sectionIdx] libsurfaceflinger.so `来以string的方式查看指定序号的Section内容，值没有经过格式化，比如这里的.dynsym序号是2，那么`readelf -p 2 libsurfaceflinger.so`输出的内容为：\n```\nduoyi@duoyi-OptiPlex-7010:~/Desktop/todo$ readelf -p 2 libsurfaceflinger.so \n\nString dump of section '.dynsym':\n  [    40]  4\n  [    50]  s\n  [    b0]  .^A\n  [    c0]  \\^A\n  [    d0]  c^A\n  [   120]  A^B\n  [   130]  G^B\n  [   140]  _^B\n  [   1b0]  2^C\n  [   1c0]  Z^C\n  ...\n```\n\n跟上面分析节区表和节区表的表项一样，符号表的结构是节区表的表项，那符号表的表项结构体是怎么表示的呢，如下\n```\ntypedef struct {  \n     Elf32_Word st_name;      //符号表 表项的名称。\n     //如果该值非0，则表示符号名在字符串表(.dynstr)中的索引值(offset)，为0即符号表项没有名称。\n     Elf32_Addr st_value;       //符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。\n     Elf32_Word st_size;         //符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。\n     unsigned char st_info;    //符号的类型和绑定属性。\n     unsigned char st_other;   \n     Elf32_Half st_shndx;        //每个符号表项都以和其他节区的关系的方式给出定义。\n　　　　　　　　　　　　　//此成员给出相关的节区头部表索引。\n} Elf32_Sym; \n```\n### 字符串表 .dynstr\n根据上面说的 符号表结构体的st_name项，非0值表示该符号名在字符串表中的索引，那么自然而然的就要介绍一下字符串表了。  \n字符串表中包含若干以 null 结尾的字符串，这些字符串通常是 symbol 或 section 的名字。当 ELF 文件的其它部分需要引用字符串时，只需提供该字符串在字符串表中的位置索引即可。  \n\n下图为一个长度为25字节的字符串表示例：  \n![](http://images0.cnblogs.com/blog2015/763648/201506/302242024621822.png)\n字符串引用示例：  \n![](http://images0.cnblogs.com/blog2015/763648/201506/302242336658657.png)  \n\n根据上面ELF文件头 字符串表的索引为3，通过`readelf -p 3 libsurfaceflinger.so`来打印一下：\n```\nduoyi@duoyi-OptiPlex-7010:~/Desktop/todo$ readelf -p 3 libsurfaceflinger.so \n\nString dump of section '.dynstr':\n  [     1]  __cxa_finalize\n  [    10]  __cxa_atexit\n  [    1d]  __aeabi_unwind_cpp_pr0\n  ..\n  [  451a]  libc.so\n  [  4522]  libstdc++.so\n  [  452f]  libm.so\n  [  4537]  libsurfaceflinger.so\n```\n\n### 重定位表 \n在编译-汇编这2个操作中，编译器和汇编器为每个文件创建程序地址一般都是从0开始，但是实际加载时模块的基址肯定不是0，为了避免加载地址重叠，就引入了重定位这个东西。重定位就是为程序不同部分分配加载地址，调整程序中的数据和代码以反映所分配地址的过程。简单的言之，则是将程序中的各个部分映射到合理的地址上来。\n\n**.rel.text .rel.dyn .rel.plt .plt  .got .got.plt的关系**\n\n- .rel.text：定位的地方在.text段内，以offset指定具体要定位位置。在链接时候由链接器完成。\n\n- .rel.dyn：重定位的地方在.got段内，主要是针对外部数据变量符号。不支持延迟重定位(Lazy)，通常是在so文件执行时就在.init段中进行重定位操作。\n\n- .rel.plt：重定位的地方在.got.plt段内, 主要是针对外部函数符号。一般是函数首次被调用时候重定位。\n\n- .plt：Procedure Linkage Table，过程链接表。所有对外部函数的调用都经过PLT再到GOT的一个调用过程。\n\n- .got：Global Offset Table，全局偏移表，存放着调用外部函数的实际地址（第一次存放的是PLT中的指令，PLT执行完之后会把计算得到的实际值再存到GOT中）。\n\n- .got.plt：ELF将GOT拆分成两个表 .got和.got.plt,前者用来保存全局变量引用的地址，后者用来保存函数引用的地址。\n\n  > Android ARM 下需要处理两个重定位表，plt_rel 和 rel，plt 指的是延迟绑定，但是 Android 目前并不对延迟绑定做特殊处理，直接与普通的重定位同时处理。\n\n### 重定位\n\n[【ARM】安卓SO中GOT REL PLT 作用与关系](https://bbs.pediy.com/thread-221821.htm)\n\n\n\n\n\n\n\n## “程序”头表\n\n上面分析了这么多的Section区，但实际上so库加载到内存中，是按照执行视图来查找各个重定位表的，所以下面就来分析一下执行视图中必须存在的程序头表（Program Header Table）。  \n程序头表表项的结构体Elf32_phdr如下：\n```\ntypedef struct {  \n    Elf32_Word p_type;           //此数组元素描述的段的类型，或者如何解释此数组元素的信息。 \n    Elf32_Off  p_offset;           //此成员给出从文件头到该段第一个字节的偏移\n    Elf32_Addr p_vaddr;         //此成员给出段的第一个字节将被放到内存中的虚拟地址\n    Elf32_Addr p_paddr;        //此成员仅用于与物理地址相关的系统中。system V忽略所有应用程序的物理地址信息。\n    Elf32_Word p_filesz;         //此成员给出段在文件映像中所占的字节数。可以为0。\n    Elf32_Word p_memsz;     //此成员给出段在内存映像中占用的字节数。可以为0。\n    Elf32_Word p_flags;         //此成员给出与段相关的标志。\n    Elf32_Word p_align;        //此成员给出段在文件中和内存中如何对齐。\n} Elf32_phdr;\n```\n这里的p_type就代表了当前Segment的类型，重点介绍2个：\n- PT_LOAD：指定可装入段，通过 p_filesz 和 p_memsz 进行描述。只有类型为PT_LOAD的段才是需要装入的。当然在装入之前，需要确定装入的地址，只要考虑的就是页面对齐，还有该段的p_vaddr域的值。确定了装入地址后，就通过elf_map()建立用户空间虚拟地址空间与目标映像文件中某个连续区间之间的映射，其返回值就是实际映射的起始地址。\n- PT_DYNAMIC：动态链接相关，如果目标文件参与动态链接，则其程序头表将包含一个类型为 PT_DYNAMIC 的元素。此段包含 .dynamic 节。\n\n### 动态节.dynamic\n和我们重定位相关的动态节的结构体如下：\n```\ntypedef struct {\n        Elf32_Sword d_tag;\n        union {\n                Elf32_Word      d_val;\n                Elf32_Addr      d_ptr;\n        } d_un;\n} Elf32_Dyn;\n```\n- d_tag：表明该动态节类型，有DT_PLTGOT、DT_HASH、DT_STRTAB、DT_SYMTAB、DT_RELA等等\n- d_un->d_val：根据tag表示的不同有不同的意思，多数情况下表示该节大小值\n- d_un->d_ptr：表示该节的虚拟地址（文件的虚拟地址与实际执行过程中的虚拟地址不一定匹配）\n\n## ELF文件格式图例\n![](http://img.blog.csdn.net/20140918103240781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VpZ3V6aTExMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n# 参考\n[【ARM】安卓SO中GOT REL PLT 作用与关系](https://bbs.pediy.com/thread-221821.htm)\n\n[EFL PLT GOT跳转关系](http://blog.csdn.net/lifeshow/article/details/29597401)\n[ELF文件中的.plt .rel.dyn .rel.plt .got .got.plt的关系](https://www.cnblogs.com/leo0000/p/5604132.html)  \n[ELF文件格式解析](http://www.07net01.com/2016/05/1534423.html)  \n[difference-between-got-and-got-plt](https://stackoverflow.com/questions/11676472/what-is-the-difference-between-got-and-got-plt-section#comment16231745_11676472)","tags":["注入"],"categories":["Android逆向安全"]},{"title":"Material Design 色表","url":"/2017/11/16/and-util-color/","content":"Material Design 色表\n<!-- more -->\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <resources>\n    \n            <!-- 常用颜色值 -->\n        <color name=\"white40\">#40FFFFFF</color>\n        <color name=\"white\">#FFFFFF</color>\n        <color name=\"black\">#000000</color>\n        <color name=\"gray\">#808080</color>\n        <color name=\"green\">#008000</color>\n        <color name=\"lightblue\">#0083FF</color>\n    \n    \n        <color name=\"red50\">#fde0dc</color>\n        <color name=\"red100\">#f9bdbb</color>\n        <color name=\"red200\">#f69988</color>\n        <color name=\"red300\">#f36c60</color>\n        <color name=\"red400\">#e84e40</color>\n        <color name=\"red500\">#e51c23</color>\n        <color name=\"red600\">#dd191d</color>\n        <color name=\"red700\">#d01716</color>\n        <color name=\"red800\">#c41411</color>\n        <color name=\"red900\">#b0120a</color>\n        <color name=\"reda100\">#ff7997</color>\n        <color name=\"reda200\">#ff5177</color>\n        <color name=\"reda400\">#ff2d6f</color>\n        <color name=\"reda700\">#e00032</color>        \n        \n        <color name=\"pink50\">#fce4ec</color>\n        <color name=\"pink100\">#f8bbd0</color>\n        <color name=\"pink200\">#f48fb1</color>\n        <color name=\"pink300\">#f06292</color>\n        <color name=\"pink400\">#ec407a</color>\n        <color name=\"pink500\">#e91e63</color>\n        <color name=\"pink600\">#d81b60</color>\n        <color name=\"pink700\">#c2185b</color>\n        <color name=\"pink800\">#ad1457</color>\n        <color name=\"pink900\">#880e4f</color>\n        <color name=\"pinka100\">#ff80ab</color>\n        <color name=\"pinka200\">#ff4081</color>\n        <color name=\"pinka400\">#f50057</color>\n        <color name=\"pinka700\">#c51162</color>\n                        \n        <color name=\"purple50\">#f3e5f5</color>\n        <color name=\"purple100\">#e1bee7</color>\n        <color name=\"purple200\">#ce93d8</color>\n        <color name=\"purple300\">#ba68c8</color>\n        <color name=\"purple400\">#ab47bc</color>\n        <color name=\"purple500\">#9c27b0</color>\n        <color name=\"purple600\">#8e24aa</color>\n        <color name=\"purple700\">#7b1fa2</color>\n        <color name=\"purple800\">#6a1b9a</color>\n        <color name=\"purple900\">#4a148c</color>\n        <color name=\"purplea100\">#ea80fc</color>\n        <color name=\"purplea200\">#e040fb</color>\n        <color name=\"purplea400\">#d500f9</color>\n        <color name=\"purplea700\">#aa00ff</color>\n                \n        <color name=\"deeppurple50\">#ede7f6</color>\n        <color name=\"deeppurple100\">#d1c4e9</color>\n        <color name=\"deeppurple200\">#b39ddb</color>\n        <color name=\"deeppurple300\">#9575cd</color>\n        <color name=\"deeppurple400\">#7e57c2</color>\n        <color name=\"deeppurple500\">#673ab7</color>\n        <color name=\"deeppurple600\">#5e35b1</color>\n        <color name=\"deeppurple700\">#512da8</color>\n        <color name=\"deeppurple800\">#4527a0</color>\n        <color name=\"deeppurple900\">#311b92</color>\n        <color name=\"deeppurplea100\">#b388ff</color>\n        <color name=\"deeppurplea200\">#7c4dff</color>\n        <color name=\"deeppurplea400\">#651fff</color>\n        <color name=\"deeppurplea700\">#6200ea</color>\n                \n        <color name=\"indigo50\">#e8eaf6</color>\n        <color name=\"indigo100\">#c5cae9</color>\n        <color name=\"indigo200\">#9fa8da</color>\n        <color name=\"indigo300\">#7986cb</color>\n        <color name=\"indigo400\">#5c6bc0</color>\n        <color name=\"indigo500\">#3f51b5</color>\n        <color name=\"indigo600\">#3949ab</color>\n        <color name=\"indigo700\">#303f9f</color>\n        <color name=\"indigo800\">#283593</color>\n        <color name=\"indigo900\">#1a237e</color>\n        <color name=\"indigoa100\">#8c9eff</color>\n        <color name=\"indigoa200\">#536dfe</color>\n        <color name=\"indigoa400\">#3d5afe</color>\n        <color name=\"indigoa700\">#304ffe</color>\n                \n        <color name=\"blue50\">#e7e9fd</color>\n        <color name=\"blue100\">#d0d9ff</color>\n        <color name=\"blue200\">#afbfff</color>\n        <color name=\"blue300\">#91a7ff</color>\n        <color name=\"blue400\">#738ffe</color>\n        <color name=\"blue500\">#5677fc</color>\n        <color name=\"blue600\">#4e6cef</color>\n        <color name=\"blue700\">#455ede</color>\n        <color name=\"blue800\">#3b50ce</color>\n        <color name=\"blue900\">#2a36b1</color>\n        <color name=\"bluea100\">#a6baff</color>\n        <color name=\"bluea200\">#6889ff</color>\n        <color name=\"bluea400\">#4d73ff</color>\n        <color name=\"bluea700\">#4d69ff</color>\n                \n        <color name=\"lightblue50\">#e1f5fe</color>\n        <color name=\"lightblue100\">#b3e5fc</color>\n        <color name=\"lightblue200\">#81d4fa</color>\n        <color name=\"lightblue300\">#4fc3f7</color>\n        <color name=\"lightblue400\">#29b6f6</color>\n        <color name=\"lightblue500\">#03a9f4</color>\n        <color name=\"lightblue600\">#039be5</color>\n        <color name=\"lightblue700\">#0288d1</color>\n        <color name=\"lightblue800\">#0277bd</color>\n        <color name=\"lightblue900\">#01579b</color>\n        <color name=\"lightbluea100\">#80d8ff</color>\n        <color name=\"lightbluea200\">#40c4ff</color>\n        <color name=\"lightbluea400\">#00b0ff</color>\n        <color name=\"lightbluea700\">#0091ea</color>   \n        \n        <color name=\"cyan50\">#e0f7fa</color>\n        <color name=\"cyan100\">#b2ebf2</color>\n        <color name=\"cyan200\">#80deea</color>\n        <color name=\"cyan300\">#4dd0e1</color>\n        <color name=\"cyan400\">#26c6da</color>\n        <color name=\"cyan500\">#00bcd4</color>\n        <color name=\"cyan600\">#00acc1</color>\n        <color name=\"cyan700\">#0097a7</color>\n        <color name=\"cyan800\">#00838f</color>\n        <color name=\"cyan900\">#006064</color>\n        <color name=\"cyana100\">#84ffff</color>\n        <color name=\"cyana200\">#18ffff</color>\n        <color name=\"cyana400\">#00e5ff</color>\n        <color name=\"cyana700\">#00b8d4</color>\n        \n        <color name=\"teal50\">#e0f2f1</color>\n        <color name=\"teal100\">#b2dfdb</color>\n        <color name=\"teal200\">#80cbc4</color>\n        <color name=\"teal300\">#4db6ac</color>\n        <color name=\"teal400\">#26a69a</color>\n        <color name=\"teal500\">#009688</color>\n        <color name=\"teal600\">#00897b</color>\n        <color name=\"teal700\">#00796b</color>\n        <color name=\"teal800\">#00695c</color>\n        <color name=\"teal900\">#004d40</color>\n        <color name=\"teala100\">#a7ffeb</color>\n        <color name=\"teala200\">#64ffda</color>\n        <color name=\"teala400\">#1de9b6</color>\n        <color name=\"teala700\">#00bfa5</color>\n        \n        <color name=\"green50\">#d0f8ce</color>\n        <color name=\"green100\">#a3e9a4</color>\n        <color name=\"green200\">#72d572</color>\n        <color name=\"green300\">#42bd41</color>\n        <color name=\"green400\">#2baf2b</color>\n        <color name=\"green500\">#259b24</color>\n        <color name=\"green600\">#0a8f08</color>\n        <color name=\"green700\">#0a7e07</color>\n        <color name=\"green800\">#056f00</color>\n        <color name=\"green900\">#0d5302</color>\n        <color name=\"greena100\">#a2f78d</color>\n        <color name=\"greena200\">#5af158</color>\n        <color name=\"greena400\">#14e715</color>\n        <color name=\"greena700\">#12c700</color>\n        \n        <color name=\"lightgreen50\">#f1f8e9</color>\n        <color name=\"lightgreen100\">#dcedc8</color>\n        <color name=\"lightgreen200\">#c5e1a5</color>\n        <color name=\"lightgreen300\">#aed581</color>\n        <color name=\"lightgreen400\">#9ccc65</color>\n        <color name=\"lightgreen500\">#8bc34a</color>\n        <color name=\"lightgreen600\">#7cb342</color>\n        <color name=\"lightgreen700\">#689f38</color>\n        <color name=\"lightgreen800\">#558b2f</color>\n        <color name=\"lightgreen900\">#33691e</color>\n        <color name=\"lightgreena100\">#ccff90</color>\n        <color name=\"lightgreena200\">#b2ff59</color>\n        <color name=\"lightgreena400\">#76ff03</color>\n        <color name=\"lightgreena700\">#64dd17</color>\n        \n        <color name=\"lime50\">#f9fbe7</color>\n        <color name=\"lime100\">#f0f4c3</color>\n        <color name=\"lime200\">#e6ee9c</color>\n        <color name=\"lime300\">#dce775</color>\n        <color name=\"lime400\">#d4e157</color>\n        <color name=\"lime500\">#cddc39</color>\n        <color name=\"lime600\">#c0ca33</color>\n        <color name=\"lime700\">#afb42b</color>\n        <color name=\"lime800\">#9e9d24</color>\n        <color name=\"lime900\">#827717</color>\n        <color name=\"limea100\">#f4ff81</color>\n        <color name=\"limea200\">#eeff41</color>\n        <color name=\"limea400\">#c6ff00</color>\n        <color name=\"limea700\">#aeea00</color>\n        \n        <color name=\"yellow50\">#fffde7</color>\n        <color name=\"yellow100\">#fff9c4</color>\n        <color name=\"yellow200\">#fff59d</color>\n        <color name=\"yellow300\">#fff176</color>\n        <color name=\"yellow400\">#ffee58</color>\n        <color name=\"yellow500\">#ffeb3b</color>\n        <color name=\"yellow600\">#fdd835</color>\n        <color name=\"yellow700\">#fbc02d</color>\n        <color name=\"yellow800\">#f9a825</color>\n        <color name=\"yellow900\">#f57f17</color>\n        <color name=\"yellowa100\">#ffff8d</color>\n        <color name=\"yellowa200\">#ffff00</color>\n        <color name=\"yellowa400\">#ffea00</color>\n        <color name=\"yellowa700\">#ffd600</color>   \n        \n        <color name=\"amber50\">#fff8e1</color>\n        <color name=\"amber100\">#ffecb3</color>\n        <color name=\"amber200\">#ffe082</color>\n        <color name=\"amber300\">#ffd54f</color>\n        <color name=\"amber400\">#ffca28</color>\n        <color name=\"amber500\">#ffc107</color>\n        <color name=\"amber600\">#ffb300</color>\n        <color name=\"amber700\">#ffa000</color>\n        <color name=\"amber800\">#ff8f00</color>\n        <color name=\"amber900\">#ff6f00</color>\n        <color name=\"ambera100\">#ffe57f</color>\n        <color name=\"ambera200\">#ffd740</color>\n        <color name=\"ambera400\">#ffc400</color>\n        <color name=\"ambera700\">#ffab00</color>\n        \n        <color name=\"orange50\">#fff3e0</color>\n        <color name=\"orange100\">#ffe0b2</color>\n        <color name=\"orange200\">#ffcc80</color>\n        <color name=\"orange300\">#ffb74d</color>\n        <color name=\"orange400\">#ffa726</color>\n        <color name=\"orange500\">#ff9800</color>\n        <color name=\"orange600\">#fb8c00</color>\n        <color name=\"orange700\">#f57c00</color>\n        <color name=\"orange800\">#ef6c00</color>\n        <color name=\"orange900\">#e65100</color>\n        <color name=\"orangea100\">#ffd180</color>\n        <color name=\"orangea200\">#ffab40</color>\n        <color name=\"orangea400\">#ff9100</color>\n        <color name=\"orangea700\">#ff6d00</color>\n        \n        <color name=\"deeporange50\">#fbe9e7</color>\n        <color name=\"deeporange100\">#ffccbc</color>\n        <color name=\"deeporange200\">#ffab91</color>\n        <color name=\"deeporange300\">#ff8a65</color>\n        <color name=\"deeporange400\">#ff7043</color>\n        <color name=\"deeporange500\">#ff5722</color>\n        <color name=\"deeporange600\">#f4511e</color>\n        <color name=\"deeporange700\">#e64a19</color>\n        <color name=\"deeporange800\">#d84315</color>\n        <color name=\"deeporange900\">#bf360c</color>\n        <color name=\"deeporangea100\">#ff9e80</color>\n        <color name=\"deeporangea200\">#ff6e40</color>\n        <color name=\"deeporangea400\">#ff3d00</color>\n        <color name=\"deeporangea700\">#dd2c00</color>\n        \n        <color name=\"brown50\">#efebe9</color>\n        <color name=\"brown100\">#d7ccc8</color>\n        <color name=\"brown200\">#bcaaa4</color>\n        <color name=\"brown300\">#a1887f</color>\n        <color name=\"brown400\">#8d6e63</color>\n        <color name=\"brown500\">#795548</color>\n        <color name=\"brown600\">#6d4c41</color>\n        <color name=\"brown700\">#5d4037</color>\n        <color name=\"brown800\">#4e342e</color>\n        <color name=\"brown900\">#3e2723</color>\n        \n        <color name=\"grey50\">#fafafa</color>\n        <color name=\"grey100\">#f5f5f5</color>\n        <color name=\"grey200\">#eeeeee</color>\n        <color name=\"grey300\">#e0e0e0</color>\n        <color name=\"grey400\">#bdbdbd</color>\n        <color name=\"grey500\">#9e9e9e</color>\n        <color name=\"grey600\">#757575</color>\n        <color name=\"grey700\">#616161</color>\n        <color name=\"grey800\">#424242</color>\n        <color name=\"grey900\">#212121</color>\n        <color name=\"grey1000\">#000000</color>\n        \n        <color name=\"bluegrey50\">#eceff1</color>\n        <color name=\"bluegrey100\">#cfd8dc</color>\n        <color name=\"bluegrey200\">#b0bec5</color>\n        <color name=\"bluegrey300\">#90a4ae</color>\n        <color name=\"bluegrey400\">#78909c</color>\n        <color name=\"bluegrey500\">#607d8b</color>\n        <color name=\"bluegrey600\">#546e7a</color>\n        <color name=\"bluegrey700\">#455a64</color>\n        <color name=\"bluegrey800\">#37474f</color>\n        <color name=\"bluegrey900\">#263238</color>        \n    </resources>\n```","tags":["Material Design"],"categories":["Android代码库"]},{"title":"App相关全局管理类","url":"/2017/11/15/and-util-app/","content":"Activity管理类以及App类\n<!-- more -->\n## 代码\n> AppManager.java  \n\n```java\n\npublic class AppManager {\n\n    private static Stack<Activity> activityStack;\n    private static AppManager instance;\n\n    public Context getAppContext() {\n        return appContext;\n    }\n\n    private Context appContext;\n    private AppManager() {\n    }\n\n    /**\n     * 单一实例\n     */\n    public static AppManager getInstance() {\n        if (instance == null) {\n            instance = new AppManager();\n        }\n        return instance;\n    }\n\n    /**\n     * 添加Activity到堆栈\n     */\n    public void addActivity(Activity activity) {\n        if (activityStack == null) {\n            activityStack = new Stack<Activity>();\n        }\n        activityStack.add(activity);\n    }\n\n    /**\n     * 获取当前Activity（堆栈中最后一个压入的）\n     */\n    public Activity currentActivity() {\n        Activity activity = activityStack.lastElement();\n        return activity;\n    }\n\n    /**\n     * 结束当前Activity（堆栈中最后一个压入的）\n     */\n    public void finishActivity() {\n        Activity activity = activityStack.lastElement();\n        finishActivity(activity);\n    }\n\n    /**\n     * 结束指定的Activity\n     */\n    public void finishActivity(Activity activity) {\n        if (activity != null) {\n            activityStack.remove(activity);\n            activity.finish();\n            activity = null;\n        }\n    }\n\n    /**\n     * 结束指定类名的Activity\n     */\n    public void finishActivity(Class<?> cls) {\n        for (Activity activity : activityStack) {\n            if (activity.getClass().equals(cls)) {\n                finishActivity(activity);\n            }\n        }\n    }\n\n    /**\n     * 结束所有Activity\n     */\n    public void finishAllActivity() {\n        for (int i = 0, size = activityStack.size(); i < size; i++) {\n            if (null != activityStack.get(i)) {\n                activityStack.get(i).finish();\n            }\n        }\n        activityStack.clear();\n    }\n\n    /**\n     * 退出应用程序\n     */\n    public void AppExit(Context context) {\n        try {\n            finishAllActivity();\n            ActivityManager activityMgr = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n            activityMgr.restartPackage(context.getPackageName());\n            System.exit(0);\n        } catch (Exception e) {\n        }\n    }\n\n    public void setContext(Context context) {\n        this.appContext = context;\n    }\n}\n\n\n```\n\n> App 来初始化一些数据库网络等\n\n```\npublic class App extends Application {\n\n    private static DaoSession mDaoSession;\n    private Context mContext;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        mContext = this.getApplicationContext();\n        AppManager.getInstance().setContext(mContext);\n        setupDatabase(this);\n        setupLog();\n        setupNet();\n        ...\n\n\n\n    }\n\n\n\n\n\n    private void setupDatabase(Context context) {\n        DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(context, DATABASE_WEATHER);\n        Database db = openHelper.getWritableDb();\n        DaoMaster daoMaster = new DaoMaster(db);\n        mDaoSession = daoMaster.newSession();\n    }\n\n \n\n    public static DaoSession getDaoSession() {\n        return mDaoSession;\n    }\n\n\n\n}\n\n```\n","tags":["Application"],"categories":["Android代码库"]},{"title":"SharedPreference工具类","url":"/2017/11/15/and-util-shap/","content":"SharedPreference工具类\n<!-- more -->\n## 代码\n```java\npublic class SharedPreferenceUtil {\n\n    public static void putSharedPreferences(String key, Object value) {\n        Context context = AppManager.getInstance().getAppContext();\n        String type = value.getClass().getSimpleName();\n        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);\n        SharedPreferences.Editor editor = sharedPreferences.edit();\n        if (\"Integer\".equals(type)) {\n            editor.putInt(key, (Integer) value);\n        } else if (\"Boolean\".equals(type)) {\n            editor.putBoolean(key, (Boolean) value);\n        } else if (\"String\".equals(type)) {\n            editor.putString(key, (String) value);\n        } else if (\"Float\".equals(type)) {\n            editor.putFloat(key, (Float) value);\n        } else if (\"Long\".equals(type)) {\n            editor.putLong(key, (Long) value);\n        }\n        editor.commit();\n    }\n\n    public static Object getSharedPreferences(String key, Object defValue) {\n        Context context = AppManager.getInstance().getAppContext();\n\n        String type = defValue.getClass().getSimpleName();\n        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);\n        //defValue为为默认值，如果当前获取不到数据就返回它\n        if (\"Integer\".equals(type)) {\n            return sharedPreferences.getInt(key, (Integer) defValue);\n        } else if (\"Boolean\".equals(type)) {\n            return sharedPreferences.getBoolean(key, (Boolean) defValue);\n        } else if (\"String\".equals(type)) {\n            return sharedPreferences.getString(key, (String) defValue);\n        } else if (\"Float\".equals(type)) {\n            return sharedPreferences.getFloat(key, (Float) defValue);\n        } else if (\"Long\".equals(type)) {\n            return sharedPreferences.getLong(key, (Long) defValue);\n        }\n        return null;\n    }\n}\n```\n","tags":["SharedPreference"],"categories":["Android代码库"]},{"title":"Fragment 杂记","url":"/2017/11/13/Fragment杂记/","content":"Fragment 使用过程中遇到得坑与使用心得\n<!-- more -->\n\n# 实例化\nFragment使用静态单例构造器与setArguments来传递初始化参数\n```\npublic class FragmentOne extends Fragment{\n    private TextView textView;\n    public View onCreateView(LayoutInflater inflater,\n            @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.fragment_one, null);\n        textView = (TextView) view.findViewById(R.id.textview);\n        if(getArguments()!=null){\n            //取出保存的值\n            textView.setText(getArguments().getString(\"name\"));\n        }\n        return view;\n    }\n    public static  FragmentOne newInstance(String text){\n        FragmentOne fragmentOne = new FragmentOne();\n        Bundle bundle = new Bundle();\n        bundle.putString(\"name\", text);\n        //fragment保存参数，传入一个Bundle对象\n        fragmentOne.setArguments(bundle);\n        return fragmentOne;\n    }\n}\n```\n\n# ButterKnife的使用\n```java\n    Unbinder unbinder;\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        View view= inflater.inflate(R.layout.activity_weather, container, false);\n        unbinder = ButterKnife.bind(this,view);\n        }\n    @Override\n    public void onDestroyView() {\n        super.onDestroyView();\n        unbinder.unbind();\n    }    \n        \n```\n\n\n# 旋转导致重叠\n## 保存数据：onSaveInstanceState\n当手机屏幕旋转，或者Activity被回收的时候，系统会调用`onSaveInstanceState(Bundle outState)`来保存视图层（View Hierarchy）数据，参数Bundle是可以传递可序列化数据的类。观察Activity的onCreate的方法参数就明白了`onCreate(@Nullable Bundle savedInstanceState)`。\n\n通过上面的介绍，大致也能理解Fragment的重叠原因也是因为数据的保存。当屏幕旋转的时候，Fragment执行onDetach，但是Activity中依然持有之前实例化的Fragment，在`onSaveInstanceState`中被保存，当Activity重新执行onCreate的时候，这个Fragment又被显示到屏幕上，就造成了屏幕重叠。\n\n## 解决方法\n\n按照上面的介绍，最简单的方法就是重写onSaveInstanceState，函数体置空，直接不保存状态，自然恢复的时候就不会有重叠的情况。\n```\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n    }\n```\n但是如果这样的，又与恢复数据的需求背道而驰，假设用户在看视频，总不可能旋转一下，视频又得从头播放吧。  \n对于Fragment的话可以在Activity的onAttachFragment的方法中对参数Fragment判断是否是某个具体Fragment的实例，然后直接设置该Fragment，而不用再一次去new一个。\n## 参考\n[如何向一个Fragment传递参数---setArguments方法的介绍](http://blog.csdn.net/small_lee/article/details/50553881)","tags":["Fragment"],"categories":["Android"]},{"title":"浅析Android进程间通信（三）","url":"/2017/11/11/android-ipc3/","content":"基于Android 6.0，从源码角度来理解Binder机制\n<!-- more -->\n\n# Binder\n\n正如前面说的，进程间通信的本质就是进程A拿到了进程B中Binder的对象的代理，通过这个代理Binder来向进程B发送请求进行通信。而Android系统有各种各样的系统服务，除了上一节提到的系统电量PowerManagerService，还有网络相关的、输入法、音频视频、剪切板和USB等等，想都不用向，这些服务肯定是共同持有一个Binder的抽象类，再具体扩展的。\n\n## BnInterface和BpInterface\n\n先介绍2个来自[IInterface.h](http://androidxref.com/6.0.1_r10/xref/frameworks/native/include/binder/IInterface.h#49)的重要接口BnInterface和BpInterface，分别对应`Binder实体`即响应方持有的Binder和`Binder代理`即调用方持有。\n\n```cpp\n49  template<typename INTERFACE>\n50  class BnInterface : public INTERFACE, public BBinder\n51  {\n52  public:\n53      virtual sp<IInterface>      queryLocalInterface(const String16& _descriptor);\n54      virtual const String16&     getInterfaceDescriptor() const;\n55\n56  protected:\n57      virtual IBinder*            onAsBinder();\n58  };\n59\n60  // ----------------------------------------------------------------------\n61\n62  template<typename INTERFACE>\n63  class BpInterface : public INTERFACE, public BpRefBase\n64  {\n65  public:\n66                                BpInterface(const sp<IBinder>& remote);\n67\n68  protected:\n69      virtual IBinder*            onAsBinder();\n70  };\n```\n\nBnInterface和BpInterface又分别继承自[Binder.h](http://androidxref.com/6.0.1_r10/xref/frameworks/native/include/binder/Binder.h)中定义的2个类`BBinder`和`BpRefBase`（实际上是和BpRefBase中的mRemote对象BpBinder有关），BBinder和BpBinder都继承自[IBinder](http://androidxref.com/6.0.1_r10/xref/frameworks/native/include/binder/IBinder.h)。\n\n关系比较乱，上一个红茶大佬的图：\n\n![](http://img.blog.csdn.net/20150909221454433)\n\n\n\n\n\n## BBinder\n\n在[Binder.cpp](http://androidxref.com/6.0.1_r10/xref/frameworks/native/libs/binder/Binder.cpp#73)中对BBinder的各个方法都进行了实现，主要关注`transact`这个方法中调用的`onTransact`，`onTransact`是会被子类重写来实现自己的业务的\n\n```cpp\n97 status_t BBinder::transact(\n98    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n99 {\n100    data.setDataPosition(0);\n101\n102    status_t err = NO_ERROR;\n103    switch (code) {\n104        case PING_TRANSACTION:\n105            reply->writeInt32(pingBinder());\n106            break;\n107        default:\n108            err = onTransact(code, data, reply, flags);\n109            break;\n110    }\n111\n112    if (reply != NULL) {\n113        reply->setDataPosition(0);\n114    }\n115\n116    return err;\n117 }\n```\n\n## BpBinder\n\n[BpBinder](http://androidxref.com/6.0.1_r10/xref/frameworks/native/libs/binder/BpBinder.cpp#159)的transact的内部实际调用的是[IPCThreadState::transact](http://androidxref.com/6.0.1_r10/xref/frameworks/native/libs/binder/IPCThreadState.cpp#548)，再跟进就是`IPCThreadState::writeTransactionData`\n\n```cpp\n159 status_t BpBinder::transact(\n160    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n161{\n162    // Once a binder has died, it will never come back to life.\n163    if (mAlive) {\n164        status_t status = IPCThreadState::self()->transact(\n165            mHandle, code, data, reply, flags);\n166        if (status == DEAD_OBJECT) mAlive = 0;\n167        return status;\n168    }\n169\n170    return DEAD_OBJECT;\n171}\n```\n\n\n\n## 宏\n\n再介绍[IInterface.h](http://androidxref.com/6.0.1_r10/xref/frameworks/native/include/binder/IInterface.h)头文件下的几个重要的宏。\n### DECLARE_META_INTERFACE\n按字面意思直译的话就是`声明interface`，实际上下面的宏也确实是起到了声明的作用\n```c\n74#define DECLARE_META_INTERFACE(INTERFACE)                               \\\n75    static const android::String16 descriptor;                          \\\n76    static android::sp<I##INTERFACE> asInterface(                       \\\n77            const android::sp<android::IBinder>& obj);                  \\\n78    virtual const android::String16& getInterfaceDescriptor() const;    \\\n79    I##INTERFACE();                                                     \\\n80    virtual ~I##INTERFACE();                 \n```\n### IMPLEMENT_META_INTERFACE\n对应上面的声明，这里就是`实现interface`了。\n```c\n83#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \\\n84    const android::String16 I##INTERFACE::descriptor(NAME);             \\\n85    const android::String16&                                            \\\n86            I##INTERFACE::getInterfaceDescriptor() const {              \\\n87        return I##INTERFACE::descriptor;                                \\\n88    }                                                                   \\\n89    android::sp<I##INTERFACE> I##INTERFACE::asInterface(                \\\n90            const android::sp<android::IBinder>& obj)                   \\\n91    {                                                                   \\\n92        android::sp<I##INTERFACE> intr;                                 \\\n93        if (obj != NULL) {                                              \\\n94            intr = static_cast<I##INTERFACE*>(                          \\\n95                obj->queryLocalInterface(                               \\\n96                        I##INTERFACE::descriptor).get());               \\\n97            if (intr == NULL) {                                         \\\n98                intr = new Bp##INTERFACE(obj);                          \\\n99            }                                                           \\\n100        }                                                               \\\n101        return intr;                                                    \\\n102    }                                                                   \\\n103    I##INTERFACE::I##INTERFACE() { }                                    \\\n104    I##INTERFACE::~I##INTERFACE() { }      \n```\n\n## 实例分析\n\n下面就以Camera服务来实际理一遍Bn和Bp是如何工作的。\n\n在[Camera.cpp](http://androidxref.com/6.0.1_r10/xref/frameworks/av/camera/Camera.cpp)中各个方法内部实际调用[ICamera.cpp](http://androidxref.com/6.0.1_r10/xref/frameworks/av/camera/ICamera.cpp)来实现\n\n[BnCamera](http://androidxref.com/6.0.1_r10/xref/frameworks/av/include/camera/ICamera.h)在`ICamera.h`中定义了\n\n```java\n118class BnCamera: public BnInterface<ICamera>\n119{\n120public:\n121    virtual status_t    onTransact( uint32_t code,\n122                                    const Parcel& data,\n123                                    Parcel* reply,\n124                                    uint32_t flags = 0);\n125};\n```\n\n而[BpCamera](http://androidxref.com/6.0.1_r10/xref/frameworks/av/camera/ICamera.cpp#54)是ICamera.cpp中定义的类\n\n```cpp\n54 class BpCamera: public BpInterface<ICamera>\n55 {\n56 public:\n57    BpCamera(const sp<IBinder>& impl)\n58        : BpInterface<ICamera>(impl)\n59    {\n60    }\n\t...\n\t}\n```\n其他进程请求Camera服务的时候，就需要通过BpCamera来了。下面从BpCamera中一次实际的请求`takePicture`切入分析：\n```java\n206    // take a picture - returns an IMemory (ref-counted mmap)\n207    status_t takePicture(int msgType)\n208    {\n209        ALOGV(\"takePicture: 0x%x\", msgType);\n210        Parcel data, reply;\n211        data.writeInterfaceToken(ICamera::getInterfaceDescriptor());\n212        data.writeInt32(msgType);\n213        remote()->transact(TAKE_PICTURE, data, &reply);\n214        status_t ret = reply.readInt32();\n215        return ret;\n216    }\n  ...\n   }\n```\n\n```java\n373        case TAKE_PICTURE: {\n374            ALOGV(\"TAKE_PICTURE\");\n375            CHECK_INTERFACE(ICamera, data, reply);\n376            int msgType = data.readInt32();\n377            reply->writeInt32(takePicture(msgType));\n378            return NO_ERROR;\n379        } break;\n```\n\n通过请求码`TAKE_PICTURE`来最后调用到`(takePicture(msgType));`\n\nBpCamera继承BpInterface，是代理Binder。`takePicture`这个方法中data根据一些传输协议来写入数据，通过`remote`来transact，同时还有`reply`作为响应。\n\n\n\n\n\n# ServiceManager\n\n\n\n## 通过0号Binder来获取SM的代理\n\n### JAVA层\n\n在[ServiceManager.java](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/os/ServiceManager.java)中通过`ServiceManagerNative`来获取ServiceManager\n\n```java\n33    private static IServiceManager getIServiceManager() {\n34        if (sServiceManager != null) {\n35            return sServiceManager;\n36        }\n37\n38        // Find the service manager\n39        sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());\n40        return sServiceManager;\n41    }\n```\n\n在`ServiceManagerNative`中，返回`IServiceManager`的实现类`ServiceManagerProxy`实例，来获取0号Binder\n\n```java\n    static public IServiceManager asInterface(IBinder obj)\n    {\n        if (obj == null) {\n            return null;\n        }\n        IServiceManager in =\n            (IServiceManager)obj.queryLocalInterface(descriptor);\n        if (in != null) {\n            return in;\n        }\n        \n        return new ServiceManagerProxy(obj);\n    }\n    public ServiceManagerProxy(IBinder remote) \n\t{\n    \tmRemote = remote;//\n\t}\n```\n\n\n引用红茶话Binder中2句话\n> 1） ServiceManagerProxy就是IServiceManager代理接口；\n>\n> 2） ServiceManagerNative显得很鸡肋；\n\n\n\n\n\n### C层\n\n在[IServiceManager.cpp](http://androidxref.com/6.0.1_r10/xref/frameworks/native/libs/binder/IServiceManager.cpp#33)中line40提供了获取0号Binder的方法\n\n```c\n33sp<IServiceManager> defaultServiceManager()\n34{\n35    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;\n36\n37    {\n38        AutoMutex _l(gDefaultServiceManagerLock);\n39        while (gDefaultServiceManager == NULL) {\n40            gDefaultServiceManager = interface_cast<IServiceManager>(\n41                ProcessState::self()->getContextObject(NULL));\n42            if (gDefaultServiceManager == NULL)\n43                sleep(1);\n44        }\n45    }\n46\n47    return gDefaultServiceManager;\n48}\n```\n再进入到[ProcessState](http://androidxref.com/6.0.1_r10/xref/frameworks/native/libs/binder/ProcessState.cpp#85)中查看相关代码，`getContextObject`中调用`getStrongProxyForHandle(0)`方法。\n\n```c\n85sp<IBinder> ProcessState::getContextObject(const sp<IBinder>& /*caller*/)\n86{\n87    return getStrongProxyForHandle(0);\n88}\n\n179sp<IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)\n180{\n181    sp<IBinder> result;\n182\n183    AutoMutex _l(mLock);\n184\n185    handle_entry* e = lookupHandleLocked(handle);\n186\n187    if (e != NULL) {\n191        IBinder* b = e->binder;\n192        if (b == NULL || !e->refs->attemptIncWeak(this)) {\n193            if (handle == 0) {\n212\n213                Parcel data;\n214                status_t status = IPCThreadState::self()->transact(\n215                        0, IBinder::PING_TRANSACTION, data, NULL, 0);\n216                if (status == DEAD_OBJECT)\n217                   return NULL;\n218            }\n220            b = new BpBinder(handle);\n221            e->binder = b;\n222            if (b) e->refs = b->getWeakRefs();\n223            result = b;\n224        } else {\n225            // This little bit of nastyness is to allow us to add a primary\n226            // reference to the remote proxy when this team doesn't have one\n227            // but another team is sending the handle to us.\n228            result.force_set(b);\n229            e->refs->decWeak(this);\n230        }\n231    }\n232\n233    return result;\n234}\n```\n\ngetContextObject(NULL)实际上相当于返回了一个 new BpBinder(0)\n\n再来看看模板方法`interface_cast`\n\n```c\ntemplate<typename INTERFACE>\ninline sp<INTERFACE> interface_cast(const sp<IBinder>& obj)\n{\n    return INTERFACE::asInterface(obj);\n}\n```\n实际上是调用IServiceManager的asInterface方法\n\n\n\n![](http://img.blog.csdn.net/20150909225436079)\n## 通过SM代理来向SM注册其他系统服务\n```cpp\n    power = new PowerManagerService();\n    ServiceManager.addService(Context.POWER_SERVICE, power);\n```\nSystemServer向SM注册PowerManagerService\n## 通过SM代理向SM获得其他系统服务\n\n`IServiceManager`的实现类`ServiceManagerProxy`实例中提供了`add`、`get`等方法\n\n```java\npublic IBinder getService(String name) throws RemoteException \n{\n    Parcel data = Parcel.obtain();\n    Parcel reply = Parcel.obtain();\n    data.writeInterfaceToken(IServiceManager.descriptor);\n    data.writeString(name);\n    \n    mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);\n    \n    IBinder binder = reply.readStrongBinder();\n    reply.recycle();\n    data.recycle();\n    return binder;\n}\n```\n\n# 参考\n[红茶话Binder-1](http://blog.csdn.net/codefly/article/details/17058607)\n\n[Android系统服务](http://blog.csdn.net/sinat_34396176/article/details/51480936)\n","tags":["IPC"],"categories":["Android"]},{"title":"Android OpenGL的简单使用","url":"/2017/11/04/android-opengl1/","content":"Android OpenGL的Demo\n<!-- more -->\n# 写在前面的话\n最近在弄framework层的注入，又是学习Android系统的启动流程，IPC，还有Android的整个GUI渲染机制，看源码看了一礼拜，眼睛疼，擦。。总感觉没有成功的打通整个环节，从Android系统的启动，到执行开机通话这个环节，又得研究游戏Apk是怎么调用OpenGL的渲染，为什么不走eglSwapBuffer这个方法，我hook了又不调，烦得很哎。。还是找个简单的来做一做，先研究在Android应用上面openGL的使用吧哎。。想到这一个礼拜来一直沉迷源码，赶紧停下来写写java，我就顺手把OpenGL在安卓的应用这一块理一理吧。。唉。。 \n\n# SurfaceView\n先简略的说一下SurfaceFlinger，这就是一个系统服务，负责系统底层GUI这一块的管理，后面我会详细的把这一块理一理。  \n通常来说，我们一个Activity(或者说一个Window)都在SurfaceFlinger中，对应这一个Layer（见下图），像一般我们在Activity的布局中，需要显示Button啊、TextView这种的，都是往这个对应的Layer填充数据，然后由SurfaceFlinger来对各种各样的Layer进行合成渲染，最后控制底层显示在屏幕上。然后像Button这种的控件的绘制，都是在UI主线程中进行的，如果需要频繁的刷新界面，比如直播啊拍照的摄像头预览，那肯定就比较耗时嘛，耗时你主线程就没办法对用户的输入进行响应，容易ANR，所以就有了SurfaceView这个东西，他在SurfaceFlinger中单独对应一个Layer(LayerBuffer)，通过子线程来对它进行更新。\n![](http://img.my.csdn.net/uploads/201303/11/1363016714_1787.jpg)  \nSurfaceView继承View，有两个子类GLSurfaceView和VideoView \n## 使用\n创建一个自定义的MySurfaceView，继承自SurfaceView，并实现两个接口SurfaceHolder.CallBack和Runnable(都是为了方便，如果代码复杂的应该要分别实现MySurfaceHolder已经DrawingThread来分别对应周期控制与子线程绘制)。  \nSurfaceHolder.CallBack的三个方法分别对应着SurfaceView的三个生命周期\n```\n    public interface Callback {\n        void surfaceCreated(SurfaceHolder var1);\n\n        void surfaceChanged(SurfaceHolder var1, int var2, int var3, int var4);\n\n        void surfaceDestroyed(SurfaceHolder var1);\n    }\n```\n由此我们可以猜测这个Holder可能是Surface的主要控制类，看看这个类的部分方法，不难知道SurfaceHolder控制着SurfaceView的大小，格式，可以监控或者改变SurfaceView。\n```\n    void setFixedSize(int var1, int var2);\n\n    void setSizeFromLayout();\n\n    void setFormat(int var1);\n\n    void setKeepScreenOn(boolean var1);\n\n    Canvas lockCanvas();\n\n    Canvas lockCanvas(Rect var1);\n\n    default Canvas lockHardwareCanvas() {\n        throw new RuntimeException(\"Stub!\");\n    }\n\n    void unlockCanvasAndPost(Canvas var1);\n\n    Rect getSurfaceFrame();\n\n    Surface getSurface();\n```\n需要绘制的话，还需要一个画布类Canvas，在对应的生命周期中开始绘制并且提交，Holder也提供了相应的方法\n```\nmCanvas = mHolder.lockCanvas(); //lock\nmHolder.unlockCanvasAndPost(mCanvas);//unLock Post\n```\n### 完整代码\n```java\npublic class MySurfaceView extends SurfaceView implements SurfaceHolder.Callback,Runnable{\n\n    SurfaceHolder mHolder ;\n    // 画布\n    private Canvas mCanvas;\n    // 子线程标志位\n    private boolean isDrawing;\n\n    public MySurfaceView(Context context, AttributeSet attrs) {\n    \n        super(context, attrs);\n        init();\n    }\n\n    private void init() {\n        mHolder = getHolder();//得到SurfaceHolder对象\n        mHolder.addCallback(this);//注册SurfaceHolder\n        setFocusable(true);\n        setFocusableInTouchMode(true);\n        this.setKeepScreenOn(true);//保持屏幕长亮\n    }\n\n\n\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {//创建\n        isDrawing = true;\n        new Thread(this).start();\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {//改变\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {//销毁\n        isDrawing = false;\n    }\n\n\n    @Override\n    public void run() {\n        while (isDrawing){\n            drawing();\n        }\n    }\n\n    private void drawing() {\n        try {\n            mCanvas = mHolder.lockCanvas();\n            //这里进行内容的绘制\n\n        }finally {\n            if (mCanvas != null){\n                mHolder.unlockCanvasAndPost(mCanvas);\n            }\n        }\n    }\n\n\n}\n```\n    \n \n# GLSurfaceView 和 Renderer\nSurfaceView的子类，功能和SurfaceView相似。我们可以创建一个GLSurfaceView类的实例，实现GLSurfaceView.Renderer接口添加自定义渲染。GLSurfaceView没什么好说的，主要还是他的这个渲染器接口Renderer\n```\n    public interface Renderer {\n        void onSurfaceCreated(GL10 var1, EGLConfig var2);\n\n        void onSurfaceChanged(GL10 var1, int var2, int var3);\n\n        void onDrawFrame(GL10 var1);\n    }\n```\n这个接口有3个方法  \n- onSurfaceCreated() surface被创建或者重新创建的时候调用。当线程开始渲染时或者EGL Context丢失时也会调用(EGL是Android系统对OpenGL的上层封装扩展，EGL Context通常在系统屏幕黑掉的时候丢失)。\n- onSurfaceChanged()- 如果View的几和形状发生变化了就调用\n- onDrawFrame()- 绘制当前的帧，每次View被重绘时被调用。\n\n## 完整代码\n根据以上3个方法的介绍，基本可以确定是onSurfaceCreated里面做一些配置任务，官网也推荐我们在这个方法里创建一些资源等。然后在onDrawFrame里面实现每一帧的绘制任务。\n具体的位置就是要参考openGL的API了，先写上吧，以后有需要再进一步学习\n```\n\npublic class SunnyGLRender  implements GLSurfaceView.Renderer {\n\n    public float mAngle;\n    float one = 0.5f;\n    private FloatBuffer triggerBuffer2 = MainActivity.BufferUtil.floatToBuffer(new float []{\n            0,one,0, //上顶点\n            -one,-one,0, //左下点\n            one,-one,0,}); //右下点\n    private FloatBuffer triggerBuffer1 = MainActivity.BufferUtil.floatToBuffer(new float []{\n            0,one,0, //上顶点\n            -one,-one,0, //左下点\n            one,-one,0,}); //右下点\n    private float[] mTriangleArray = {\n            // X, Y, Z 这是一个等边三角形\n            -0.5f, -0.25f, 0,\n            0.5f, -0.25f, 0,\n            0.0f, 0.559016994f, 0 };\n\n    @Override\n    public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n\n        //GLES30:为OpenGL ES2.0版本,相应的\n        //GLES30:OpenGL ES3.0\n        Log.e(\"zcxgl\",\"onSurfaceCreated\");\n\n        //黑色背景\n        gl.glClearColor(0.6f, 0f, 0.5f, 0.5f);\n        //gl.glClear(GL10.GL_COLOR_BUFFER_BIT);\n        // 启用顶点数组（否则glDrawArrays不起作用）\n        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);\n\n    }\n\n    @Override\n    public void onSurfaceChanged(GL10 gl, int width, int height) {\n        //mProgram = GLES30.glCreateProgram();\n        //Log.e(\"zcxgl\", \"Could not link program: mProgram = \"+mProgram);\n//        Log.e(\"zcxgl\",\"onSurfaceChanged\");\n        float ratio = (float) width / height;\n        Log.e(\"zcxgl\",\"onSurfaceChanged:\"+ratio+\",\"+width+\",\"+height);\n\n        gl.glMatrixMode(GL10.GL_PROJECTION); // 设置当前矩阵为投影矩阵\n        gl.glLoadIdentity(); // 重置矩阵为初始值\n        gl.glFrustumf(-ratio, ratio, -1, 1, 3, 7); // 根据长宽比设置投影矩阵\n//        gl.glFrustumf(-ratio, ratio, -1, 1, 5, 6);\n\n    }\n    private FloatBuffer colorBuffer2 = MainActivity.BufferUtil.floatToBuffer(new float[]{\n            one,0,0,one,\n            0,one,0,one,\n            0,0,one,one,\n    });\n    @Override\n    public void onDrawFrame(GL10 gl) {\n        // Redraw background color\n        Log.d(\"zcxgl\",\"onDrawFramew\");\n        gl.glClear(GL10.GL_COLOR_BUFFER_BIT);\n        gl.glColor4f(1.0f, 0.0f, 0.0f, 1.0f);\n\n        /************ 启用MODELVIEW模式，并使用GLU.gluLookAt()来设置视点 ***************/\n        // 设置当前矩阵为模型视图模式\n        gl.glMatrixMode(GL10.GL_MODELVIEW);\n        gl.glLoadIdentity(); // reset the matrix to its default state\n        // 设置视点\n        GLU.gluLookAt(gl, 0, 0, -5, 0f, 0f, 0f, 0f, 1.0f, 0.0f);\n        /*****************************************/\n\n        long time = SystemClock.uptimeMillis() % 4000L;\n        mAngle = 0.090f * ((int)time);\n        // 重置当前的模型观察矩阵\n        gl.glLoadIdentity();\n        // 移动绘图原点的坐标与上面的语句连用就相当于设置新的绘图远点坐标，\n        //gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);//后面的1-10是指图像的1-10层，\n        // 图像所处层次越大，在屏幕上显示就越小。默认为（0，0，1),\n        // 左移 1.5 单位，并移入屏幕 6.0。\n        gl.glTranslatef(0f, 0.0f, -5.0f);\n\n        gl.glRotatef(mAngle, 0.0f, 0.0f, 1.0f);\n        //启用平滑着色\n        gl.glEnableClientState(GL10.GL_COLOR_ARRAY);//\n        //gl.glColor4f(1.0f, 0.0f, 0.0f, 1.0f);//可以直接设置绘图的单调颜色\n        // 设置三角形点\n        // gl.glVertexPointer(3, GL10.GL_FIXED, 0, triggerBuffer);\n        gl.glVertexPointer(3,GL10.GL_FLOAT,0,triggerBuffer2);\n        //设置平滑着色的颜色矩阵\n        gl.glColorPointer(4,GL10.GL_FLOAT,0,colorBuffer2);//都是一维矩阵，因此第一个参数就是表示一个颜色的长度表示\n        //绘制\n        gl.glDrawArrays(GL10.GL_TRIANGLES, 0, 3);\n        // 关闭颜色平滑着色设置\n        gl.glDisableClientState(GL10.GL_COLOR_ARRAY);\n        //gl.glFinish();\n\n    }\n}\n```\n在MainActivity中直接调用setRenderer即可\n```java\n    mGLSurfaceView = (GLSurfaceView) findViewById(R.id.glsv_main);\n    mGLSurfaceView.setRenderer(new SunnyGLRender());\n```\n\n\n\n# 参考\n[GLSurfaceView.Renderer](https://developer.android.com/reference/android/opengl/GLSurfaceView.Renderer.html)  \n[SurfaceView入门学习](http://www.jianshu.com/p/15060fc9ef18)\n","tags":["OpenGL"],"categories":["Android"]},{"title":"RxJava (四)","url":"/2017/11/01/rxjava-4/","content":"Backpressure背压和Flowable\n<!-- more -->\n## Cold and Hold Observables\nRxjava的Observable有Hot和Cold两种，一个是火辣美眉，主动出击，不管有没有Observer订阅，Observer中途订阅也无法接受到之前的数据。一个是高冷女神，坐等撩拨，只有Observer订阅的时候，才会开始发送数据，而且如果有多个Observer中途订阅，Cold Observable也会把之前的数据流依次发送给Observer。\n\n\n### Cold Observables\nRxJava创建型操作符[Interval](https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Interval.html)就是个典型的Cold Observable，他会根据你给的时间间隔，来依次发送0,1,2...直接看代码吧\n```java\n    public static void main(String[] args) throws Exception {\n\n        Observable<Long> cold = Observable.interval(200, TimeUnit.MILLISECONDS);\n        try {\n\n            cold.subscribe(i -> System.out.println(\"First: \" + i));\n            Thread.sleep(400);\n            cold.subscribe(i -> System.out.println(\"Second: \" + i));\n            Thread.sleep(1000);\n        } catch (Exception e) {\n        }\n\n    }\n```\n输出\n```\nFirst: 0\nFirst: 1\nFirst: 2\nSecond: 0\nFirst: 3\nSecond: 1\nFirst: 4\nSecond: 2\n```\n该Observable 200ms发送1次数据，在400ms之后，新增一个Observer，观察日志发现Second也是从0开始接收的。\n\n### Hot Observables\n使用 publish 操作函数可以把 Cold Observable 转化为 ConnectableObservable，实际上就是一个Hot Observable，代码如下\n```java\n   public static void main(String[] args) throws Exception {\n\n        ConnectableObservable hot = Observable.create(observableEmitter -> {\n            new Thread(()->{\n                int i = 0;\n                while (i < 20) {\n                    observableEmitter.onNext(i++);\n                    try {\n                        Thread.sleep(200);\n                    } catch (InterruptedException e) {\n                    }\n                }\n            }).start();\n\n        }).publish();\n\n        hot.connect();\n        hot.subscribe(i -> System.out.println(\"First: \" + i));\n        Thread.sleep(400);\n        hot.subscribe(i -> System.out.println(\"Second: \" + i));\n        Thread.sleep(10000);\n    }\n```\n输出\n```\nFirst: 1\nFirst: 2\nFirst: 3\nSecond: 3\nFirst: 4\nSecond: 4\nFirst: 5\nSecond: 5\nFirst: 6\nSecond: 6\nFirst: 7\nSecond: 7\n```\n看见没，这回Second中途插进来，只能接收到当时发送的3,1和2都没啦。  \n对Hot Observable来说，同一时刻Observer收到的都是相同的数据。\n\n## 背压BackPressure \nBackPressure是什么？  \n官方的原文是`in order to alleviate the problems caused when a quickly-producing Observable meets a slow-consuming observer.`简而言之，就是一种缓解**Observable发送速度与Observer处理速度不匹配**的一种策略。\n\n### MissingBackpressureException\n在**RxJava1**中，如果Observable发送事件的速度远远超过了Observer的接收处理速度，即上下游速率不匹配的时候，就会跑出一个 MissingBackpressureException，错误代码如下：\n```java\n        Observable\n                .interval(20, TimeUnit.MILLISECONDS)\n                .take(Integer.MAX_VALUE)\n                .subscribe(cLong->{\n                    Thread.sleep(1000);\n                    System.out.println(cLong);\n                });\n```\n上游的Observable每隔20ms就发送1个值，而下游1000ms才处理1次。没被处理的数据就会被存到内存中，根据Rxjava1的源码得知，当内存中暂存的数据超过128个的时候，就会抛出MissingBackpressureException了。\n### Flowable\n为什么上面要强调在RxJava1中呢，因为在RxJava2中Observable中没背压这个概念，官方引入了FLowable这个类来专门做背压的处理。上述同样的代码，只会引发OOM而不是MissingBackpressureException。  \n来看看FLowable的简单使用：\n```java\n    public static void main(String[] args) throws Exception {\n        System.out.println(Flowable.bufferSize());\n        \n        Flowable.create(flowableEmitter -> {\n                    for (int i = 0; i < 1000; i++) {\n                        flowableEmitter.onNext(i);\n                    }\n                }\n                , BackpressureStrategy.DROP)\n                .observeOn(Schedulers.newThread())\n                .subscribeOn(Schedulers.io())\n                .subscribe(cLong -> {\n                    Thread.sleep(100);\n                    System.out.println(\"recv\" + cLong);\n                });\n\n\n        Thread.sleep(100000);\n    }\n```\n输出\n```\n128\nrecv0\nrecv1\nrecv2\nrecv3\nrecv4\nrecv5\n...\nrecv124\nrecv125\nrecv126\nrecv127\n```\n内部flowableEmitter的数据流来自于一个Observable，也是起到interval的效果。第一行输出FLowable内置的BufferSize缓存区大小为128，同时设置背压策略为`BackpressureStrategy.DROP`，所以在发送和接收速率不匹配的时候，上游只会缓存128个值，剩下的DROP掉了，这也说明了为什么输出只到recv127。\n\n\n","tags":["RxJava"],"categories":["Android"]},{"title":"浅析Android进程间通信（二）","url":"/2017/10/28/android-ipc2/","content":"结合Linux下IPC机制来简单分析Android底层的Binder机制\n<!-- more -->\n# Linux系统的进程间通信\n## 信号\n信号是Unix/Linux系统在一定条件下生成的事件。信号是一种异步通信机制，信号会通知 接收信号的进程 发生了某个事件，然后操作系统将会中断该进程的执行，跳转去执行相应的信号处理程序。  \n听起来像什么？想不想硬件上面电信号对CPU的中断，一个意思的，就是信号这个是软件层模拟的对进程的一种中断形式，深入我就没了解了，有需要自己去百度。\n## 管道\n通过管道来实现IPC主要有3种\n- popen()和pclose()函数\n- pipe()函数\n- 命名管道FIFO\n\n### popen() pclose()\n```c\n#include <stdio.h>\nFILE *popen(const char *cmdstring, const char *type);\n返回值：若成功则返回文件指针，若出错则返回NULL\n\nint pclose(FILE *fp);\n返回值：cmdstring的终止状态，若出错则返回-1\n```\npopen()函数的返回值是一个普通的标准I/O流, 它只能用 pclose() 函数来关闭/如果type是'w'，则返回的文件指针是可写的，通过这个流的写入的内容会被转化为shell命令的标准输入（就是会让读这个管道的进程执行相应的shell命令？）  \nfp = popen（cmdstring， \"w\"）：  \n![](http://images.cnitblog.com/blog/468825/201402/221953109902246.jpg)  \nfp = popen（cmdstring， \"r\"）   \n![](http://images.cnitblog.com/blog/468825/201402/221953097004287.jpg)\n### pipe()\npipe()函数可以返回两个管道描述符:pipefd[0]和pipefd[1]，任何写入pipefd[1]的数据都可以从pipefd[0]读回；pipe()函数返回的是文件描述符(file descriptor)，因此只能使用底层的read()和write()系统调用来访问。pipe()函数通常用来实现父子进程之间的通信：\n ![](http://img.blog.csdn.net/20161223173958916)\n\n### FIFO\n终于到我大FIFO了，有没有发现前面的2种方法只能用在相关的进程中，如果2个啥关系也没有的进程怎么通过一样的原理（一个写，一个读）来实现IPC呢。  \n这就要用到命名管道FIFO了，让2个进程都打开同一个文件（特殊文件），来实现数据交换  \n 写：\n ```\n   /* open函数以O_WRONLY方式打开FIFO文件,如果成功pipe_fd指向打开的文件 */  \n    pipe_fd = open(FIFO_NAME, O_WRONLY);  \n    /* 再使用write函数来把buffer中的内容写到fifo文件中，成功则返回实际写入的字节数 */  \n    res = write(pipe_fd, buffer, BUFFER_SIZE);  \n ```\n读：\n```\n    /* open函数打开FIFO_NAME文件,以O_RDONLY的方式(即只读) \n     * 如果成功,则返回文件描述符 */  \n    pipe_fd = open(FIFO_NAME, O_RDONLY);  \n    /* 再使用read函数来读取fifo文件中的内容到buffer中 */  \n    res = read(pipe_fd, buffer, BUFFER_SIZE);  \n```\n读写之间的阻塞操作是由系统的来调度的，具体参考参考中的FIFO读写规则。\n\n# Android系统的进程间通信\nok，终于把linux的ipc大致理了一下，为什么在说Android的进程间通信之前，要先把linux的下面的说一下？因为Android是基于Linux的，实现的思路肯定也会有参考原有的思想，还有就是我也是刚学，多写一写记得牢一些。。  \n关于Android系统下的IPC我不打算像网上那样贴一大堆代码，只见树木不见森林，我就说几句话，毕竟是做笔记成分多一点，能不能懂就看个人了  \nAndroid系统的IPC包括以下4个主要项：\n- Binder驱动\n- ServiceManager\n- Server(Remote Service)\n- Client\n\n套用一句别人的话：\n> Binder框架定义了四个角色：Server，Client，ServiceManager以及Binder驱动。其中Server，Client，ServiceManager运行于用户空间，Binder驱动运行于内核空间。这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，ServiceManager是域名服务器（DNS），Binder驱动是路由器。  \n\n\n## Binder驱动\n工作于内核态，提供open()，mmap()，poll()，ioctl()等标准文件操作。  \n一句话，他就相当于管道，ServiceManager、Server和Client实际上都是通过Binder驱动和Binder来打交道，是Android进程间通信的基础桥梁，封装了具体的调用细节。  \n注意区分：Binder驱动和Binder，Binder驱动是Android IPC机制的底层实现，Binder是一个封装了读写细节的类，所有远程服务都要继承Binder。可以理解为1个Binder就是1个服务，他们都是由Binder驱动来调用操作的。\n## ServiceManager\nService会创建了多个Binder的实体，对应着不同的Remote Service（PowerManagerService、ActivityManagerService等，全都继承于Binder，否则怎么能够在Binder驱动中实现通信呢），会向ServiceManager注册，传给ServiceManager需要注册的Binder的名字和引用。作用确实类似于DNS，存放着 名字(域名) 和 引用（ip地址）。  \n但是有没有想过，ServiceManager和Service在不同的进程，怎么实现这两者之间的进程通信呢？  \n所以就有了一个叫做0号Binder的东西，就好比你知道114.114.114.114是国内的通用DNS一样，他们定死了一个Binder，来让其他进程直接通过Binder驱动来默认使用这个0号Binder实现与ServiceManager的进程间通信。  \n## Server\n系统服务，通过Binder驱动调用0号Binder向ServiceManager注册多个系统服务，比如底层的系统电量管理服务，内容（假设）为：\"name = PowerManagerService，addr = 0x001\"。那么在ServiceManager中就会记录下来，远程服务PowerManagerService的Binder引用为0x001。\n## Client\n客户端想要调用某个服务时，也要先通过Binder驱动调用0号Binder来向ServiceManager请求，如果请求的PowerManagerService，那么ServiceManager就会返回PowerManagerService的引用给他，Client就拿到PowerManagerService的Binder引用地址为0x001。然后再通过Binder驱动，与PowerManagerService进行数据交换。\n\n## 总结\n每个远程服务，都是Binder的子类，继承于Binder，使得他们可以基于Binder驱动进行数据读写。可以把Binder认为是每个远程服务派到当前调用服务的用户进程的代表（代理），有什么事，跟我的代表说就行了。通过我的代表来调用我的方法。  \n一次调用系统电量服务，查询电量值的流程如下：  \n系统启动，Server向Binder驱动写入信息流：`使用0号Binder 注册name=PowerManagerService addr=0x001`，那么Binder就会解析，然后找到并调用0号Binder，对0号Binder写入`注册name=PowerManagerService addr=0x001`，然后0号Binder就会调用ServiceManager的方法，注册PowerManagerService。  \nClient向Binder驱动写入信息流`使用0号Binder 查找name=PowerManagerService`，那么Binder就会解析，然后找到并调用0号Binder，向ServiceManager请求得到PowerManagerService的引用地址。然后Binder驱动就把得到的`引用地址=0x001`返回给Client。\nClient再通过向Binder驱动写入请求信息流`使用地址0x001的Binder 执行命令 getPowerValue`，Binder驱动就会解析，然后找到并调用地址为0x001号Binder，写入命令`执行命令 getPowerValue`，那么 `0x001`所对应的Binder就会对他对应的PowerManagerService调用getPowerValue，再把得到的值返回给Binder驱动，Binder驱动再返回给Client，结束调用。\n\n**那么问题来了，Server和Client是怎么和Binder驱动进行通信的呢？**\n\n是通过内存映射，让驱动设备文件映射到用户进程和内核进程，即用户进程地址V1和内核进程地址V2都映射着同一块物理内存，那么用户把进程把数据写到文件上，内核进程自然就能读取到内容，而不需要在copy到内核去。具体查看[binder驱动-------之内存映射篇](http://blog.csdn.net/xiaojsj111/article/details/31422175)\n\n![](http://hi.csdn.net/attachment/201102/27/0_1298798582y7c5.gif)\n\n# 参考\n[popen()和pclose()](http://www.cnblogs.com/nufangrensheng/p/3561190.html)  \n[Linux命名管道FIFO的读写规则](http://blog.csdn.net/MONKEY_D_MENG/article/details/5570468)  \n[Android Binder设计与实现 - 设计篇](http://blog.csdn.net/universus/article/details/6211589)","tags":["IPC"],"categories":["Android"]},{"title":"kotlin委托机制","url":"/2017/10/25/kotlin委托/","content":"Kotlin中的委托机制\n<!-- more -->\n\n## 类委托\nKotlin通过`by`关键字可以简单的实现委托模式。  \n委托模式，用java的话来说，就是通过组合，让类A持有其他类B的实例，然后类A中的部分方法实际上都是通过调用的类B这个实例的方法来实现的。\n\n### kotlin实现委托模式\nActivity中的onClick方法，实际上是委托给OnClickListener的实例来实现的，简单易懂。\n```kotlin\ninterface Listener {\n    fun onClick()\n}\n\nclass OnClickListener : Listener {\n    override fun onClick() {\n        print(\"OnClickListener\")\n    }\n}\n\nclass Activity : Listener {\n    val mListener = OnClickListener()\n    override fun onClick() {\n        mListener.onClick()\n    }\n}\n\nfun main(args: Array<String>) {\n    var act = Activity()\n    act.onClick()\n}\n```\n### by关键字简洁地实现委托模式\n上面的实现，乍一看跟java没两样，可kotlin要的就是简洁、优雅，要是还跟java一样罗里吧嗦，怎么体现这门语言的逼格？所以就引入了 `by` 关键字来实现委托模式。  \n原理都差不多，在类Activity的构造方法中传入OnClickListener实例即可，直接上代码吧。\n```kotlin\ninterface Listener {\n    fun onClick()\n}\n\nclass OnClickListener : Listener {\n    override fun onClick() {\n        print(\"OnClickListener\")\n    }\n}\n\nclass Activity(listener: OnClickListener) : Listener by listener\n\nfun main(args: Array<String>) {\n    var listener = OnClickListener()\n    var act = Activity(listener)\n    act.onClick()\n}\n```\n\n\n## 代理属性\nKotlin也支持代理属性，语法定义如下：  \n`val/var <property name>: <Type> by <expression>`  \n- var/val：属性类型(可变/只读)\n- name：属性名称\n- Type：属性的数据类型\n- expression：代理类\n\n```kotlin\nclass Example {\n    var p: String by Delegate()\n}\n\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, thank you for delegating '${property.name}' to me!\"\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$value has been assigned to '${property.name} in $thisRef.'\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val e = Example()\n    println(e.p)\n    e.p = \"NEW\"\n}\n```\n输出\n```\nExample@25f38edc, thank you for delegating 'p' to me!\nNEW has been assigned to 'p in Example@25f38edc.'\n```\n\nKotlin 标准库为几种常用的代理提供了工厂方法:\n- 延迟加载属性(lazy property): 属性值只在初次访问时才会计算,然后保存结果，后面直接返回这个结果\n- 可观察属性(observable property): 属性发生变化时, 可以向监听器发送通知\n- 将多个属性保存在一个 map 内, 而不是保存在多个独立的域内\n\n\n### 延迟加载的属性\nlazy() 是一个接受 lamdba 并返回一个实现延迟属性的代理：第一次调用 get() 执行 lamdba 并传递 lazy() 并存储结果，以后每次调用 get() 时只是简单返回之前存储的值。\n> 注意: var类型属性不能设置为延迟加载属性，因为在lazy中并没有setValue(…)方法  \nlazy操作符是线程安全的。如果在不考虑多线程问题或者想提高更多的性能，也可以使用lazy(LazyThreadSafeMode.NONE){ … } \n\n\n```kotlin\nfun lazyinit(): Int {\n    println(\"lazy is called\")\n    return 1\n}\n\nval age by lazy {\n    lazyinit()\n}\n\nfun main(args: Array<String>) {\n    println(\"age: $age\") \n    println(\"age: $age\") \n\n}\n```\n输出\n```\nlazy is called\nage: 1\nage: 1\n```\n\n### 可观察的属性\nDelegates.observable() 需要两个参数：一个初始值和一个用于修改的 handler  \nhandler有三个参数：一个将被赋值的属性，旧值，新值。\n```kotlin\nvar name: String by Delegates.observable(\"initName\", {\n    kProperty, oldName, newName ->\n    println(\"kProperty：${kProperty.name} | oldName:$oldName | newName:$newName\")\n})\n\n\nfun main(args: Array<String>) {\n\n    println(\"name: $name\")\n    name = \"newName1\"\n    name = \"newName2\"\n    println(\"name: $name\")\n}\n```\n输出\n```\nname: initName\nkProperty：name | oldName:initName | newName:newName1\nkProperty：name | oldName:newName1 | newName:newName2\nname: newName2\n```\n\nDelegates.vetoable() 也需要两个参数：一个初始值和一个用来在保存新值之前做一些条件判断，来决定是否将新值保存。\n修改上述部分代码：\n```kotlin\nvar name: String by Delegates.vetoable(\"initName\", {\n    kProperty, oldName, newName ->\n    println(\"kProperty：${kProperty.name} | oldName:$oldName | newName:$newName\")\n    newName.contains(\"1\")\n})\n```\n输出\n```\nname: initName\nkProperty：name | oldName:initName | newName:newName1\nkProperty：name | oldName:newName1 | newName:newName2\nname: newName1\n```\n\n### 在 Map 中存储属性\n把属性值存储在 map 中是一种常见的使用方式，这种操作经常出现在解析 JSON 或者其它动态的操作中。这种情况下你可以使用 map 来代理它的属性。\n\n```\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n\nfun main(args: Array<String>) {\n    val user = User(mapOf(\n            \"name\" to \"John Doe\",\n            \"age\"  to 25\n    ))\n    println(user.name) // Prints \"John Doe\"\n    println(user.age)  // Prints 25\n\n}\n```\n输出\n```\nJohn Doe\n25\n```\nvar 属性可以用 MutableMap 代替只读的 Map\n```\nclass MutableUser(val map: MutableMap<String, Any?>) {\n    var name: String by map\n    var age: Int     by map\n}\n```","tags":["设计模式","Kotlin语法"],"categories":["Kotlin"]},{"title":"RSA/AES加密","url":"/2017/10/25/encrypt/","content":"RSA/AES加密工具类\n<!-- more -->\n\n## RSA\n```java\nimport sun.security.rsa.RSAPrivateCrtKeyImpl;\nimport sun.security.rsa.RSAPublicKeyImpl;\n\nimport javax.crypto.Cipher;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.*;\nimport java.util.Base64;\n\npublic class RSAUtil {\n\n\n    private static final String ALGORITHM = \"RSA\";\n\n\n    //生成密钥对\n    public static KeyPair genKeyPair(int keyLength) throws NoSuchAlgorithmException {\n        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM);\n        keyPairGenerator.initialize(keyLength);\n        return keyPairGenerator.generateKeyPair();\n    }\n\n\n    //以base64编码保存密钥\n    public static void saveKey(Key key, String path) throws IOException {\n        Path keyPath = Paths.get(path);\n        Files.write(keyPath, Base64.getEncoder().encode(key.getEncoded()));\n    }\n\n    //读取公钥\n    public static PublicKey readPublicKey(String path) throws Exception {\n        Path keyPath = Paths.get(path);\n        byte[] keyBytes = Files.readAllBytes(keyPath);\n        return new RSAPublicKeyImpl(Base64.getDecoder().decode(keyBytes));\n    }\n\n    //读取密钥\n    public static PrivateKey readPrivateKey(String path) throws Exception {\n        Path keyPath = Paths.get(path);\n        byte[] keyBytes = Files.readAllBytes(keyPath);\n        return RSAPrivateCrtKeyImpl.newKey(Base64.getDecoder().decode(keyBytes));\n    }\n\n\n    //公钥加密\n    public static String encrypt(String content, PublicKey publicKey) throws Exception {\n        //选择算法,创建实例\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        //选择模式,结合公钥初始化\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        //加密\n        byte[] result = cipher.doFinal(content.getBytes());\n        //转码\n        String base64Result = Base64.getEncoder().encodeToString(result);\n        return base64Result;\n    }\n\n    //私钥解密\n    public static String decrypt(String content, PrivateKey privateKey) throws Exception {\n        //创建实例\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        //初始化\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n        //转码\n        byte[] encodedBytes = Base64.getDecoder().decode(content.getBytes());\n        //解密\n        byte[] result = cipher.doFinal(encodedBytes);\n        return new String(result);\n    }\n\n\n    public static void main(String[] args) {\n\n        try {\n\n            //确保目录存在\n            File f = new File(\"/home/duoyi/encrypt/\");\n            f.mkdirs();\n\n\n            KeyPair keyPair = RSAUtil.genKeyPair(1024);\n\n            //获取公钥\n            PublicKey publicKey = keyPair.getPublic();\n            System.out.println(\"公钥：\" + new String(Base64.getEncoder().encode(publicKey.getEncoded())));\n\n            //获取私钥\n            PrivateKey privateKey = keyPair.getPrivate();\n            System.out.println(\"私钥：\" + new String(Base64.getEncoder().encode(privateKey.getEncoded())));\n\n            //保存密钥\n            RSAUtil.saveKey(publicKey, \"/home/duoyi/encrypt/rsa.pub\");\n            RSAUtil.saveKey(privateKey, \"/home/duoyi/encrypt/rsa.pri\");\n\n\n            String content = \"this is content\";\n\n\n            //读取密钥\n            PublicKey pubKey = RSAUtil.readPublicKey(\"/home/duoyi/encrypt/rsa.pub\");\n            PrivateKey priKey = RSAUtil.readPrivateKey(\"/home/duoyi/encrypt/rsa.pri\");\n\n            //加密\n            String encryptBase64 = RSAUtil.encrypt(content, pubKey);\n\n            //解密\n            String result = decrypt(encryptBase64, priKey);\n\n            System.out.println(\"密文为:\" + new String(Base64.getDecoder().decode(encryptBase64.getBytes())));\n            System.out.println(\"密文转码后为:\" + encryptBase64);\n            System.out.println(\"转码后解码为:\" + result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n\n```\n输出\n```\n公钥：MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCwX7B6S8teU8b7YXgaT9kOoJXP6GHrPnrV9VNQUrKYP701dsIVzWuTCxqp99JJTtRb6KRhzpTdUkwG4bWLVq5mhBb5ItglV6sU9bXQdx8Lc69xKQ0+5W6WvGYfosQEdv/h3eKvQEPbs5rGfoTka4u3Gh4Ncf9McYzI6O5E+eHQRQIDAQAB\n私钥：MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALBfsHpLy15TxvtheBpP2Q6glc/oYes+etX1U1BSspg/vTV2whXNa5MLGqn30klO1FvopGHOlN1STAbhtYtWrmaEFvki2CVXqxT1tdB3Hwtzr3EpDT7lbpa8Zh+ixAR2/+Hd4q9AQ9uzmsZ+hORri7caHg1x/0xxjMjo7kT54dBFAgMBAAECgYBfg4KLyC4bKB1zFya2gRVYAYj/7aXRgqV85v02W4KSRrpNkMGskvE10WagMy/zOThxiXwz527gqGe5tlPdYJTS03zZlgky1IwL80ZN6F5CIc2LzDTkbDHXHIG5kMt4OOZf/UtM4W+lCNGt4azt5sWlIOoWE6vXQOLfv1eUiQfsAQJBANdThIeP+O4kn0MA2QWkcV39v4ZBnftK4wsXvrFOhMBceiSqJCPwpU2/Tf65JO0KH3lEo/s+ZUjctz2SFX/yc0UCQQDRsI6And20aZi4+SaRnK/4BZIWbklchdkrWloWRj0Rp/NBi9p4lX9ZCNQs0zPDo8pRY2Qvhlj7yuPUHnMPATkBAkEAu/5c3QZj7Xbn3VXmJDj4CXm7N3oedgFhzJOEl8TXviJ/OXeaag52JDT74YK/rHyEEhpNmNNXFpAtI4JhZv3EiQJAPgvAHs6Xi4qzZghTIUL7zqfXUkvP6VCxseJKRc0CxPatQ/fd7VBPHkk+fwT/jCQq+WoveuCF8/tU7q8T3JzAAQJAOXPzNmxQaD+Jt7I8nbJdU70lpRkuU2dwhmOG9DS8ICwo2JGk5woXbUfGTA7DW5K9MMb3oz9cjWV0Dj+tLJicYA==\n�nL��߫�0�\u0019GR�mĨ�\u0010�\u001d��\u001b��\u0004������m+��9u�\u001d\u0017}0�\u001f�5H�_B��\u000b9�'�\"\u001bvU������ކ?~_f�ϭ˪=��ʩ�/�O�\u0007T��q�\u0019�\"�jn4�}\n密文转码后为:ORHTTIVB8bRDeFGU5SZNyELbU32ADdduTJvs36vwMLUZR1KVbcSo574Qxx3wzBu+tQSJ0dn4pcVtK6T4OXXSHRd9MP4f+TVImV9C/LoLOeMnyCIbdlW2j6TIw/Xehj9+X2bez63Lqj3D68qpuC/pT+EHVK+icfwZ5iL+am405H0=\n转码后解码为:this is content\n```\n\n## AES\n```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class AESUtil {\n\n    public static final String ALGORITHM = \"AES\";\n    public static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\n\n\n    //选择算法,根据密码生成密钥\n    public static SecretKey genKey(String password) throws NoSuchAlgorithmException {\n        KeyGenerator keyGenerator = KeyGenerator.getInstance(ALGORITHM);\n        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n        random.setSeed(password.getBytes());//设置密钥\n        keyGenerator.init(random);\n        return keyGenerator.generateKey();\n    }\n\n    //以base64编码保存密钥\n    public static void saveKey(Key key, String path) throws IOException {\n        Path keyPath = Paths.get(path);\n        Files.write(keyPath, Base64.getEncoder().encode(key.getEncoded()));\n    }\n\n    //读取密钥\n    public static SecretKey readSecretKey(String path) throws Exception {\n        Path keyPath = Paths.get(path);\n        byte[] keyBytes = Files.readAllBytes(keyPath);\n        return new SecretKeySpec(Base64.getDecoder().decode(keyBytes), ALGORITHM);\n    }\n\n\n    public static String encrypt(String content, SecretKey secretKey) throws Exception {\n        //指定算法创建Cipher实例\n        Cipher cipher = Cipher.getInstance(ALGORITHM);//算法是AES\n        //选择模式，结合密钥初始化Cipher实例\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        //加密\n        byte[] result = cipher.doFinal(content.getBytes());\n        //使用Base64对密文进行转码\n        String base64Result = Base64.getEncoder().encodeToString(result);\n        return base64Result;\n    }\n\n\n    public static String decrpyt(String content, SecretKey secretKey) throws Exception {\n        //获取实例\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        //初始化\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        //转码\n        byte[] encodedBytes = Base64.getDecoder().decode(content.getBytes());\n        //解密\n        byte[] result = cipher.doFinal(encodedBytes);\n        return new String(result);\n    }\n\n    public static void main(String[] args) {\n        try {\n            //确保目录存在\n            File f = new File(\"/home/duoyi/encrypt/\");\n            f.mkdirs();\n\n            String content = \"this is content\";\n            String password = \"passwd\";\n\n            SecretKey key = AESUtil.genKey(password);\n\n            AESUtil.saveKey(key, \"/home/duoyi/encrypt/aes.key\");\n\n            String encryptBase64 = AESUtil.encrypt(content, key);\n\n            SecretKey readKey = AESUtil.readSecretKey(\"/home/duoyi/encrypt/aes.key\");\n            String result = AESUtil.decrpyt(encryptBase64, readKey);\n\n            System.out.println(\"密文为:\" + new String(Base64.getDecoder().decode(encryptBase64.getBytes())));\n            System.out.println(\"密文转码后为:\" + encryptBase64);\n            System.out.println(\"转码后解码为:\" + result);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n\n        }\n    }\n\n}\n```\n输出\n```\n密文为:�\u0012���������Fq<\n密文转码后为:/hKckfWZxuqJ467Rx0ZxPA==\n转码后解码为:this is content\n```","tags":["加密"],"categories":["Android代码库"]},{"title":"Android Dialog 帮助类","url":"/2017/10/24/and-util-dialog/","content":"快速生成Dialog的封装类，来自开源中国客户端\n<!-- more -->\n## 代码\n```java\n\nimport android.app.ProgressDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.support.v7.app.AlertDialog;\nimport android.support.v7.widget.AppCompatEditText;\nimport android.support.v7.widget.GridLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.text.TextUtils;\nimport android.view.View;\nimport android.view.ViewGroup;\n\n\nimport static android.view.View.OVER_SCROLL_NEVER;\n\n/**\n * 通用的对话框\n * Created by haibin\n * on 2016/11/2.\n */\n@SuppressWarnings(\"all\")\npublic final class DialogHelper {\n    public static AlertDialog.Builder getDialog(Context context) {\n        return new AlertDialog.Builder(context);\n    }\n\n    /**\n     * 获取一个普通的消息对话框，没有取消按钮\n     */\n    public static AlertDialog.Builder getMessageDialog(\n            Context context,\n            String title,\n            String message,\n            boolean cancelable) {\n        return getDialog(context)\n                .setCancelable(cancelable)\n                .setTitle(title)\n                .setMessage(message)\n                .setPositiveButton(\"确定\", null);\n    }\n\n    /**\n     * 获取一个普通的消息对话框，没有取消按钮\n     */\n    public static AlertDialog.Builder getMessageDialog(\n            Context context,\n            String title,\n            String message) {\n        return getMessageDialog(context, title, message, true);\n    }\n\n    /**\n     * 获取一个普通的消息对话框，没有取消按钮\n     */\n    public static AlertDialog.Builder getMessageDialog(Context context, String message) {\n        return getMessageDialog(context, \"\", message, true);\n    }\n\n    /**\n     * 获取一个普通的消息对话框，没有取消按钮\n     */\n    public static AlertDialog.Builder getMessageDialog(\n            Context context,\n            String title,\n            String message,\n            String positiveText) {\n        return getDialog(context)\n                .setCancelable(true)\n                .setTitle(title)\n                .setMessage(message)\n                .setPositiveButton(positiveText, null);\n    }\n\n    public static AlertDialog.Builder getConfirmDialog(Context context,\n                                                       String title,\n                                                       View view,\n                                                       DialogInterface.OnClickListener positiveListener) {\n        return getDialog(context)\n                .setTitle(title)\n                .setView(view)\n                .setPositiveButton(\"确定\", positiveListener)\n                .setNegativeButton(\"取消\", null);\n    }\n\n    /**\n     * 获取一个验证对话框\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context,\n            String title,\n            String message,\n            String positiveText,\n            String negativeText,\n            boolean cancelable,\n            DialogInterface.OnClickListener positiveListener,\n            DialogInterface.OnClickListener negativeListener) {\n        return getDialog(context)\n                .setCancelable(cancelable)\n                .setTitle(title)\n                .setMessage(message)\n                .setPositiveButton(positiveText, positiveListener)\n                .setNegativeButton(negativeText, negativeListener);\n    }\n\n    /**\n     * 获取一个验证对话框\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context, String message,\n            DialogInterface.OnClickListener positiveListener,\n            DialogInterface.OnClickListener negativeListener) {\n        return getDialog(context)\n                .setMessage(message)\n                .setPositiveButton(\"确定\", positiveListener)\n                .setNegativeButton(\"取消\", negativeListener);\n    }\n\n    public static AlertDialog.Builder getSingleChoiceDialog(\n            Context context,\n            String title,\n            String[] arrays,\n            int selectIndex,\n            DialogInterface.OnClickListener onClickListener) {\n        AlertDialog.Builder builder = getDialog(context);\n        builder.setSingleChoiceItems(arrays, selectIndex, onClickListener);\n        if (!TextUtils.isEmpty(title)) {\n            builder.setTitle(title);\n        }\n        builder.setNegativeButton(\"取消\", null);\n        return builder;\n    }\n\n\n    /**\n     * 获取一个验证对话框，没有点击事件\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context,\n            String title,\n            String message,\n            String positiveText,\n            String negativeText,\n            boolean cancelable,\n            DialogInterface.OnClickListener positiveListener) {\n        return getConfirmDialog(\n                context, title, message, positiveText,\n                negativeText, cancelable, positiveListener, null);\n    }\n\n    /**\n     * 获取一个验证对话框，没有点击事件\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context,\n            String title,\n            String message,\n            String positiveText,\n            String negativeText,\n            DialogInterface.OnClickListener positiveListener) {\n        return getConfirmDialog(\n                context, title, message, positiveText, negativeText, true, positiveListener, null);\n    }\n\n\n    /**\n     * 获取一个验证对话框，没有点击事件\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context,\n            String title,\n            String message,\n            String positiveText,\n            String negativeText,\n            boolean cancelable) {\n        return getConfirmDialog(\n                context, title, message, positiveText, negativeText, cancelable, null, null);\n    }\n\n    /**\n     * 获取一个验证对话框，没有点击事件\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context,\n            String message,\n            String positiveText,\n            String negativeText,\n            boolean cancelable) {\n        return getConfirmDialog(context, \"\", message, positiveText, negativeText\n                , cancelable, null, null);\n    }\n\n    /**\n     * 获取一个验证对话框，没有点击事件，取消、确定\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context,\n            String title,\n            String message,\n            boolean cancelable) {\n        return getConfirmDialog(context, title, message, \"确定\", \"取消\", cancelable, null, null);\n    }\n\n    /**\n     * 获取一个验证对话框，没有点击事件，取消、确定\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context,\n            String message,\n            boolean cancelable,\n            DialogInterface.OnClickListener positiveListener) {\n        return getConfirmDialog(context, \"\", message, \"确定\", \"取消\", cancelable, positiveListener, null);\n    }\n\n    /**\n     * 获取一个验证对话框，没有点击事件，取消、确定\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context,\n            String message,\n            DialogInterface.OnClickListener positiveListener) {\n        return getConfirmDialog(context, \"\", message, \"确定\", \"取消\", positiveListener);\n    }\n\n    /**\n     * 获取一个验证对话框，没有点击事件，取消、确定\n     */\n    public static AlertDialog.Builder getConfirmDialog(\n            Context context,\n            String title,\n            String message) {\n        return getConfirmDialog(context, title, message, \"确定\", \"取消\", false, null, null);\n    }\n\n    /**\n     * 获取一个输入对话框\n     */\n    public static AlertDialog.Builder getInputDialog(\n            Context context,\n            String title,\n            AppCompatEditText editText,\n            String positiveText,\n            String negativeText,\n            boolean cancelable,\n            DialogInterface.OnClickListener positiveListener,\n            DialogInterface.OnClickListener negativeListener) {\n        return getDialog(context)\n                .setCancelable(cancelable)\n                .setTitle(title)\n                .setView(editText)\n                .setPositiveButton(positiveText, positiveListener)\n                .setNegativeButton(negativeText, negativeListener);\n    }\n\n    /**\n     * 获取一个输入对话框\n     */\n    public static AlertDialog.Builder getInputDialog(\n            Context context, String title,\n            AppCompatEditText editText,\n            String positiveText,\n            String negativeText,\n            boolean cancelable,\n            DialogInterface.OnClickListener positiveListener) {\n        return getInputDialog(\n                context,\n                title,\n                editText,\n                positiveText,\n                negativeText,\n                cancelable,\n                positiveListener,\n                null);\n    }\n\n    /**\n     * 获取一个输入对话框\n     */\n    public static AlertDialog.Builder getInputDialog(\n            Context context,\n            String title,\n            AppCompatEditText editText,\n            boolean cancelable,\n            DialogInterface.OnClickListener positiveListener) {\n        return getInputDialog(context, title, editText, \"确定\", \"取消\"\n                , cancelable, positiveListener, null);\n    }\n\n    /**\n     * 获取一个输入对话框\n     */\n    public static AlertDialog.Builder getInputDialog(\n            Context context, String title, AppCompatEditText editText, String positiveText,\n            boolean cancelable,\n            DialogInterface.OnClickListener positiveListener,\n            DialogInterface.OnClickListener negativeListener) {\n        return getInputDialog(\n                context, title, editText, positiveText, \"取消\", cancelable\n                , positiveListener, negativeListener);\n    }\n\n    /**\n     * 获取一个输入对话框\n     */\n    public static AlertDialog.Builder getInputDialog(\n            Context context, String title, AppCompatEditText editText,\n            boolean cancelable,\n            DialogInterface.OnClickListener positiveListener,\n            DialogInterface.OnClickListener negativeListener) {\n        return getInputDialog(\n                context, title, editText, \"确定\", \"取消\", cancelable\n                , positiveListener, negativeListener);\n    }\n\n\n    /**\n     * 获取一个等待对话框\n     */\n    public static ProgressDialog getProgressDialog(Context context) {\n        return new ProgressDialog(context);\n    }\n\n    /**\n     * 获取一个等待对话框\n     */\n    public static ProgressDialog getProgressDialog(Context context, boolean cancelable) {\n        ProgressDialog dialog = getProgressDialog(context);\n        dialog.setCancelable(cancelable);\n        return dialog;\n    }\n\n    /**\n     * 获取一个等待对话框\n     */\n    public static ProgressDialog getProgressDialog(Context context, String message) {\n        ProgressDialog dialog = getProgressDialog(context);\n        dialog.setMessage(message);\n        return dialog;\n    }\n\n    /**\n     * 获取一个等待对话框\n     */\n    public static ProgressDialog getProgressDialog(\n            Context context, String title, String message, boolean cancelable) {\n        ProgressDialog dialog = getProgressDialog(context);\n        dialog.setCancelable(cancelable);\n        dialog.setTitle(title);\n        dialog.setMessage(message);\n        return dialog;\n    }\n\n    /**\n     * 获取一个等待对话框\n     */\n    public static ProgressDialog getProgressDialog(\n            Context context, String message, boolean cancelable) {\n        ProgressDialog dialog = getProgressDialog(context);\n        dialog.setCancelable(cancelable);\n        dialog.setMessage(message);\n        return dialog;\n    }\n\n    public static AlertDialog.Builder getSelectDialog(\n            Context context, String title, String[] items,\n            String positiveText,\n            DialogInterface.OnClickListener itemListener) {\n        return getDialog(context)\n                .setTitle(title)\n                .setItems(items, itemListener)\n                .setPositiveButton(positiveText, null);\n\n    }\n\n    public static AlertDialog.Builder getSelectDialog(\n            Context context, String[] items,\n            String positiveText,\n            DialogInterface.OnClickListener itemListener) {\n        return getDialog(context)\n                .setItems(items, itemListener)\n                .setPositiveButton(positiveText, null);\n\n    }\n\n    public static AlertDialog.Builder getSelectDialog(Context context, View view, String positiveText,\n                                                      DialogInterface.OnClickListener itemListener) {\n        return getDialog(context)\n                .setView(view)\n                .setPositiveButton(positiveText, null);\n    }\n\n//    public static AlertDialog.Builder getRecyclerViewDialog(Context context, BaseRecyclerAdapter.OnItemClickListener listener) {\n//        RecyclerView recyclerView = new RecyclerView(context);\n//        RecyclerView.LayoutParams params =\n//                new GridLayoutManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);\n//        recyclerView.setPadding(Util.dipTopx(context, 16), Util.dipTopx(context, 16),\n//                Util.dipTopx(context, 16), Util.dipTopx(context, 16));\n//        recyclerView.setLayoutParams(params);\n//        recyclerView.setLayoutManager(new GridLayoutManager(context, 3));\n//        CommentItemAdapter adapter = new CommentItemAdapter(context);\n//        adapter.setOnItemClickListener(listener);\n//        recyclerView.setAdapter(adapter);\n//        recyclerView.setOverScrollMode(OVER_SCROLL_NEVER);\n//        return getDialog(context)\n//                .setView(recyclerView)\n//                .setPositiveButton(null, null);\n//    }\n}\n\n```\n## 使用\n```java\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.support.v7.widget.AppCompatEditText;\nimport android.view.View;\nimport android.widget.EditText;\nimport android.widget.TextView;\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n\n\n    Context mContext;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mContext = MainActivity.this;\n        findViewById(R.id.btn_message_dialog).setOnClickListener(this);\n        findViewById(R.id.btn_confirm_dialog).setOnClickListener(this);\n        findViewById(R.id.btn_input_dialog).setOnClickListener(this);\n        findViewById(R.id.btn_progress_dialog).setOnClickListener(this);\n        findViewById(R.id.btn_select_dialog).setOnClickListener(this);\n\n\n    }\n\n    @Override\n    public void onClick(View view) {\n        switch (view.getId()){\n            case R.id.btn_message_dialog:\n                DialogHelper.getMessageDialog(mContext,\"This is a msg dialog\").show();\n                break;\n            case R.id.btn_confirm_dialog:\n                DialogHelper.getConfirmDialog(mContext,\"This is Title\",\"This is a msg dialog\").show();\n                break;\n            case R.id.btn_input_dialog:\n                AppCompatEditText editText = new AppCompatEditText(mContext);\n                DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n\n                    }\n                };\n                DialogHelper.getInputDialog(mContext,\"This is Title\",editText,false,listener).show();\n                break;\n            case R.id.btn_progress_dialog:\n                DialogHelper.getProgressDialog(mContext).show();\n                break;\n            case R.id.btn_select_dialog:\n                DialogHelper.getSelectDialog(mContext, \"This is Title\", new String[]{\"item1\", \"item2\"}, \"positiveText\",\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialogInterface, int i) {\n\n                            }\n                        }).show();\n                break;\n            default:;\n        }\n    }\n}\n```\n","tags":["Dialog"],"categories":["Android代码库"]},{"title":"浅析Android进程间通信（一）","url":"/2017/10/19/android-ipc/","content":"简单介绍使用AIDL来实现进程间通信。\n<!-- more -->\n## 序列化接口Parcelable\n### 为什么会有序列化这么个东西？   \n简单说就是为了保存在内存中的各种对象的状态，并且可以把保存的对象状态再读出来。  \n虽然你可以用你自己的各种各样的方法来保存，但是Java已经提供一个完善的接口来进行序列化的工作,那就是Serializable。 \n\n### 序列化的使用场景\n\n1. 永久性保存对象，保存对象的字节序列到本地文件中；\n2. 通过序列化对象在网络中传递对象；\n3. 通过序列化在进程间传递对象。\n\n### Parcelable又是什么？  \nParcelable是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC） \n### Parcelable和Serializable如何选择？\n  1. 在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。  \n  2. Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。  \n  3. Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。\n\n> 注意：writeToParcel和参数为Parcel的构造方法，里面的读写顺序一定要一致  \n\n## Android 进程间通信(IPC)\n假设要做一个音乐播放的App，除去前台UI展示，还要能够后台播放，实现方案分析可以查看这篇[博文](http://blog.csdn.net/seu_calvin/article/details/53932171)，讲的很深入了。\n我们就采用多进程的方式来实现这个需求吧。\n\n### 项目结构\n\n![](http://owu391pls.bkt.clouddn.com/ss20171016210148.png)\n![](http://owu391pls.bkt.clouddn.com/2017-10-24%2022-00-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)  \n\nProject视图下可能看的更清楚，在AS中new直接选择AIDL-AIDL File即可自动生成。\n- MediaService就是跑在另一个进程中的后台服务，负责播放音乐文件。\n- MusicTrack是bean类。\n- 要想在AIDL使用到bean类，需要生命与java文件对应的同名aidl文件，即 MusicTrack.aidl\n- MusicAIDLService.aidl 就是远程服务接口声明。\n\n> 注意同名的java文件和aild文件的包名需要一样。\n\n### 代码\n在写完AIDL和bean类之后，编译一下工程，AS会自动生成后续我们需要使用的代理类 MusicAIDLService.Stub，这个类是AS根据AIDL文件，自动创建的，在\n`app/build/generated/source/aidl/debug/`目录下， MusicAIDLService.Stub就是一个Binder的子类，后续就跟普通的Service的使用没有区别了。\n```java\n//MusicAIDLService.aidl 声明远程进程方法 在Service重载\npackage com.dongua.ipc.service;\nimport com.dongua.ipc.service.MusicTrack;\n\ninterface MusicAIDLService{\n    void play();\n    void pause();\n    void stop();\n    void prev();\n    void next();\n    MusicTrack getCurrentTrack();\n}\n```\n\n```java\n//MusicTrack.aidl \npackage com.dongua.ipc.service;\nparcelable MusicTrack;\n```\n```java\n//MusicTrack.java 用来多进程之间传输的数据需要实现Parcelable接口\npublic class MusicTrack implements Parcelable {\n\n    public String mTitle;\n    public String mAlbum;\n    public String mArtist;\n\n    public MusicTrack(Parcel in) {\n        mTitle = in.readString();\n        mArtist = in.readString();\n        mAlbum = in.readString();\n    }\n\n    public static final Creator<MusicTrack> CREATOR = new Creator<MusicTrack>() {\n        @Override\n        public MusicTrack createFromParcel(Parcel in) {\n            return new MusicTrack(in);\n        }\n\n        @Override\n        public MusicTrack[] newArray(int size) {\n            return new MusicTrack[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(mTitle);\n        dest.writeString(mAlbum);\n        dest.writeString(mArtist);\n    }\n}\n```\n\n```java\npublic class MediaService extends Service {\n\n    private static final String TAG = \"MediaService\";\n\n    private Binder mBinder = new MusicAIDLService.Stub() {\n        @Override\n        public void play() throws RemoteException {\n            Log.i(TAG, \"play: \");\n        }\n\n        @Override\n        public void pause() throws RemoteException {\n            Log.i(TAG, \"pause: \");\n\n        }\n\n        @Override\n        public void stop() throws RemoteException {\n            Log.i(TAG, \"stop: \");\n        }\n\n        @Override\n        public void prev() throws RemoteException {\n            Log.i(TAG, \"prev: \");\n        }\n\n        @Override\n        public void next() throws RemoteException {\n            Log.i(TAG, \"next: \");\n        }\n\n        @Override\n        public MusicTrack getCurrentTrack() throws RemoteException {\n            Log.i(TAG, \"getCurrentTrack: \");\n            return null;\n        }\n    };\n\n\n\n\n    @Override\n    public void onCreate() {\n        Log.i(TAG, \"onCreate: \");\n        super.onCreate();\n    }\n\n    @Override\n    public void onDestroy() {\n        Log.i(TAG, \"onDestroy: \");\n        super.onDestroy();\n    }\n\n    @Override\n    public int onStartCommand(Intent intent,  int flags, int startId) {\n        Log.i(TAG, \"onStartCommand: \");\n        return super.onStartCommand(intent, flags, startId);\n    }\n\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.i(TAG, \"onBind: \");\n        return mBinder;\n    }\n\n\n}\n\n```\n\n```java\n//MainActivity.java\n    private MusicAIDLService mMusicService ;\n    private ServiceConnection mConnection = new ServiceConnection(){\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            mMusicService = (MusicAIDLService) MusicAIDLService.Stub.asInterface(service);\n            try {\n                mMusicService.play();\n                mMusicService.pause();\n                mMusicService.stop();\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n```\n\n\n输出  \n\n```\n10-16 20:58:48.257 22211-22211/com.dongua.ipc:music I/MediaService: onCreate: \n10-16 20:58:48.257 22211-22211/com.dongua.ipc:music I/MediaService: onBind: \n10-16 20:58:48.261 22211-22268/com.dongua.ipc:music I/MediaService: play: \n10-16 20:58:48.261 22211-22223/com.dongua.ipc:music I/MediaService: pause: \n10-16 20:58:48.262 22211-22225/com.dongua.ipc:music I/MediaService: stop: \n10-16 20:58:51.633 22211-22211/com.dongua.ipc:music I/MediaService: onDestroy: \n```\n\n\n如果你只是想要了解如何使用AIDL来完成进程间的通信，实现功能即可，对底层的细节不感兴趣，那么后续的直接套上面的模板来，或者使用基于AIDL封装的更加完善的Messenger（注意与Message区别）来完成相应的需求即可。\n\n\n## 参考\n[深入分析Java的序列化与反序列化](http://www.importnew.com/18024.html)  \n[序列化原理机制浅谈](http://blog.csdn.net/morethinkmoretry/article/details/5929345#comments)\n","tags":["IPC"],"categories":["Android"]},{"title":"ClassLoader 相关面试题","url":"/2017/10/17/classloader2/","content":"\n检测你是否掌握了[ClassLoader的基础知识](https://melonwxd.github.io/2017/10/17/classloader1/)\n<!-- more -->\n\n## 能不能自己写个类叫java.lang.System？  \n有这么一道面试题：能不能自己写个类叫java.lang.System？  \n先假设，如果我们要写一个java.lang.System这个类，结合上述知识，能否拿出什么合理的方案呢？  \n### 分析1：双亲委托原则\n想要 jvm 载入 java.lang.System 这个类，根据双亲委托原则，会先去内存查找，看是否已经加载了。真正的java.lang.System是由BootstrapClassloader加载的（由System.class.getClassLoader()==null 可以判断出），等你去内存找的时候，就直接返回正确的java.lang.System了。\n那么是不是说 没有办法自己写一个叫做java.lang.System的类了呢？\n不，只能说明，遵循双亲委托原则，是没办法实现的，那么不遵循不就行了呗。\n### 分析2：重写findClass\n双亲委托原则根据之前的分析，也是基于java代码在findClass方法中实现的，如果我们重写findClass里面的方法，我findClass的时候不去内存找，我直接调用findClass去读取文件，自行构建class，加载到内存行不行？  \n说干就干，写完感觉还不错，貌似可以的样子\n```java\n    @Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        if(name.equals(\"java.lang.System\"))\n            return findClass(name);\n        return super.loadClass(name);\n    }\n```\n我们自己写的System.java\n```java\npackage java.lang;\n\npublic class System {\n    public static void gc() {\n         \n    }\n}\n\n```\n自定义的ClassLoader的main方法(完整代码见 [ClassLoader的分析与使用](https://melonwxd.github.io/2017/10/17/classloader1/))\n```java\n    public static void main(String[] args) {\n        ClassLoaderTest classLoaderTest = new ClassLoaderTest(\"/home/duoyi/Desktop/ClassLoaderDemo\");\n        try {\n            Class c = classLoaderTest.findClass(\"java.lang.System\");\n            Object obj = c.newInstance();\n            Method method1 = c.getDeclaredMethod(\"gc\",null);\n            method1.invoke(obj, null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n```\n运行一下看看，输出：\n```\njava.lang.SecurityException: Prohibited package name: java.lang\n\tat java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:761)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:642)\n\tat PckA.ClassLoaderTest.findClass(ClassLoaderTest.java:49)\n\tat PckA.ClassLoaderTest.main(ClassLoaderTest.java:69)\n```\n抛出一个安全异常：包名为禁用包名  \n进入defineClass中的preDinfeClass方法看一看\n```java\nprivate ProtectionDomain preDefineClass(String name, ProtectionDomain pd)\n    {\n        // Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias\n        // relies on the fact that spoofing is impossible if a class has a name\n        // of the form \"java.*\"\n        if ((name != null) && name.startsWith(\"java.\")) {\n            throw new SecurityException\n                (\"Prohibited package name: \" +\n                 name.substring(0, name.lastIndexOf('.')));\n        }\n    }\n```\n这就没办法了，他在内部做了限制，不允许java开头的包名被defineClass方法构造，而且defineClass是final方法，也无法通过重写来绕过，所以最终答案就是，不能\n","tags":["ClassLoader"],"categories":["虚拟机"]},{"title":"ClassLoader的分析与使用","url":"/2017/10/17/classloader1/","content":"深入学习ClassLoader原理与学习自定义ClassLoader的使用\n<!-- more -->\n\n# JAVA自带的三个类加载器\nJava语言系统自带有三个类加载器: \n- Bootstrap ClassLoader 最顶层的加载类，主要加载核心类库，%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。 \n- Extention ClassLoader 扩展的类加载器，加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。 \n- Appclass Loader也称为SystemAppClass 加载当前应用的classpath的所有类。\n\n这三个类加载器各自对应加载的jar包和class文件的位置\n```java\n    public static void main(String[] args) {\n        System.out.println(\"BootstrapClassLoader加载Jar包路径: \"+System.getProperty(\"sun.boot.class.path\"));\n        System.out.println(\"ExtClassLoader加载Jar包路径: \"+System.getProperty(\"java.ext.dirs\"));\n        System.out.println(\"AppClassLoader加载Jar包路径: \"+System.getProperty(\"java.class.path\"));\n    }\n```\n输出\n```\nBootstrapClassLoader加载Jar包路径: /opt/jdk1.8.0_144/jre/lib/resources.jar:/opt/jdk1.8.0_144/jre/lib/rt.jar:/opt/jdk1.8.0_144/jre/lib/sunrsasign.jar:/opt/jdk1.8.0_144/jre/lib/jsse.jar:/opt/jdk1.8.0_144/jre/lib/jce.jar:/opt/jdk1.8.0_144/jre/lib/charsets.jar:/opt/jdk1.8.0_144/jre/lib/jfr.jar:/opt/jdk1.8.0_144/jre/classes\nExtClassLoader加载Jar包路径: /opt/jdk1.8.0_144/jre/lib/ext:/usr/java/packages/lib/ext\nAppClassLoader加载Jar包路径: /opt/jdk1.8.0_144/jre/lib/charsets.jar:/opt/jdk1.8.0_144/jre/lib/deploy.jar:/opt/jdk1.8.0_144/jre/lib/ext/cldrdata.jar:/opt/jdk1.8.0_144/jre/lib/ext/dnsns.jar:/opt/jdk1.8.0_144/jre/lib/ext/jaccess.jar:/opt/jdk1.8.0_144/jre/lib/ext/jfxrt.jar:/opt/jdk1.8.0_144/jre/lib/ext/localedata.jar:/opt/jdk1.8.0_144/jre/lib/ext/nashorn.jar:/opt/jdk1.8.0_144/jre/lib/ext/sunec.jar:/opt/jdk1.8.0_144/jre/lib/ext/sunjce_provider.jar:/opt/jdk1.8.0_144/jre/lib/ext/sunpkcs11.jar:/opt/jdk1.8.0_144/jre/lib/ext/zipfs.jar:/opt/jdk1.8.0_144/jre/lib/javaws.jar:/opt/jdk1.8.0_144/jre/lib/jce.jar:/opt/jdk1.8.0_144/jre/lib/jfr.jar:/opt/jdk1.8.0_144/jre/lib/jfxswt.jar:/opt/jdk1.8.0_144/jre/lib/jsse.jar:/opt/jdk1.8.0_144/jre/lib/management-agent.jar:/opt/jdk1.8.0_144/jre/lib/plugin.jar:/opt/jdk1.8.0_144/jre/lib/resources.jar:/opt/jdk1.8.0_144/jre/lib/rt.jar:/home/duoyi/IdeaProjects/ClassLoaderTest/out/production/ClassLoaderTest:/home/duoyi/idea-IC-172.4155.36/lib/idea_rt.jar\n```\n\n\n\n ## 父加载器和父类\n 查阅ClassLoader源码中构造方法\n ```java\nprivate final ClassLoader parent;\nprivate ClassLoader(Void unused, ClassLoader parent) {\n    this.parent = parent;\n    ...\n}\nprotected ClassLoader() {\n    this(checkCreateClassLoader(), getSystemClassLoader());\n}\npublic final ClassLoader getParent() {\n    if (parent == null)\n        return null;\n    return parent;\n}\n ```\n从构造方法可以知道每个类加载器都有一个parent变量来代表父加载器，所以父加载器并不是继承关系上的父类。当调用的是无参的构造方法时，会由系统默认创建一个ClassLoader来作为当前类加载器的parent，实际上默认就是AppClassLoader。  \n把各ClassLoader的父加载器打印出来看看：\n```java\nClassLoader cl = ClassLoaderTest.class.getClassLoader();\nSystem.out.println(cl.toString());\nSystem.out.println(cl.getParent().toString());\nSystem.out.println(cl.getParent().getParent().toString());\n```\n输出：\n```\nsun.misc.Launcher$AppClassLoader@18b4aac2\nsun.misc.Launcher$ExtClassLoader@677327b6\nException in thread \"main\" java.lang.NullPointerException\n\tat PckA.ClassLoaderTest.main(ClassLoaderTest.java:86)\n```\n可以看到一般我们继承ClassLoader来实现的自定义ClassLoader的父加载器，都是AppClassLoader，AppClassLoader的父加载器是ExtCLassLoader，但是ExtClassLoader居然不存在父加载器，看构造方法就知道每个ClassLoader都是有父加载器的，这不是互相矛盾了。其实不然，ExtClassLoader的父加载器就是BootstrapClassLoader，但是Bootstrap是通过C++实现的，所以Java无法拿到它的引用，自然为null了。\n\n\n 继承关系图：  \n\n ![](http://img.blog.csdn.net/20170211112754197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 全盘负责与双亲委托\n\n全盘负责 是指当一个ClassLoader装载一个类时，除非显示地使用另一个ClassLoader，则该类所依赖及引用的类也由这个CladdLoader载入。\n真正加载class字节码文件生成Class对象由“双亲委派”机制完成。\n“双亲委派”机制加载Class的具体过程是：\n1. 源ClassLoader先判断该Class是否已加载，如果已加载，则返回Class对象；如果没有则委托给父类加载器。\n2. 父类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则委托给祖父类加载器。\n3. 依此类推，直到始祖类加载器（BootstrapClassLoader）。\n4. 始祖类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的子类加载器。\n5. 始祖类加载器的子类加载器尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的孙类加载器。\n6. 依此类推，直到源ClassLoader。  \n  源ClassLoader尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，源ClassLoader不会再委托其子类加载器，而是抛出异常。 \n  “双亲委派”机制只是Java推荐的机制，并不是强制的机制。  \n  我们可以继承java.lang.ClassLoader类，实现自己的类加载器。如果想保持双亲委派模型，就应该重写findClass(name)方法；如果想破坏双亲委派模型，可以重写loadClass(name)方法。\n\n\n\n\n# 自定义ClassLoader\n\n## findClass、defineClass和loadClass\n通常自定义ClassLoader，我们都要重写findClass方法，在其中调用defineClass来返回我们想要加载的特定的那个类\n```java\n    /**\n     * Finds the class with the specified <a href=\"#name\">binary name</a>.\n     * This method should be overridden by class loader implementations that\n     * follow the delegation model for loading classes, and will be invoked by\n     * the {@link #loadClass <tt>loadClass</tt>} method after checking the\n     * parent class loader for the requested class.  The default implementation\n     * throws a <tt>ClassNotFoundException</tt>.\n     */\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        throw new ClassNotFoundException(name);\n    }\n```\ndefineClass就不深究源码了，根据参数就知道，根据类名、bytes[]来重新构造一个Class类，这个bytes就是findClass中找到class文件后，使用流读取进来写入到byte[]中。\n```java\n\t/*\n     *\n     * @param  name\n     *         The expected <a href=\"#name\">binary name</a> of the class, or\n     *         <tt>null</tt> if not known\n     *         \n     * @param  b\n     *         The bytes that make up the class data. The bytes in positions\n     *         <tt>off</tt> through <tt>off+len-1</tt> should have the format\n     *         of a valid class file as defined by\n     *         <cite>The Java&trade; Virtual Machine Specification</cite>.\n     *\n     * @param  off\n     *         The start offset in <tt>b</tt> of the class data\n     *\n     * @param  len\n     *         The length of the class data\n     *\n     * @param  protectionDomain\n     *         The ProtectionDomain of the class\n     *         \n     */\n    protected final Class<?> defineClass(String name, byte[] b, int off, int len,\n                                         ProtectionDomain protectionDomain)\n        throws ClassFormatError\n    {\n        protectionDomain = preDefineClass(name, protectionDomain);\n        String source = defineClassSourceLocation(protectionDomain);\n        Class<?> c = defineClass1(name, b, off, len, protectionDomain, source);\n        postDefineClass(c, protectionDomain);\n        return c;\n    }\n```\nloadClass 则体现了上述的双亲委托机制，一般来说是无需改动，为什么说一般，因为后面要改..\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            Class<?> c = findLoadedClass(name);//源ClassLoader先判断该Class是否已加载\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);//父类加载器判断是否加载过该Class\n                    } else {\n                        c = findBootstrapClassOrNull(name);//父类为null时即为BootstrapClassLoader\n                    }\n                } catch (ClassNotFoundException e) {\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    c = findClass(name);//向上查找，向下加载又回到源ClassLoader的findClass方法中\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n## 实例\n编写要加载的类 Test.java，其中有静态方法main和实例方法fun，尤其要注意这包名：A.B.C\n```java\npackage A.B.C;\npublic class Test {\n    public static void main(String[] args){\n        System.out.println(\"this is main method from Test\");\n    }\n    public void fun(){\n        System.out.println(\"this is fun method from Test\");\n    }\n}\n```\n然后将该文件放到 /home/duoyi/Desktop/ClassLoaderDemo/A/B/C 下，在终端里通过javac编译一下得到class文件\n\n编写自定义的ClassLoader类，代码写的很清楚了，也是按照上述流程来：\n1. 继承ClassLoader\n2. 重写findClass，并在内部通过defineClass创建Class实例\n3. 通过反射调用方法  \n\n\n```java\n\npublic class ClassLoaderTest extends ClassLoader {\n\n    private String mLibPath;\n\n    public ClassLoaderTest(String path) { \n        mLibPath = path;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException { \n\n        String fileName = getFileName(name);\n\n        File file = new File(mLibPath, fileName);\n\n        try {\n            FileInputStream is = new FileInputStream(file);\n\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            int len = 0;\n            try {\n                while ((len = is.read()) != -1) {\n                    bos.write(len);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            byte[] data = bos.toByteArray();\n            is.close();\n            bos.close();\n\n            return defineClass(name, data, 0, data.length);\n\n        } catch (IOException e) { \n            e.printStackTrace();\n        }\n\n        return super.findClass(name);\n    }\n\n    //将包名转换为实际路径\n    private String getFileName(String name) {\n        name = name.replaceAll(\"\\\\.\",\"/\");\n        return name+\".class\";\n    }\n\n\n    public static void main(String[] args) {\n        ClassLoaderTest classLoaderTest = new ClassLoaderTest(\"/home/duoyi/Desktop/ClassLoaderDemo\");\n        try {\n\n            Class c = classLoaderTest.findClass(\"A.B.C.Test\");\n            Object obj = c.newInstance();\n            Method method1 = c.getDeclaredMethod(\"main\",String[].class);\n            Method method2 = c.getDeclaredMethod(\"fun\",null);\n            method1.invoke(obj, (Object) new String[]{});\n            method2.invoke(obj,null);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n```\n运行 输出：\n```\nthis is main method from Test\nthis is fun method from Test\n```\n\n### 考一考  \n不小心篇幅写的太多了，详情请参考[这里](https://melonwxd.github.io/2017/10/17/classloader2/)，检验你对上述知识的了解程度。\n\n# Android的ClassLoader\n\n## BaseDexClassLoader\n\n[源码](http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java)\n\n```java\n\n32    /**\n33     * Constructs an instance.\n34     *\n35     * @param dexPath the list of jar/apk files containing classes and\n36     * resources, delimited by {@code File.pathSeparator}, which\n37     * defaults to {@code \":\"} on Android\n38     * @param optimizedDirectory directory where optimized dex files\n39     * should be written; may be {@code null}\n40     * @param libraryPath the list of directories containing native\n41     * libraries, delimited by {@code File.pathSeparator}; may be\n42     * {@code null}\n43     * @param parent the parent class loader\n44     */\n45    public BaseDexClassLoader(String dexPath, File optimizedDirectory,\n46            String libraryPath, ClassLoader parent) {\n47        super(parent);\n48        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);\n49    }\n\n```\n\n    /*第一个参数是jar包或apk的路径，\n    第二个参数是将这些jar包或apk优化后成为dex的存储路径，\n    第三个参数是本地库的路径，\n    第四个参数是父装载器，父装载器有什么用呢？当我们loadClass的时候，会优先用父装载器去loadclass*/\n- dexPath：目标类所在的Apk或者Jar文件路径\n- optimizedDirectory：我在[这篇文章](https://melonwxd.github.io/2017/10/10/dalvik-art/)里贴过apk安装流程图，apk中的dex会被解压出来，并优化成ODex文件，这个参数就是解压路径。ClassLoader只能加载内部存储路径中的dex文件，所以这个路径必须为内部路径\n- libraryPath：本地库的路径，\n- parent：父加载器\n\n\nBaseDexClassLoader有2个子类，DexClassLoader和PathClassLoader，这两个都只重写了BaseDexClassLoader的构造而已，具体的加载逻辑还是在BaseDexClassLoader中。\n\n### FindClass\n\n跟Java一样的加载流程，我们具体看看BaseDex的加载逻辑\n\n```java\n30  private final DexPathList pathList;\n...\n51    @Override\n52    protected Class<?> findClass(String name) throws ClassNotFoundException {\n53        List<Throwable> suppressedExceptions = new ArrayList<Throwable>();\n54        Class c = pathList.findClass(name, suppressedExceptions);//在这里通过pathList查找\n55        if (c == null) {\n56            ClassNotFoundException cnfe = new ClassNotFoundException(\"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList);\n57            for (Throwable t : suppressedExceptions) {\n58                cnfe.addSuppressed(t);\n59            }\n60            throw cnfe;\n61        }\n62        return c;\n63    }\n```\n\n 跟进查看DexPathList的`findClass`\n\n```java\n61    private final Element[] dexElements;\n...\n321    /**\n322     * Finds the named class in one of the dex files pointed at by\n323     * this instance. This will find the one in the earliest listed\n324     * path element. If the class is found but has not yet been\n325     * defined, then this method will define it in the defining\n326     * context that this instance was constructed with.\n327     *\n328     * @param name of class to find\n329     * @param suppressed exceptions encountered whilst finding the class\n330     * @return the named class or {@code null} if the class is not\n331     * found in any of the dex files\n332     */\n333    public Class findClass(String name, List<Throwable> suppressed) {\n334        for (Element element : dexElements) {\n335            DexFile dex = element.dexFile;\n336\n337            if (dex != null) {\n338                Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);\n339                if (clazz != null) {\n340                    return clazz;\n341                }\n342            }\n343        }\n344        if (dexElementsSuppressedExceptions != null) {\n345            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));\n346        }\n347        return null;\n348    }\n```\n\n遍历一个Element数组，Element持有DexFile实例，通过调用每个DexFile实例的`loadClassBinaryName`来根据`name`载入，实际上内部是调用了`defineClass`方法，来创建类，如果载入成功则返回，否则返回null。\n\n**这里基本可以找到热更的思路了，通过反射把我们的增量class添加到这个Element[]，并保证比要更新的同名类更早加载即可**\n\nQzone团队的图：\n\n![](http://img.blog.csdn.net/20160315141956321)\n\n### PathClassLoader\n\nAndroid系统是通过PathClassLoader加载系统类和已安装的应用的。 \n\n```java\n26    /**\n27     * Creates a {@code PathClassLoader} that operates on a given list of files\n28     * and directories. This method is equivalent to calling\n29     * {@link #PathClassLoader(String, String, ClassLoader)} with a\n30     * {@code null} value for the second argument (see description there).\n31     *\n32     * @param dexPath the list of jar/apk files containing classes and\n33     * resources, delimited by {@code File.pathSeparator}, which\n34     * defaults to {@code \":\"} on Android\n35     * @param parent the parent class loader\n36     */\n \n37    public PathClassLoader(String dexPath, ClassLoader parent) {\n38        super(dexPath, null, null, parent);\n39    }\n\n```\n\n\n\n### DexClassLoader\n\nDexClassPath则可以从一个jar包或者未安装的apk中加载dex\n\n```java\n37    /**\n38     * Creates a {@code DexClassLoader} that finds interpreted and native\n39     * code.  Interpreted classes are found in a set of DEX files contained\n40     * in Jar or APK files.\n41     *\n42     * <p>The path lists are separated using the character specified by the\n43     * {@code path.separator} system property, which defaults to {@code :}.\n44     *\n45     * @param dexPath the list of jar/apk files containing classes and\n46     *     resources, delimited by {@code File.pathSeparator}, which\n47     *     defaults to {@code \":\"} on Android\n48     * @param optimizedDirectory directory where optimized dex files\n49     *     should be written; must not be {@code null}\n50     * @param libraryPath the list of directories containing native\n51     *     libraries, delimited by {@code File.pathSeparator}; may be\n52     *     {@code null}\n53     * @param parent the parent class loader\n54     */\n55    public DexClassLoader(String dexPath, String optimizedDirectory,\n56            String libraryPath, ClassLoader parent) {\n57        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n58    }\n```\n\n一般我们都是用这个DexClassLoader来作为动态加载的加载器  \n\n\n\n ## 参考\n[一看你就懂，超详细java中的ClassLoader详解](http://blog.csdn.net/briblue/article/details/54973413)  \n[类加载机制：全盘负责和双亲委托](http://blog.csdn.net/zhangzeyuaaa/article/details/42499839)\n","tags":["ClassLoader","JVM"],"categories":["虚拟机"]},{"title":"RxJava (三)","url":"/2017/10/15/rxjava-3/","content":"RxJava 操作符  \n<!-- more -->\n## 参考\n一下根据操作符的类型进行说明，不会将每个类别下的都讲一遍，具体请查阅[官方文档](http://reactivex.io/documentation/operators.html)  \n[中文文档](https://mcxiaoke.gitbooks.io/rxdocs/content/)\n\n## 创建Observable的操作符\n### create\n最基本的创建被观察者的方式\n```java\nObservable<String> observable =Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n                emitter.onNext(\"Event1\");\n                emitter.onNext(\"Event2\");\n                emitter.onNext(\"Event3\");\n                emitter.onComplete();\n            }\n        });\n```  \n### just\n将对象或者对象集合转换成被观察者，并将值发送出去。可以看到下面代码中，Consumer的accept方法参数是List类型的。\n```java\n        List<Integer> integers = new ArrayList<>();\n        integers.add(1);\n        integers.add(2);\n        integers.add(3);\n        \n        Observable.just(integers)\n                .subscribeOn(AndroidSchedulers.mainThread())\n                .observeOn(Schedulers.newThread())\n                .subscribe(new Consumer<List<Integer>>() {\n                    @Override\n                    public void accept(List<Integer> integers) throws Exception {\n\n                    }\n                });\n```\n### from\n作用跟just差不多，唯一区别就是他是将可迭代的数据结构中的对象一个个发送的，惨Consumer的accept的数据类型就知道跟just的区别了\n```java\n        Observable.fromIterable(integers)\n                .subscribeOn(AndroidSchedulers.mainThread())\n                .observeOn(Schedulers.newThread())\n                .subscribe(new Consumer<Integer>() {\n                    @Override\n                    public void accept(Integer integer) throws Exception {\n\t\t\t\t\n                    }\n                });\n```\n\n\n## 转化Observable类型的操作符\n### FlatMap \n将Observable发送的数据经过转换再发送给观察者\n![](http://reactivex.io/documentation/operators/images/flatMap.c.png)\n与之差不多的是 ConcatMap，看上图可以知道FlatMap是无序的（绿色球和蓝色球在观察者中串在一起了），而ConcatMap是有序的，就保证了绿色四边形全都是在蓝色四边形之前收到的。\n例子使用瓜乐天气里，场景如下，先get获取当前ip地址，再拿到ip地址去请求获取城市的编码id，然后对id进行处理。\n```java\n   public void getWeatherByIp() {\n        mNetClient.getCurCityIP()\n                .subscribeOn(Schedulers.io())\n                .observeOn(Schedulers.io())\n                .concatMap(new Function<Response<ResponseBody>, ObservableSource<ResponseBody>>() {\n                    @Override\n                    public ObservableSource<ResponseBody> apply(Response<ResponseBody> response) throws Exception {\n\n                        JsonObject jo = Utils.string2Json(response.body().string());\n                        String ipAddr = jo.get(\"data\").getAsString();\n                        return mNetClient.getCityID(ipAddr);\n                    }\n                })\n                .observeOn(Schedulers.io())\n                .subscribe(new Consumer<ResponseBody>() {\n                    @Override\n                    public void accept(ResponseBody responseBody) throws Exception {\n                        JsonObject jo = new JsonParser().parse(responseBody.string()).getAsJsonObject();\n                        JsonArray ja = jo.getAsJsonArray(\"results\");\n                        String cityID = ja.get(0).getAsJsonObject().get(\"id\").getAsString();\n                        LogUtil.I(\"id=\" + cityID);\n\n                        getCityWeatherByID(cityID);\n                        getHourlyByID(cityID);\n                    }\n                });\n        \n    }\n```\n在concatMap中通过new Function把getCurCityIP返回的结果，处理得到ipAddr，然后返回mNetClient.getCityID(ipAddr)，这也是个Observable对象（结合retrofit），然后在观察者根据getCityID的ResponseBody获得城市id，再进一步做其他请求。\n\n\n### groupBy\n使用groupBy来制定分组规则，对数据源进行分组，这样观察者就可以通过自动生成的GroupedObservable的getKey方法来获得分组key，从而实现对分组数据的获取。\n上一个网上找的例子\n```java\n\nObservable.range(1, 8).groupBy(new Func1<Integer, String>() {  \n            @Override  \n            public String call(Integer integer) {  \n                return (integer % 2 == 0) ? \"偶数组\" : \"奇数组\";  \n            }  \n        }).subscribe(new Action1<GroupedObservable<String, Integer>>() {  \n            @Override  \n            public void call(final GroupedObservable<String, Integer> stringIntegerGroupedObservable) {  \n                System.out.println(\"group name:\" + stringIntegerGroupedObservable.getKey());  \n                if (stringIntegerGroupedObservable.getKey().equalsIgnoreCase(\"奇数组\"))  \n                    stringIntegerGroupedObservable.subscribe(new Action1<Integer>() {  \n                        @Override  \n                        public void call(Integer integer) {  \n                            System.out.println(stringIntegerGroupedObservable.getKey() + \"'member: \" + integer);  \n                        }  \n                    });  \n            }  \n        }); \n```\n#### 注意事项\ngourpBy操作符将数据源进行分组，生成多个GroupedObservable，一旦有观察者开始订阅，每个GroupedObservable都会开始缓存，如果你只对其中一个分组的数据进行处理，就像例子中那样，对欧数组没有进行处理，那么可能造成内存泄漏。所以如果不需要该组数据，也要接收并处理掉。（官方文档上写的是take(0)，就是只接收前0个，那这样我只要奇数组不就不行了）\n\n### buffer\n定期的将Observable要发送的数据放在一起同时发送给观察者，而不是一个个发送。\n![](http://reactivex.io/documentation/operators/images/Buffer.png)\n\n\n## 不写了 健身去\n写一半找例子的时候发现居然有人[翻译](https://mcxiaoke.gitbooks.io/rxdocs/content/)和[总结](https://www.jianshu.com/p/7b1f57bd1489)了  \n这么火的技术，肯定早就有人翻译了..  \n![](http://ww2.sinaimg.cn/large/9150e4e5ly1fjkl5d4d1tj204g04fglo.jpg)\n\n\n","tags":["RxJava"],"categories":["Android"]},{"title":"RxJava (二)","url":"/2017/10/13/rxjava-2/","content":"RxJava 线程调度\n<!-- more -->\n## RxJava线程调度\n线程调度就是允许观察者和被观察者处在不同的线程中，通过RxJava内置的调度器可以很轻松的完成这些功能。\n开发会用到的主要线程选项：\n- Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作\n- Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作\n- Schedulers.newThread() 代表一个常规的新线程\n- AndroidSchedulers.mainThread() 代表Android的主线程  \n\n### 基本使用\nsubscribeOn() 指定的是被观察者所在的线程\nobserveOn() 指定的是观察者所在的线程\n如果不说明，那么默认是在创建实例的线程\n```\nobservable.subscribeOn(Schedulers.newThread())                    \n            .observeOn(AndroidSchedulers.mainThread())             \n            .subscribe(observer);\n\n```\n\n### 多次指定观察者线程\n多次subscribeOn指定的线程只有第一次指定的有效,  其余的会被忽略。\n多次observerOn，则是最后一次指定的有效，每调用一次observeOn()，对应的观察者就会改变到该线程，例子如下：\n```java\n Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n                Log.d(TAG, \"Observable thread is :\" + Thread.currentThread().getName());\n                emitter.onNext(1);\n                emitter.onNext(2);\n            }\n        });\n\n        Consumer<Integer> consumer = new Consumer<Integer>() {\n            @Override\n            public void accept(Integer integer) throws Exception {\n                Log.d(TAG, \"consumer1 thread is :\" + Thread.currentThread().getName());\n                Log.d(TAG, \"consumer1 onNext: \" + integer);\n            }\n        };\n\n        observable.subscribeOn(AndroidSchedulers.mainThread())\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .observeOn(Schedulers.io())\n                .doOnNext(new Consumer<Integer>() {\n                    @Override\n                    public void accept(Integer integer) throws Exception {\n                        Log.d(TAG, \"consumer1 thread is :\" + Thread.currentThread().getName());\n                        Log.d(TAG, \"consumer1 onNext: \" + integer);\n                    }\n                })\n                .observeOn(Schedulers.newThread())\n                .subscribe(new Consumer<Integer>() {\n                    @Override\n                    public void accept(Integer integer) throws Exception {\n                        Log.d(TAG, \"consumer2 thread is :\" + Thread.currentThread().getName());\n                        Log.d(TAG, \"consumer2 onNext: \" + integer);\n                    }\n                });\n```\n输出：\n```\n10-13 20:48:23.222 18592-18592/com.dongua.rxand D/MainActivity: Observable thread is :main\n10-13 20:48:23.266 18592-18718/com.dongua.rxand D/MainActivity: consumer1 thread is :RxCachedThreadScheduler-2\n10-13 20:48:23.267 18592-18718/com.dongua.rxand D/MainActivity: consumer1 onNext: 1\n10-13 20:48:23.268 18592-18718/com.dongua.rxand D/MainActivity: consumer1 thread is :RxCachedThreadScheduler-2\n10-13 20:48:23.268 18592-18718/com.dongua.rxand D/MainActivity: consumer1 onNext: 2\n10-13 20:48:23.270 18592-18719/com.dongua.rxand D/MainActivity: consumer2 thread is :RxNewThreadScheduler-1\n10-13 20:48:23.270 18592-18719/com.dongua.rxand D/MainActivity: consumer2 onNext: 1\n10-13 20:48:23.271 18592-18719/com.dongua.rxand D/MainActivity: consumer2 thread is :RxNewThreadScheduler-1\n10-13 20:48:23.271 18592-18719/com.dongua.rxand D/MainActivity: consumer2 onNext: 2\n```\n分析：  \n- 两次调用subscribeOn，先是mainThread，再是ioThread，打印出来是main。  \n- 在consumer1订阅之前，两次调用observerOn，先是mainThread，再是ioThread，打印出来是RxCachedThreadScheduler-2。   \n- 在consumer2订阅之前，调用observerOn，使用newThread来通知，consume2打印出来是与consumer1不同的RxNewThreadScheduler-1。  \n","tags":["RxJava"],"categories":["Android"]},{"title":"Kotlin 设计模式—适配器模式","url":"/2017/10/10/kotlin-dp-adapter/","content":"Kotlin设计模式之适配器模式\n<!-- more -->  \n## 适配器模式\n## 简介\n适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  \n在我看到这句话的时候，我的心里想的是：为什么你要让两个接口不兼容的东西一起工作？可惜kotlin学的不是很深，后续场景应该可以结合ListView的Adapter来讲讲，虽然我觉得两者没什么关系。。  \n\n### 适用场景\n1. 业务的接口与工作的类不兼容，（比如：类中缺少实现接口的某些方法）但又需要两者一起工作\n2. 在现有接口和类的基础上为新的业务需求提供接口\n\n## 实例\n生活中，我们常用的插头是二插头和三插头的，那么在开发的时候，通常我们的业务接口可以这样写：\n```kotlin\ninterface TwoPlug{\n    fun powerWithTwo()\n}\ninterface ThreePlug{\n    fun powerWithThree()\n}\nclass TwoPlugImp :TwoPlug{\n    override fun powerWithTwo() {\n        println(\"正在使用二插头充电\")\n    }\n}\nclass ThreePlugImp :ThreePlug{\n    override fun powerWithThree() {\n        println(\"正在使用三插头充电\")\n    }\n}\n\n```\nok，简直完美，要啥有啥，但是天不遂人愿，你的客户只有三插头的充电器（业务逻辑的接口方法），但是他家的插座都是二插头的（实际编码的类），于是你要弄个适配器使得三插头的充电器可以插在二插头的插座上工作。\n\n```kotlin\n\nclass Two2ThreeAdapter : TwoPlug {\n    var threePlug = ThreePlugImp()\n    override fun powerWithTwo() {\n        threePlug.powerWithThree()\n    }\n}\n\nfun main(args: Array<String>) {\n    val plug = Two2ThreeAdapter()\n    plug.powerWithTwo()\n}\n```","tags":["设计模式"],"categories":["Kotlin"]},{"title":"JVM虚拟机，Dalvik虚拟机，ART虚拟机分析","url":"/2017/10/10/dalvik-art/","content":"JVM虚拟机，Dalvik虚拟机，ART虚拟机简介\n<!-- more -->\n## .java .class .dex .apk\n- .java 源文件\n- .class 字节码文件 可以被jvm执行\n- .dex Dalvik支持的字节码文件 可以被dalvik执行\n- .apk 资源文件和dex文件打包后，再经过签名、对齐等操作变成apk文件（Android package）\n\n### apk安装流程\n![](https://cloud.githubusercontent.com/assets/21374839/26571436/8779c70c-4548-11e7-9e9f-7ff265b32837.png)\n\n\n## Dalvik、JIT 与 ART、AOT\n### Dalvik\n通俗的讲，Dalvik虚拟机就是Android平台上的JVM虚拟机。主要对JVM的修改如下：\n1. 将原来 class 文件进行优化，例如将其中的常量冗余信息进行合并，提高虚拟机解析效率\n2. 修改 JVM 运行时基于栈的数据结构修改为 Dalvik 基于寄存器的数据结构，数据访问方式更快，运行效率更高  \n\n所以才会有了.dex文件格式，Dalvik将.apk文件解压（即安装apk的过程），转class.dex转换成ODEX文件（转换过程还会根据当前系统进行优化）存储在本地，运行APP的时候就是找到这个ODEX文件并通过Dalvik来执行。\n### JIT\nJAVA是解释型语言，JVM执行字节码的时候通常有2个方案：\n1. 在执行前一次性把所有指令都编译成本地代码，然后再执行\n2. 逐条解释并执行  \n\nJIT是Just In Time，即时编译。在JVM解释执行字节码的时候，多次调用的程序段才被编译，编译后存放在内存中，下次直接执行编译后的本地代码。\n\n当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code）保存在内存中，下次遇到相同的逻辑的时候就更快了。但是如果大部分代码的执行次数很少，那么编译花费的时间不一定少于执行dex的时间。所以采用的是**只编译执行次数较多的dex为本地机器码**的做法。\n\n~~至于为什么，是因为在运行时，Dalvik虚拟机会将dex代码翻译成处理器指令，然后交给系统处理，这样效率就很低。将字节码翻译成机器码也是需要时间的，如果大部分代码的执行次数很少，那么编译花费的时间不一定少于执行的时间。~~\n\n就HotSpot虚拟机来说的话有client和server两种模式，又有一定程度的[不同](http://ifeve.com/hotspot-jit/)\n\n### 使用AOT策略的ART虚拟机\nJIT是运行时编译，这样可以对执行次数频繁的dex代码进行编译和优化，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间，所以Google在4.4之后推出了ART，用来替换Dalvik（在5.0中彻底替换）。  \nART的策略与Dalvik不同，在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。之后打开App的时候，不需要额外的翻译工作，直接使用本地机器码运行，因此运行速度提高。这就是AOT，Ahead Of Time ，相应的会消耗掉更多的存储空间以及导致安装时间加长。\n","tags":["JVM","Dalvik","ART"],"categories":["虚拟机"]},{"title":"RxJava (一)","url":"/2017/10/09/rxjava-1/","content":"RxJava 基本用法\n<!-- more -->\n## 观察者模式和RxJava的异同\n先来快速的写一个观察者模式的实现，大致如下：\n```java\npublic interface Observer {\n    void update(Event event);\n}\npublic interface Observable{\n    void subscribe(Observer observer);\n    void unsubscribe(Observer observer);\n    void notifyObserver(Event event);\n}\n```\n这里有观察者Observer和被观察者Observable，Observable有订阅和取消订阅，以及通知Observer的notify方法，以及参数Event。\n这里就囊括了RxJava的四个基本要素：\n- 观察者Observer\n- 被观察者Observable\n- 订阅subscribe\n- 事件Event  \n\n而RxJava在此基础上，还定义了2个特殊事件：\n- onCompleted\n- onError  \n\n## RxJava基本实现\n这里展示一下1.0的基本用法 后续都是基于rxjava2.0来演示\n### RxJava1.0\n#### 观察者Observer/Subscriber\n```java\n//Observer<String> observer = new Observer<String>() \nSubscriber<String> subscriber = new Subscriber<String>() {\n    @Override\n    public void onNext(String s) {\n        Log.d(tag, \"Item: \" + s);\n    }\n\n    @Override\n    public void onCompleted() {\n        Log.d(tag, \"Completed!\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(tag, \"Error!\");立连接\n    }\n};\n```\nSubscriber相对于Observer新增了2个方法：\n- onStart\n- unsubscribe　\n\n#### 被观察者Observable\n```java\nObservable observable = Observable.create(new Observable.OnSubscribe<String>() {\n    @Override\n    public void call(Subscriber<? super String> subscriber) {\n        subscriber.onNext(\"Event1\");\n        subscriber.onNext(\"Event2\");\n        subscriber.onNext(\"Event3\");\n        subscriber.onCompleted();\n    }\n});\n```\n#### 订阅subscrible\n```java\nobservable.subscrible(subsricber)\n```\n\n### RxJava2.0\n#### 观察者Observer/Subscriber\n```java\nObserver<Integer> observer = new Observer<String>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                System.out.println(\"subscribe\");\n            }\n\n            @Override\n            public void onNext(String value) {\n                System.out.println(value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"error\");\n            }\n\n            @Override\n            public void onComplete() {\n                System.out.println(\"complete\");\n            }\n        };\n\n```\n\n#### 被观察者Observable\n```java\nObservable<String> observable =Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n                emitter.onNext(\"Event1\");\n                emitter.onNext(\"Event2\");\n                emitter.onNext(\"Event3\");\n                emitter.onComplete();\n            }\n        });\n```\n#### 订阅subscrible\n```java\nobservable.subscrible(subsricber)\n```\n#### rxjava链式写法\n```java\nObservable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n                emitter.onNext(\"Event1\");\n                emitter.onNext(\"Event2\");\n                emitter.onNext(\"Event3\");\n                emitter.onComplete();\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                System.out.println(\"subscribe\");\n            }\n\n            @Override\n            public void onNext(String value) {\n                System.out.println(value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"error\");\n            }\n\n            @Override\n            public void onComplete() {\n                System.out.println(\"complete\");\n            }\n        });\n```\n输出如下：\n```\nsubscribe\nEvent1\nEvent2\nEvent3\ncomplete\n```\n### 1.0 2.0差别\n#### ObservableEmitter\n这里2.0在实例化Observable的时候，使用的是ObservableOnSubscribe这个类，并且重写onSubscribe方法，参数是ObservableEmitter（Emitter译为发射器）。通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件，对应Observer的三个方法。\n#### Disposable\n在Observer的onSubscribe方法中，参数类型为Disposable，拿到这个参数，Observer可以随时调用dipose方法来结束本次订阅，尽管Observable的事件依然会按顺序发送直到接送，但Observer在调用dipose之后就停止了接收。\n#### Consumer\n在2.0中subscribe有多个重载方法\n```\npublic final Disposable subscribe() {}\n    public final Disposable subscribe(Consumer<? super T> onNext) {}\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {} \n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {}\n    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Consumer<? super Disposable> onSubscribe) {}\n    public final void subscribe(Observer<? super T> observer) {}\n```\n拿来替换1.0中的Action0、Action1等，在1.0中通过参数个数来分别对应next、competed、error事件，代码如下：\n```java\nAction1<String> onNextAction = new Action1<String>() {\n    // onNext()\n    @Override\n    public void call(String s) {\n        Log.d(tag, s);\n    }\n};\nAction1<Throwable> onErrorAction = new Action1<Throwable>() {\n    // onError()\n    @Override\n    public void call(Throwable throwable) {\n        // Error handling\n    }\n};\nAction0 onCompletedAction = new Action0() {\n    // onCompleted()\n    @Override\n    public void call() {\n        Log.d(tag, \"completed\");\n    }\n};\n\n// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()\nobservable.subscribe(onNextAction);\n// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()\nobservable.subscribe(onNextAction, onErrorAction);\n// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()\nobservable.subscribe(onNextAction, onErrorAction, onCompletedAction);\n```\n而在2.0中，使用方法也差不多，也是通过参数判断，只不过整合到一个Consumer类中\n```java\n        Consumer<String> nextConsumer = new Consumer<String>() {\n            @Override\n            public void accept(String string) throws Exception {\n                System.out.println( \"onNext: \" + string);\n            }\n        };\n        Consumer<Disposable> disposableConsumer = new Consumer<Disposable>() {\n            @Override\n            public void accept(Disposable disposable) throws Exception {\n                System.out.println( \"Disposable\");\n            }\n\n        };\n\n        Action competedAction = new Action() {\n            @Override\n            public void run() throws Exception {\n                System.out.println( \"onComplete\" );\n            }\n        };\n\n        Consumer<Throwable> errorConsumer = new Consumer<Throwable>() {\n            @Override\n            public void accept(Throwable e) throws Exception {\n                System.out.println( \"onError: \" + e.getMessage());\n            }\n        };\n\n\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"Event1\");\n                e.onComplete();\n            }\n        }).subscribe(nextConsumer,errorConsumer,competedAction,disposableConsumer);\n```\n输出：\n```\nDisposable\nonNext: Event1\nonComplete\n```\n\n\n\n## 参考资料\n\n[Rxjava 2.0](http://www.jianshu.com/u/c50b715ccaeb)  \n[Rxjava 1.0](http://gank.io/post/560e15be2dca930e00da1083)\n\n## \n","tags":["RxJava"],"categories":["Android"]},{"title":"Kotlin空指针安全","url":"/2017/09/29/kotlin-nullsafe/","content":"Kotlin Null Safety 学习笔记\n<!-- more -->\n\n \n## ? 可空 非空 \n```kotlin\n    var a: String? = null  //type is String? 可以赋null值\n    var b: String = \"b\" //type is String\n    b=a //报错 类型不匹配 \n```\n## 空值检查\n```kotlin\n    var b: String? = null //\n    val l = if(b!=null)b.length else -1\n    //or..\n    if (b != null && b.length > 0) {\n        print(\"String of length ${b.length}\")\n    } else {\n        print(\"Empty string\")\n    }\n```\n## 安全调用：?. 和 let\n如果每次都对可空的变量做空值判断，那不是和java一样啰嗦，所以kotlin还有一种简洁的调用方法\n```\nb?.length // return null if b==null\nbob?.department?.head?.name //链式调用\n``` aInt: Int? = a as? Int\n如果只想返回非空值，可以使用let关键字来忽略空值\n```kotlin\nval listWithNulls: List<String?> = listOf(\"A\",\"B\", null)\nfor (item in listWithNulls) {\n     item?.let { println(it) } // prints A and B\n}\n```\n\n## ?: 操作符 \n 如果 ?: 左边表达式不为空则返回，否则返回右边的表达式\n```\nval l: Int = if (b != null) b.length() else -1\n```\n等同于\n```\nval l = b.length()?: -1\n```\n\n## !! 操作符\n返回一个非空的 b 或者抛出一个 b 为空的 异常\n```\nval l = b !!.length()\n```\n\n## 安全转换\n一般我们在做类型转换的时候，如果被转换的不是我们预估的类型，会报一个ClassCastException异常，这里可以使用安全转换来做，当失败的时候返回一个null\n```\nval aInt: Int? = a as? Int\n```\n## null集合\n如果想要过滤一个集合中的空值，可以使用\n```\nval nullableList: List<Int?> = listOf(1, 2, null, 4)\nval intList: List<Int> = nullableList.filterNotNull()\n```","tags":["Kotlin语法"],"categories":["Kotlin"]},{"title":"Kotlin 设计模式—工厂模式","url":"/2017/09/27/kotlin-dp-factory/","content":"Kotlin设计模式之工厂模式\n<!-- more -->\n\n## 简单工厂模式\n隐藏对象创建细节，用户只需要知道自己要什么，把参数传递给工厂，工厂负责对象的创建就给你什么。\n\n```kotlin\n\n/**\n * TV 抽象产品\n * HairTV HisenseTV 具体对象\n * SimpleTVFactory 简单工厂（制造TV的工厂）\n */\n\n\ninterface TV {\n    fun play()\n}\n\nclass HaierTV : TV {\n    override fun play() {\n        println(\"Haier TV is playing\")\n    }\n}\n\nclass HisenseTV : TV {\n    override fun play() {\n        println(\"Hisense TV is playing\")\n    }\n}\n\nclass SimpleTVFactory constructor(bandName: String) {\n    var bandName: String = bandName\n\n    fun produce(): TV {\n        when (bandName) {\n            \"Haier\" -> return HaierTV()\n            \"Hisense\" -> return HisenseTV()\n            else -> return object : TV {\n                override fun play() {\n                    println(\"Non-Band TV is playing\")\n                }\n            }\n        }\n         \n    }\n}\n\nfun main(args: Array<String>) {\n    var haierFactory: SimpleTVFactory = SimpleTVFactory(\"Haier\")\n    var hisenseFactory: SimpleTVFactory = SimpleTVFactory(\"Hisense\")\n    var melonFactory: SimpleTVFactory = SimpleTVFactory(\"Dongua\")\n    haierFactory.produce()\n    hisenseFactory.produce()\n    melonFactory.produce()\n}\n```\n\n## 工厂方法模式\n随着业务的增加，用户可能不止需要海尔和海信的TV了，还需要美的TV，ok，没问题，在SimpleTVFactory的when语句里增加一个\"Media\"条件。然后小米、乐视各种TV都来了。不仅你改的累得慌，还违背了面向对象的开闭原则。\n这时候就有了工厂方法模式，不仅产品抽象，工厂类也抽个接口出来，这样当你要新增类型的时候，只需要实现工厂类借口，实现具体的代码逻辑即可。\n```kotlin\ninterface TV {\n    fun play()\n}\n\ninterface TVFactory {\n    fun produce():TV\n}\n\nclass HaierTV : TV {\n    override fun play() {\n        println(\"Haier TV is playing\")\n    }\n}\n\nclass HaierTVFactory:TVFactory{\n    override fun produce(): TV {\n        println(\"HaierTVFactory is producing\")\n         return HaierTV()\n    }\n}\n\nclass HisenseTV : TV {\n    override fun play() {\n        println(\"Hisense TV is playing\")\n    }\n}\n\nclass HisenseTVFactory:TVFactory{\n    override fun produce(): TV {\n        println(\"HisenseTVFactory is producing\")\n        return HisenseTV()\n    }\n}\n\n\nfun main(args: Array<String>) {\n    val tv:TV\n    val tvF:TVFactory\n    tvF = HisenseTVFactory()\n    tv = tvF.produce()\n    tv.play()\n}\n```\n\n## 抽象工厂模式\n随着竞争越来越激烈，各大厂商于是开始向CPU行业(这个CPU是搭载在TV上面的，就是说这两者之间是有关联的，你想，要是没有关联又何必放到同样的工厂下面提高耦合呢)进攻。\n```kotlin\ninterface TV {\n    fun play()\n}\ninterface CPU{\n    fun work()\n}\n\ninterface MultiFactory {\n    fun produceTV():TV\n    fun produceCPU():CPU\n}\n\n\nclass HaierTV : TV {\n    override fun play() {\n        println(\"HaierTV is playing\")\n    }\n}\nclass HaierCPU : CPU {\n    override fun work() {\n        println(\"HaierCPU is working\")\n    }\n}\n\nclass HaierFactory:MultiFactory{\n    override fun produceTV(): TV {\n        println(\"HaierFactory is producing TV\")\n        return HaierTV()\n    }\n\n    override fun produceCPU(): CPU {\n        println(\"HaierFactory is producing CPU\")\n        return HaierCPU()\n    }\n}\n\n\nclass HisenseTV : TV {\n    override fun play() {\n        println(\"Hisense TV is playing\")\n    }\n}\n\n\nclass HisenseCPU : CPU {\n    override fun work() {\n        println(\"HisenseCPU is working\")\n    }\n}\n\n\nclass HisenseFactory:MultiFactory{\n\n    override fun produceTV(): TV {\n        println(\"HisenseFactory is producing TV\")\n        return HisenseTV()\n    }\n\n    override fun produceCPU(): CPU {\n        println(\"HisenseFactory is producing CPU\")\n        return HisenseCPU()\n    }\n}\n\n\n\nfun main(args: Array<String>) {\n    val tv:TV\n    val cpu:CPU\n    val factory1:MultiFactory\n    val factory2:MultiFactory\n    factory1 = HaierFactory()\n    factory2 = HisenseFactory()\n    tv = factory1.produceTV()\n    tv.play()\n    cpu = factory2.produceCPU()\n    cpu.work()\n\n\n\n}\n\n```\n \n### 抽象工厂模式的优点\n抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。\n \n#### 抽象工厂模式的缺点\n产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。\n \n### 适用场景\n当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。\n\n\n\n\n\n\n\n","tags":["设计模式"],"categories":["Kotlin"]},{"title":"JVM Specification Chapter2","url":"/2017/09/24/JVM规范C2/","content":"Oracle JVM规范 简单翻译/笔记 - Chapter2\n<!-- more -->\n## 原文地址\n[原文地址](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html)  \n## Chapter2：JVM的结构\n## class文件格式\n[等俺坚持第四章了再说吧](www.null.com)\n## 数据类型 \n与Java语言类似，JVM能够处理的2种类型为 原始类型和引用类型。相应的，这两种类型也可以被保存为比变量、作为参数传递、方法的返回值和运算操作。\nJVM希望几乎所有的类型检查在运行时都已经完成，通常是由IDE来做这些检查的。原始类型的值无需被硬件标记，不需要在runtime去决定他们的类型，也不需要和引用类型的值区分开来，因为操作这些原始类型的数据的指令集（ instruction set ）本身就已经指出了那些被操作的原始数据的类型。煮个例子，iadd，ladd，fadd，dadd都是JVM相加2个数的指令，但是每个指令都分别对应了int，long，float，double这些数据类型。\n[jvm指令集](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1)  \nJVM明确支持对象（objects），一个对象不是动态分配的类实例就是一个数组。一个对象的引用，在JVM中就叫做引用类型。引用类型的值可以被认为是指向对象的指针。一个对象可以有多个引用，对象的操作总是通过引用类型的值来传递和测试。  \n### returnAddress 类型和值\nreturnAddress通常被JVM的jsr, ret, 以及jsr_w指令调用。returnAddress类型的值指向一条JVM指令的操作码。该类型在Java语言中不存在与之对应的类，无法在运行时修改。\n## 运行时数据区(Run-Time Data Areas)\n在执行程序的时候，JVM定义了各种运行时数据区。一些区域跟JVM具有相同的生命周期(JVM进程)，其他的数据是跟每个线程具有相同的生命周期。\n\n","tags":["JVM Specification","翻译"],"categories":["虚拟机"]},{"title":"HTTP基础知识","url":"/2017/09/24/HTTP基础知识/","content":"## 网关\n![](http://owu391pls.bkt.clouddn.com/tjHttp1.png)\n网关跟代理的差别就是他可以在提供非HTTP协议来服务客户端，可以提高通信的安全性，可以连接数据库，可以和信用卡结算系统联动。  \n网关实质上是一个网络通向其他网络的IP地址\n当你需要访问跟自己不在同一个网络地址内的ip时，就要通过你的网关，去向DNS查询，目标ip所在的网关，通过你的网关将数据包发送到目标ip所在网关，该网关收到数据包后，就会把数据转发到该目标ip。\n\n## ip地址、子网掩码和网络地址\nIP地址 = 网络地址 + 主机地址  \nIP地址：192.168.100.1  \n子网掩码：255.255.255.0  \n网络地址: 192.168.100.0   \n主机地址: 0.0.0.1(主机号不能全是“0”或全是“1”)  \n广播地址: 192.168.100.255   \n网络地址相同，且主机地址不同，则两台PC可以互相访问\n\n### ip地址\n![](http://owu391pls.bkt.clouddn.com/ip.png)\n\n### 子网掩码\n作用：区分网络地址和主机地址，左边是网络位，用1表示，右边是主机位，用0表示\n常见的子网掩码有2个：  \n- 255.255.255.0\n- 255.255.0.0\n\n","tags":["网络编程"],"categories":["网络基础"]},{"title":"天气预报折线图","url":"/2017/09/23/MIUIWeather/","content":"自定义View高仿小米天气24小时天气预报折线图\n<!-- more -->\n## 项目地址\n[HourlyForecastView](https://github.com/MelonWXD/HourlyForecastView)\n\n\n## 需求分析\n- 圆点的宽高(宽为固定的，高与该时刻温度值线性相关）\n- 虚线宽度的判定（根据数据源来）\n- 动画效果（图片总是在 虚线或虚线与屏幕边缘中间）\n\n## 数据源\n[饥人谷24小时天气API](http://weixin.jirengu.com/weather/future24h?cityid=WX4FBXXFKE4F)\n\n[饥人谷开放API](api.jirengu.com)\n\nJson格式部分如下，完整见上述网址\n```\n{\n    \"status\": \"OK\",\n    \"hourly\": [\n        {\n            \"text\": \"晴\",\n            \"code\": \"1\",\n            \"temperature\": \"17\",\n            \"time\": \"2017-08-30T02:00:00+08:00\"\n        },\n        {\n            \"text\": \"晴\",\n            \"code\": \"1\",\n            \"temperature\": \"17\",\n            \"time\": \"2017-08-30T03:00:00+08:00\"\n        }\n    ]\n}\n```\n \n使用Android Studio的插件GsonFormat就能根据Json，自动生成bean类了。\n> 代码块中 ... 为省略无关代码  下同  \n\n```java\npublic class HourlyWeatherBean {\n\n    /**\n     * text : 多云\n     * code : 4\n     * temperature : 28\n     * time : 2017-08-30T02:00:00+08:00\n     */\n\n    private String text;\n    private String code;\n    private String temperature;\n    private String time;\n\n    public HourlyWeatherBean(String text, String code, String temperature, String time) {\n        this.text = text;\n        this.code = code;\n        this.temperature = temperature;\n        this.time = time;\n    }\n\n    ...\n    getter \n    setter\n    ...\n}\n```\n\n## 初始化与Utils\n\n### 初始化与默认值  \n将json数据转换为beanList传给View的initData方法\n```java\nprivate void initView() {\n\n        ...\n        List<HourlyWeatherBean> hourlyWeatherList = new ArrayList<>();\n        Gson gson = new Gson();\n        JsonObject jo = new JsonParser().parse(jsonData).getAsJsonObject();\n        JsonArray ja = jo.getAsJsonArray(\"hourly\");\n        for (JsonElement element : ja) {\n            HourlyWeatherBean bean = gson.fromJson(element, new TypeToken<HourlyWeatherBean>() {\n            }.getType());\n            hourlyWeatherList.add(bean);\n        }\n\n        //设置当天的最高最低温度\n        hourlyForecastView.setHighestTemp(27);\n        hourlyForecastView.setLowestTemp(16);\n        hourlyForecastView.initData(hourlyWeatherList);\n         ...\n    }\n```\n根据传入的数据 在View内部确认画虚线的位置 同时初始化默认值和画笔\n```java\n    public void initData(List<HourlyWeatherBean> weatherData) {\n\n        hourlyWeatherList = weatherData;\n        dashLineWidth = new ArrayList<>();\n        Iterator iterator = hourlyWeatherList.iterator();\n        HourlyWeatherBean tmp;\n        String lastText = \"\";\n        int idx = 0;\n        while (iterator.hasNext()) {\n            tmp = (HourlyWeatherBean) iterator.next();\n            if (!tmp.getText().equals(lastText)) {\n                dashLineWidth.add(idx);//从0开始添加虚线位置的索引值idx\n                lastText = tmp.getText();\n            }\n            idx++;\n        }\n        dashLineWidth.add(hourlyWeatherList.size() - 1);//添加最后一条虚线位置的索引值idx\n\n        initDefValue();\n        initPaint();\n\n    }\n```\n\n### Utils工具类\n包括了dp/sp转换 以及图片压缩方法 代码就不贴了  \n\n## onMeasure  \n\n```java\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        //当设置的padding值小于默认值是设置为默认值\n        paddingL = Math.max(paddingL, getPaddingLeft());\n        paddingT = Math.max(paddingT, getPaddingTop());\n        paddingR = Math.max(paddingR, getPaddingRight());\n        paddingB = Math.max(paddingB, getPaddingBottom());\n\n        //获取测量模式\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n\n        //获取测量大小\n        int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n\n\n        if (widthMode == MeasureSpec.EXACTLY && heightMode == MeasureSpec.EXACTLY) {\n            mWidth = widthSize + paddingL + paddingR;\n            mHeight = heightSize;\n        }\n\n        //如果为wrap_content 那么View大小为默认值\n        if (widthMode == MeasureSpec.UNSPECIFIED && heightMode == MeasureSpec.AT_MOST) {\n            mWidth = defWidthPixel + paddingL + paddingR;\n            mHeight = defHeightPixel + paddingT + paddingB;\n        }\n       \n        //设置视图的大小\n        setMeasuredDimension(mWidth, mHeight);\n    }\n\n```\n当设置的padding值小于默认值时，将padding设为默认值，来保证左右两边都有足够空间来绘制\n\n需要注意的是 HorizontalScrollView的子View 在没有明确指定dp值的情况下 widthMode总是MeasureSpec.UNSPECIFIED 同理 ScrollView的子View的heightMode也是同样的情况  \n\n\n## onDraw  \n\n```java\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        if (hourlyWeatherList.size() != 0) {\n            drawLines(canvas);\n            drawBitmaps(canvas);\n        }\n    }    \n ```\n ### drawLines\n ```java\n private void drawLines(Canvas canvas) {\n        //底部的线的高度 高度为控件高度减去text高度的1.5倍\n        float baseLineHeight = mHeight - 1.5f * textSize;\n        Path p = new Path();\n\n        for (int i = 0; i < hourlyWeatherList.size(); i++) {\n            float temp = Integer.parseInt(hourlyWeatherList.get(i).getTemperature());\n            float w = itemWidth * i + paddingL;\n            float h = tempHeightPixel(temp) + paddingT;\n            if (i == 0) {\n                p.moveTo(w, h);\n            } else {\n                p.lineTo(w, h);\n            }\n\n            //画虚线\n            if (dashLineWidth.contains(i)) {\n                canvas.drawLine(w, h, w, baseLineHeight, dashPaint);\n            }\n\n        }\n        //画折线\n        canvas.drawPath(p, foldLinePaint);\n        //画底线\n        canvas.drawLine(paddingL, baseLineHeight, mWidth - paddingR, baseLineHeight, baseLinePaint);\n        ...\n \t}\n ```\n  取名不大会取，这个drawLines方法是绘制了所有非图片的东西  \n 包括底部的线、温度折线以及虚线  \n 通过遍历数据，使用Path类来确定折线的路径\n```java\nprivate void drawLines(Canvas canvas) {\n ...\n for (int i = 0; i < hourlyWeatherList.size(); i++) {\n            float temp = Integer.parseInt(hourlyWeatherList.get(i).getTemperature());\n\n            float w = itemWidth * i + paddingL;\n            float h = tempHeightPixel(temp) + paddingT;\n\n            //画大白圆\n            circlePaint.setColor(getResources().getColor(R.color.white));\n            circlePaint.setStyle(Paint.Style.FILL);\n            canvas.drawCircle(w, h, defRadius + 6, circlePaint);\n            //画小蓝圆\n            circlePaint.setColor(getResources().getColor(R.color.dodgerblue));\n            circlePaint.setStyle(Paint.Style.STROKE);\n            canvas.drawCircle(w, h, defRadius, circlePaint);\n\n            //画温度值  y轴是文本基线 故除2处理\n            canvas.drawText(hourlyWeatherList.get(i).getTemperature(), w, h - textSize / 2f, textPaint);\n            //画时间\n            canvas.drawText(hourlyWeatherList.get(i).getTime(), w, baseLineHeight + textSize, textPaint);\n        }\n}\n```\n2个圆，在折线和虚线绘制完毕后，绘制一个白色的大圆，再绘制一个半径略小的蓝色小圆，这样就能达到圆点和线之间相隔一定距离的效果  \n还有时间点和温度值，其中温度值的高度是由如下方法确定的，highestTemp和lowestTemp表示当天最高温和最低温的值，highestTempHeight表示长度(不是屏幕y轴的值，所以返回值需要 默认的View高度(y轴值)减去结果），根据该时间的温度值的比例，即可得到对应的高度\n ```java\n     public float tempHeightPixel(float tmp) {\n        float res = ((tmp - lowestTemp) / (highestTemp - lowestTemp)) * (highestTempHeight - lowestTempHeight) + lowestTempHeight;\n        return defHeightPixel - res;\n    } \n```\n### 硬件加速的小坑\n如果出现虚线绘制无效的情况，在Manifest中Activity标签下关闭硬件加速\n```\nandroid:hardwareAccelerated=\"false\"\n```\n### drawBitmaps\n绘制图片是这个自定义View最重要的地方，因为他需要满足如下规则:  \n  \n1. 左右虚线都显示在屏幕内，图片在两边虚线中间\n2. 左虚线在屏幕外，图片在屏幕左边缘与右虚线中间\n3. 右虚线在屏幕外，图片在左虚线与屏幕右边缘中间\n4. 两个虚线都在屏幕外，图片在屏幕中央\n5. 滑动过程图片不超过虚线\n分析清楚了，那么代码也就好写了\n```java\n private void drawBitmaps(Canvas canvas) {\n\t\tint scrollX = mScrollX;\n        boolean leftHide;\n        boolean rightHide;\n        for (int i = 0; i < dashLineWidth.size() - 1; i++) {\n            leftHide = true;\n            rightHide = true;\n\n            int left = itemWidth * dashLineWidth.get(i) + paddingL;\n            int right = itemWidth * dashLineWidth.get(i + 1) + paddingL;\n            float drawPoint = 0;//图的中间位置  drawBitmap是左边开始画\n            if (left > scrollX && left < scrollX + screenWidth) {\n                leftHide = false;//左边缘显示\n            }\n            if (right > scrollX && right < scrollX + screenWidth) {\n                rightHide = false;\n            }\n\n            if (!leftHide && !rightHide) {//左右边缘都显示\n                drawPoint = (left + right) / 2f;\n\n            } else if (leftHide && !rightHide) {//右边缘与屏幕左边\n\n                drawPoint = (scrollX + right) / 2f;\n            } else if (!leftHide) {//左边缘与屏幕右边\n                //rightHide is True when reach this statement\n                drawPoint = (left + screenWidth + scrollX) / 2f;\n\n            } else {//左右边缘都不显示\n                if (right < scrollX + screenWidth) { //左右边缘都在屏幕左边\n                    continue;\n                } else if (left > scrollX + screenWidth) {//左右边缘都在屏幕右边\n                    continue;\n                } else {\n                    drawPoint = (screenWidth) / 2f + scrollX;\n                }\n            }\n}\n```\n注释已经写的很清楚了，最后得到drawPoint的位置，还得满足第五点，不超过虚线，如下\n```java\n//越界判断\n            if (drawPoint >= right - bitmap.getWidth() / 2f) {\n                drawPoint = right - bitmap.getWidth() / 2f;\n            }\n            if (drawPoint <= left + bitmap.getWidth() / 2f) {\n                drawPoint = left + bitmap.getWidth() / 2f;\n            }\n```\n拿到了正确的位置，调用canvas的drawBitmap就完成了图片的绘制\n\n## Scroll滑动\n由于继承的是View，所以没有ScrollListener，即上面drawBitmaps的Line1，判断位置最关键的scrollX的值，需要咱们自己想办法来计算  \n有两种方案来实现，一个就是重写onTouchEvent方法，利用Scroller 和 VelocityTracker 来实现。或者你也可以像我一样偷懒，悄悄偷个鸡..  \n### 通过回调实现scroll值的传入\n因为外部嵌套的是HorizontalScrollView，而HorizontalScrollView已经实现了滑动的监听，那么只需要在HorizontalScrollView的onScrollChange方法里，拿到scrollX的值，并传给这个自定义View即可。  \n通过设计模式的观察者模式来实现这一功能：\n```java\npublic interface ScrollWatcher {\n    void update(int scrollX);\n}\npublic interface ScrollWatched {\n    void addWatcher(ScrollWatcher watcher);\n    void removeWatcher(ScrollWatcher watcher);\n    void notifyWatcher(int x);\n}\n```\n让HourlyForecastView实现ScrollWatcher接口，在update中将参数赋值给类变量mScrollX\n\n```java\n    private void initObserver() {\n        watcherList = new ArrayList<>();\n        watched = new ScrollWatched() {\n            @Override\n            public void addWatcher(ScrollWatcher watcher) {\n                watcherList.add(watcher);\n            }\n\n            @Override\n            public void removeWatcher(ScrollWatcher watcher) {\n                watcherList.remove(watcher);\n            }\n\n            @Override\n            public void notifyWatcher(int x) {\n                for (ScrollWatcher watcher : watcherList) {\n                    watcher.update(x);\n                }\n            }\n        };\n    }\n```\n\n```java\nprivate void initView() {\n\t\t...\n        watched.addWatcher(hourlyForecastView);\n        horizontalScrollView.setOnScrollChangeListener(new View.OnScrollChangeListener() {\n            @Override\n            public void onScrollChange(View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY) {\n                watched.notifyWatcher(scrollX);\n            }\n        });\n        ...\n}\n```\n在MainActivity中实例化ScrollWatched类，并将的实例添加进去在HorizontalScrollView的onScrollChange方法里调用notifyWatcher，参数为scrollX\n\n### 重写onTouchEvent\n这里啥也莫得，有空再写吧..\n \n## 写在最后\n最新电脑配置升级了，代码写起来更方便了，不用build的时候先去打把游戏再回来看了，打算陆陆续续把之前的笔记整理并发出来，感觉写一篇耗时比我想的久，这篇从3点多一直到现在5点40分，居然花了整整2个小时，看来要把写博客的时间安排在写完代码之后，写的时候自言自语感觉蛮好玩的，思路也清晰了不少。\n","tags":["自定义View","Geather"],"categories":["Android"]}]