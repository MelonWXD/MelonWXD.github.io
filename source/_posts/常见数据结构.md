---
title: 常见数据结构分析 
date: 2018-04-10 16:25:44
tags: [数据结构]  
categories: Android
---
ArrayList、LinkedList、HashMap、LinkedHashMap实现
<!-- more -->  

# HashMap

数组+链表实现

![](https://upload-images.jianshu.io/upload_images/1956855-e0aa3ef55cd31303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

```java
    transient Node<K,V>[] table;

    /**
     * Holds cached entrySet(). Note that AbstractMap fields are used
     * for keySet() and values().
     */
    transient Set<Map.Entry<K,V>> entrySet;
```



每个Entry为Node实例

```java
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
    }
```

***

根据key的hash值找到数组的位置i

```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }		

	/**
     * Returns index for hash code h.
     */
    static int indexFor(int h, int length) {
        return h & (length-1);
    }
```

然后遍历以数组[i]为头节点的链表，如果发现有节点的hash，key都相同的节点时，就替换为新的value，然后返回旧的value，没有就加到尾巴去

```java
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```

## JDK8中的resize方法分析

只关注链表时的resize

```java
final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
		//省略计算扩容大小的代码
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;//遍历循环数组 e为当前节点
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null){
                        newTab[e.hash & (newCap - 1)] = e;
                    }//省略红黑树resize代码
                    else { 
                      	//下面会单独贴出来
                        //①计算节点e在新数组中的位置 
                        //②遍历e所在链表，放到新数组中
                    }
                }
            }
        }
        return newTab;
    }
```

一个for循环管遍历数组，在for循环里再针对每个Node遍历所在链表，主要是关于位置计算的代码需要深入了解一下。

在贴源码之前，回顾一下HashMap是怎么确定每个V在数组中的index的？

如果数组的大小为len的话，那就是

```java
index = hash & (len-1)
```

所以index只跟要put的V的hashcode的低(len-1)位有关系。而在jdk8中，HashMap保证数组的大小len一定为2的n次幂（二进制形如100,1000,10000）。ok，有了这些基本知识就可以继续跟进resize的源码了。上面省略的代码如下：

```java
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
```

通过`if ((e.hash & oldCap) == 0)`来判断当前节点 e的hash值，如果==0，则说明e.hash的值在oldCap为1的那一位，为0。

```java
e.hash       xxxxxxxxYxx  (Y=0)
oldCap               100  (2的n次幂)
oldCap-1	  	     011			   
__________________________________
e.hash & oldCap        0
e.hash & (oldCap-1)   xx 
e.hash & oldCap 为0 说明 Y为0
```

但是这个Y为0能干嘛呢，Y为0说明了当前的节点e在新的数组中，位置是保持不变的！因为扩容后，能够影响位置的只有Y位。

```java
e.hash       xxxxxxxxxYxx  (Y=0)
newCap               1000  (2的n次幂)
newCap-1             0111 
__________________________________
e.hash & (newCap-1)   0xx 
```

看到没，如果Y为0的话，扩容后，e在数组中的index根本不会收到扩容后的数组长度影响。

再回到上面的代码

```java
Node<K,V> loHead = null, loTail = null;
Node<K,V> hiHead = null, hiTail = null;
```

loHead和loTail就是 位置不变的节点e所在的链表的头尾

hiHead和hiTail就是 位置改变的节点e所在的链表的头尾

那么问题又来了，对于改变位置的节点e来说，他是多了多少?

```java
e.hash       xxxxxxxxxYxx  (Y=1)
newCap               1000  (2的n次幂)
newCap-1             0111 
__________________________________
e.hash & (newCap-1)   Yxx  (Y=1)
```

Y=1的时候，索引位置从 0xx变成1xx，那么就是多了100，就是多了一个oldCap的len长度嘛。分析完毕。











# LinkedHashMap

https://www.jianshu.com/p/83648fa22c4c

entrySet的改变：

```java
    static class LinkedHashMapEntry<K,V> extends HashMap.Node<K,V> {
        LinkedHashMapEntry<K,V> before, after;
        LinkedHashMapEntry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
```

```java
    /**
     * The head (eldest) of the doubly linked list.
     */
    transient LinkedHashMapEntry<K,V> head;

    /**
     * The tail (youngest) of the doubly linked list.
     */
    transient LinkedHashMapEntry<K,V> tail;
```

在Hashmap中有在put方法中预留给LinkedHashmap操作的方法

```java
    // Callbacks to allow LinkedHashMap post-actions
    void afterNodeAccess(Node<K,V> p) { }
    void afterNodeInsertion(boolean evict) { }
    void afterNodeRemoval(Node<K,V> p) { }

```

增加大量规则来维护head tail双向链表
