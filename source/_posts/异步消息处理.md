---
title: 异步消息处理
date: 2017-12-26 20:47:13
tags: Android
categories: Handler
---
源码角度分析Android异步消息处理机制
<!-- more -->
# 写在前面
刚才看到2个面试题：
1. 一个线程有几个Handler，如果一个线程有多个Handler，那么怎么系统怎么确定某个Message所回调到的handleMessage方法

2. 两个副线程可以使用Looper.prepare公用一个MessageQueue吗？如果可以怎么实现

下意识给出如下答案：

1. 一个线程可以有多个Handler。Handler在发送Message的时候会通过msg.target=this来把Handler和该Handler发送的消息关联起来。Message在被Looper提取处理的时候，会调用Message对应的tagert的dispatchMessage来，从而实现多个Handler回调的准确性。


2. 第一反应是不能的，首先Looper.prepare的方法是通过ThreadLocal来保证多线程的互不影响，也保证了Looper在每个线程中都是唯一的，他这个题目我首先就有点看不懂了。最后看他说，如果可以，怎么实现？兄弟，貌似不可以啊，如果不可以为什么还要问怎么实现？一点思路都没有，又一想到Handler这个源码每次都是看了忘，遂再次走读源码并做个笔记。

# Looper
```java
    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

```

## ThreadLocal
暂时不纠结源码，反正被他修饰的变量都会为每个线程拷贝一份副本，使得多线程可以无冲突的访问同一个变量且互相不影响。所以这个就保证了上面的prepare方法只会被调用1次，以及每个线程有且只有一个Looper。

## 循环
```java
 public static void loop() {
        final Looper me = myLooper();
        final MessageQueue queue = me.mQueue;
        for (;;) {
            Message msg = queue.next(); // might block
            try {
                msg.target.dispatchMessage(msg);
            } finally {
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
         }
    }

```
取出消息，调用`msg.target.dispatchMessage`

# Handler
```java
    public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
```
## CallBack

```java
    public interface Callback {
        public boolean handleMessage(Message msg);
    }
```
没啥用，在处理的时候发现如果有Callback就调用Callback的handleMessage，就是不想写个类来实现自己的Handler的话使用这个回调来处理Message。

## 发送
```java
    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + " sendMessageAtTime() called with no mQueue");
            Log.w("Looper", e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }
    
        private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
```
主要设置了msg.target=当前的handler 以及调用MessageQueue来enqueue消息
## 处理
```java
    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
```
回调handleMessage

# 内存泄露
通常我们写主线程写Handler的时候，都是
```java
Handler handler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
        }
    };
```
ide这个时候会报一个内存泄露的警告，因为当Activity被关闭，
```java
Handler handler = new Handler(new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            return false;
        }
    });
```

# 参考
[ThreadLocal](http://blog.csdn.net/lufeng20/article/details/24314381)